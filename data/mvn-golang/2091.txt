SEVERITY = 4

package com.igormaznitsa.mvngolang;
import com.igormaznitsa.meta.annotation.MustNotContainNull;
import com.igormaznitsa.mvngolang.utils.*;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.filefilter.FileFilterUtils;
import org.apache.commons.io.filefilter.TrueFileFilter;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.shared.transfer.artifact.resolve.ArtifactResolverException;
import org.zeroturnaround.zip.ZipUtil;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import static com.igormaznitsa.meta.common.utils.Assertions.assertNotNull;
public abstract class AbstractGoDependencyAwareMojo extends AbstractGolangMojo {
  public static final String GO_MOD_FILE_NAME_BAK = ".#go.mod.mvn.orig";
  public static final String DELETE_GO_SUM_FLAG_FILE = ".#go.mod.mvn.delete.sum";
  @Parameter(name = "deleteSumFile", defaultValue = "false")
  private boolean deleteSumFile = false;
  private String extraGoPathSectionInOsFormat = "";
  @Parameter(name = "scanDependencies", defaultValue = "true")
  private boolean scanDependencies = true;
  @Parameter(name = "includeTestDependencies", defaultValue = "true")
  private boolean includeTestDependencies = true;
  @Parameter(name = "dependencyTempFolder", defaultValue = "${project.build.directory}${file.separator}.__deps__")
  private String dependencyTempFolder;
  @Parameter(name = "syncSessionIfModules", defaultValue = "true")
  private boolean syncSessionIfModules;
  public boolean isSyncSessionIfModules() {
    return Boolean.parseBoolean(findMvnProperty("mvn.golang.sync.session.if.modules",
            Boolean.toString(this.syncSessionIfModules)));
  }
  public void setSyncSessionIfModules(final boolean value) {
    this.syncSessionIfModules = value;
  }
  @Nonnull
  public String getDependencyTempFolder() {
    return this.dependencyTempFolder;
  }
  public boolean isDeleteSumFile() {
    return Boolean.parseBoolean(findMvnProperty("mvn.golang.delete.sum.file",
            Boolean.toString(this.deleteSumFile)));
  }
  public void setDependencyTempFolder(@Nonnull final String path) {
    this.dependencyTempFolder = assertNotNull(path);
  }
  public boolean isScanDependencies() {
    return this.scanDependencies;
  }
  public void setScanDependencies(final boolean flag) {
    this.scanDependencies = flag;
  }
  public boolean isIncludeTestDependencies() {
    return this.includeTestDependencies;
  }
  public void setIncludeTestDependencies(final boolean value) {
    this.includeTestDependencies = value;
  }
  @Nonnull
  private String makeRelativePathToFolder(@Nonnull final File goModFile,
                                          @Nonnull final File folder) {
    return goModFile.toPath().relativize(folder.toPath()).toString();
  }
  @Nonnull
  @MustNotContainNull
  private List<Tuple<Artifact, Tuple<GoMod, File>>> findModsInProject() throws IOException {
    final File sourceFolder = this.getSources(false);
    if (sourceFolder.isDirectory()) {
      return findGoModsAndParse(Collections
              .singletonList(Tuple.of(this.getProject().getArtifact(), sourceFolder)));
    } else {
      return Collections.emptyList();
    }
  }
  private void preprocessModules(
          @Nonnull @MustNotContainNull final List<Tuple<Artifact, File>> unpackedDependencyFolders)
          throws MojoExecutionException {
    try {
      final List<Tuple<Artifact, Tuple<GoMod, File>>> lst =
              preprocessModuleFilesInDependencies(unpackedDependencyFolders);
      final List<Tuple<GoMod, File>> dependencyGoMods = listRightPart(lst);
      final List<Tuple<Artifact, Tuple<GoMod, File>>> projectGoMods = findModsInProject();
      for (final Tuple<Artifact, Tuple<GoMod, File>> f : projectGoMods) {
        final File goModFile = f.right().right();
        final File workingFolder = goModFile.getParentFile();
        final File sumFile = new File(workingFolder, GO_SUM_FILE_NAME);
        final File goModFileBak = new File(workingFolder, GO_MOD_FILE_NAME_BAK);
        final File deleteSumFileFlag = new File(workingFolder, DELETE_GO_SUM_FLAG_FILE);
        final boolean deleteSum = this.isDeleteSumFile();
        if (deleteSum) {
          this.getLog().warn("SUM file will be deleted for artifact: " + f.left());
        }
        if (goModFileBak.isFile()) {
          if (goModFile.isFile() && !goModFile.delete()) {
            throw new IOException("Can't delete go.mod file: " + goModFile);
          }
          if (deleteSum && deleteSumFileFlag.isFile() && sumFile.isFile() && !sumFile.delete()) {
            throw new IOException("Can't delete file " + sumFile);
          }
          FileUtils.copyFile(goModFileBak, goModFile);
        } else {
          if (goModFile.isFile()) {
            FileUtils.copyFile(goModFile, goModFileBak);
          }
          if (deleteSum && !sumFile.isFile() && !deleteSumFileFlag.isFile() &&
                  !deleteSumFileFlag.createNewFile()) {
            throw new IOException("Can't create file " + deleteSumFileFlag);
          }
        }
        if (goModFile.isFile()) {
          final GoMod parsed =
                  GoMod.from(FileUtils.readFileToString(goModFile, StandardCharsets.UTF_8));
          if (replaceLinksToModules(Tuple.of(parsed, goModFile), dependencyGoMods)) {
            FileUtils.write(goModFile, parsed.toString(), StandardCharsets.UTF_8);
          }
          if (deleteSum && sumFile.isFile() && !deleteSumFileFlag.isFile() &&
                  !deleteSumFileFlag.createNewFile()) {
            throw new IOException("Can't create file " + deleteSumFileFlag);
          }
        }
      }
    } catch (IOException ex) {
      throw new MojoExecutionException("Can't process a go.mod file", ex);
    }
  }
  @Nonnull
  @MustNotContainNull
  private List<Tuple<Artifact, Tuple<GoMod, File>>> findGoModsAndParse(
          @Nonnull @MustNotContainNull final List<Tuple<Artifact, File>> unpackedFolders)
          throws IOException {
    final List<Tuple<Artifact, Tuple<GoMod, File>>> result = new ArrayList<>();
    for (final Tuple<Artifact, File> tuple : unpackedFolders) {
      for (final File f : FileUtils
              .listFiles(tuple.right(), FileFilterUtils.nameFileFilter("go.mod"),
                      TrueFileFilter.INSTANCE)) {
        final GoMod model = GoMod.from(FileUtils.readFileToString(f, StandardCharsets.UTF_8));
        result.add(Tuple.of(tuple.left(), Tuple.of(model, f)));
      }
    }
    return result;
  }
  private boolean replaceLinksToModules(@Nonnull final Tuple<GoMod, File> source,
                                        @Nonnull @MustNotContainNull final List<Tuple<GoMod, File>> targets) throws IOException {
    boolean changed = false;
    for (final Tuple<GoMod, File> j : targets) {
      if (!source.equals(j)) {
        final GoMod thatParsedGoMod = j.left();
        final File thatGoModFile = j.right();
        if (source.left().hasRequireFor(thatParsedGoMod.getModule(), null) &&
                !source.left().hasReplaceFor(thatParsedGoMod.getModule(), null)) {
          final String relativePath = makeRelativePathToFolder(source.right().getParentFile(),
                  thatGoModFile.getParentFile());
          source.left().addItem(
                  new GoMod.GoReplace(new GoMod.ModuleInfo(thatParsedGoMod.getModule()),
                          new GoMod.ModuleInfo(relativePath)));
          changed = true;
        }
      }
    }
    return changed;
  }
  @Nonnull
  @MustNotContainNull
  private List<Tuple<GoMod, File>> listRightPart(
          @Nonnull @MustNotContainNull final List<Tuple<Artifact, Tuple<GoMod, File>>> list) {
    final List<Tuple<GoMod, File>> parsed = new ArrayList<>();
    for (final Tuple<Artifact, Tuple<GoMod, File>> i : list) {
      parsed.add(i.right());
    }
    return parsed;
  }
  private int generateCrossLinksBetweenArtifactGoMods(
          @Nonnull @MustNotContainNull final List<Tuple<Artifact, Tuple<GoMod, File>>> unpackedFolders)
          throws IOException {
    int changes = 0;
    final List<Tuple<GoMod, File>> parsed = listRightPart(unpackedFolders);
    for (final Tuple<GoMod, File> i : parsed) {
      if (replaceLinksToModules(i, parsed)) {
        changes++;
        FileUtils.write(i.right(), i.left().toString(), StandardCharsets.UTF_8);
      }
    }
    return changes;
  }
  @Nonnull
  @MustNotContainNull
  private List<Tuple<Artifact, Tuple<GoMod, File>>> preprocessModuleFilesInDependencies(
          @Nonnull @MustNotContainNull final List<Tuple<Artifact, File>> unpackedFolders)
          throws IOException {
    getLog().debug("Finding go.mod descriptors in unpacked artifacts");
    final List<Tuple<Artifact, Tuple<GoMod, File>>> foundAndParsedGoMods =
            findGoModsAndParse(unpackedFolders);
    getLog().debug(String.format("Found %d go.mod descriptors", foundAndParsedGoMods.size()));
    final int changedGoModCounter = generateCrossLinksBetweenArtifactGoMods(foundAndParsedGoMods);
    getLog().debug(
            String.format("Changed %d go.mod descriptors in unpacked artifacts", changedGoModCounter));
    return foundAndParsedGoMods;
  }
  @Override
  public final void doInit() throws MojoFailureException, MojoExecutionException {
    super.doInit();
    if (this.isModuleMode()) {
      try {
        final File src = this.getSources(false);
        this.restoreGoModFromBackupAndRemoveBackup(src);
      } catch (IOException ex) {
        throw new MojoExecutionException(
                "Error during restoring of detected go.mod backup in source folder", ex);
      }
    }
    if (this.isScanDependencies()) {
      getLog().info("Scanning maven dependencies");
      final List<Tuple<Artifact, File>> foundArtifacts;
      try {
        foundArtifacts = MavenUtils.scanForMvnGoArtifacts(
                this.getProject(),
                this.isIgnoreNonResolvableArtifact(),
                this.isIncludeTestDependencies(),
                this,
                this.getSession(),
                this.getExecution(),
                this.getArtifactResolver(),
                this.getRemoteRepositories());
      } catch (ArtifactResolverException ex) {
        throw new MojoFailureException("Can't resolve artifact", ex);
      }
      if (foundArtifacts.isEmpty()) {
        getLog().debug("Mvn golang dependencies are not found");
        if (this.isModuleMode()) {
          this.preprocessModules(Collections.emptyList());
        }
        this.extraGoPathSectionInOsFormat = "";
      } else {
        getLog().debug("Found mvn-golang artifacts: " + foundArtifacts);
        final File dependencyTempTargetFolder = new File(this.getDependencyTempFolder());
        getLog().debug("Dependencies will be unpacked into folder: " + dependencyTempTargetFolder);
        final List<Tuple<Artifact, File>> unpackedFolders =
                unpackArtifactsIntoFolder(foundArtifacts, dependencyTempTargetFolder);
        if (this.isModuleMode()) {
          this.getLog().info("Module mode is activated");
          this.preprocessModules(unpackedFolders);
          this.getLog().info("Dependencies are not added into GOPATH because module mode is on");
        } else {
          final List<File> unpackedFolderList = new ArrayList<>();
          for (final Tuple<Artifact, File> f : unpackedFolders) {
            unpackedFolderList.add(f.right());
          }
          final String preparedExtraPartForGoPath =
                  IOUtils.makeOsFilePathWithoutDuplications(unpackedFolderList.toArray(new File[0]));
          getLog().debug("Prepared dependency path for GOPATH: " + preparedExtraPartForGoPath);
          this.extraGoPathSectionInOsFormat = preparedExtraPartForGoPath;
        }
      }
    } else {
      getLog().info("Maven dependency scanning is off");
    }
  }
  public boolean isIgnoreNonResolvableArtifact() {
    return false;
  }
  private void restoreGoModFromBackupAndRemoveBackup(@Nonnull final File folder)
          throws IOException {
    final Collection<File> backupFiles = FileUtils
            .listFiles(folder, FileFilterUtils.nameFileFilter(GO_MOD_FILE_NAME_BAK),
                    TrueFileFilter.INSTANCE);
    this.getLog().debug(String
            .format("Restoring go.mod from backup in %s, detected %d files", folder,
                    backupFiles.size()));
    for (final File backup : backupFiles) {
      final File workingFolder = backup.getParentFile();
      final File restored = new File(workingFolder, GO_MOD_FILE_NAME);
      final File goSumFile = new File(workingFolder, GO_SUM_FILE_NAME);
      final File deleteGoSumFileFlag = new File(workingFolder, DELETE_GO_SUM_FLAG_FILE);
      if (restored.isFile() && !restored.delete()) {
        throw new IOException("Can't delete file during backup restore: " + restored);
      }
      if (!backup.renameTo(restored)) {
        throw new IOException("Can't rename backup: " + backup + " -> " + restored);
      }
      if (this.isDeleteSumFile()) {
        if (deleteGoSumFileFlag.isFile()) {
          if (!deleteGoSumFileFlag.delete()) {
            throw new IOException("Can't delete file " + deleteGoSumFileFlag);
          }
          if (goSumFile.isFile() && !goSumFile.delete()) {
            throw new IOException("Can't delete file " + goSumFile);
          }
        }
      }
    }
  }
  @Override
  public void afterExecution(@Nullable final ProxySettings proxySettings, final boolean error)
          throws MojoFailureException, MojoExecutionException {
    try {
      if (this.isModuleMode()) {
        this.getLog().debug("module mode is on");
        final File srcFolder = this.getSources(false);
        this.getLog().debug("Detected source folder: " + srcFolder);
        if (srcFolder.isDirectory()) {
          if (this.isRestoreGoMod()) {
            this.getLog().debug("Restoring go.mod from backup in source folder: " + srcFolder);
            this.restoreGoModFromBackupAndRemoveBackup(srcFolder);
          } else {
            this.getLog().debug("Restoring of go.mod from backup is disabled by project property");
          }
        } else {
          this.getLog()
                  .debug("Restore backup mod files is ignored because source folder is not directory");
        }
      } else {
        this.getLog().debug("module mode is off");
      }
    } catch (IOException ex) {
      throw new MojoExecutionException("Error during restore go.mod from backup", ex);
    } finally {
      super.afterExecution(proxySettings, error);
    }
  }
  @Override
  protected boolean doesNeedSessionLock() {
    return this.getSession().isParallel() && this.isModuleMode() && this.isSyncSessionIfModules();
  }
  protected boolean isRestoreGoMod() {
    return Boolean.parseBoolean(MavenUtils
            .findProperty(this.getSession(), this.getProject(), "mvn.golang.restore.go.mod", "true"));
  }
  @Nonnull
  @MustNotContainNull
  private List<Tuple<Artifact, File>> unpackArtifactsIntoFolder(@Nonnull
                                                                @MustNotContainNull final List<Tuple<Artifact, File>> zippedArtifacts,
                                                                @Nonnull final File targetFolder)
          throws MojoExecutionException {
    final List<Tuple<Artifact, File>> resultFolders = new ArrayList<>();
    if (!targetFolder.isDirectory() && !targetFolder.mkdirs()) {
      throw new MojoExecutionException(
              "Can't create folder to unpack dependencies: " + targetFolder);
    }
    for (final Tuple<Artifact, File> zipFile : zippedArtifacts) {
      if (this.isVerbose()) {
        this.getLog().info("mvn-golang dependency: " + zipFile.left());
      }
      final File outDir =
              new File(targetFolder, FilenameUtils.getBaseName(zipFile.right().getName()));
      final boolean doUnpackArch;
      if (outDir.isDirectory()) {
        this.getLog().debug("Unpacked dependency folder already exists: " + outDir);
        if (Boolean.parseBoolean(MavenUtils
                .findProperty(this.getSession(), this.getProject(), "mvn.golang.force.clean.dependency",
                        "false"))) {
          this.getLog().debug("Forcing dependency folder delete: " + outDir);
          try {
            FileUtils.deleteDirectory(outDir);
          } catch (IOException ex) {
            throw new MojoExecutionException("Can't delete dependency folder: " + outDir, ex);
          }
          doUnpackArch = true;
        } else {
          getLog().debug("Ignoring dependency unpack because folder exists: " + outDir);
          doUnpackArch = false;
        }
      } else {
        doUnpackArch = true;
      }
      if (doUnpackArch) {
        if (ZipUtil
                .containsEntry(zipFile.right(), GolangMvnInstallMojo.MVNGOLANG_BUILD_FOLDERS_FILE)) {
          final File srcTargetFolder = new File(outDir, "src");
          try {
            unzipSrcFoldersContent(zipFile.right(), srcTargetFolder);
          } catch (Exception ex) {
            throw new MojoExecutionException(
                    "Can't unpack source folders from dependency archive '" +
                            zipFile.right().getName() + "' into folder '" + srcTargetFolder + '\'', ex);
          }
        } else {
          try {
            getLog().debug("Unpack dependency archive: " + zipFile);
            ZipUtil.unpack(zipFile.right(), outDir, StandardCharsets.UTF_8);
          } catch (Exception ex) {
            throw new MojoExecutionException(
                    "Can't unpack dependency archive '" + zipFile.right().getName() +
                            "' into folder '" + targetFolder + '\'', ex);
          }
        }
      }
      resultFolders.add(Tuple.of(zipFile.left(), outDir));
    }
    return resultFolders;
  }
  private boolean unzipSrcFoldersContent(@Nonnull final File artifactZip,
                                         @Nonnull final File targetFolder) {
    final byte[] buildFolderListFile =
            ZipUtil.unpackEntry(artifactZip, GolangMvnInstallMojo.MVNGOLANG_BUILD_FOLDERS_FILE);
    if (buildFolderListFile == null) {
      return false;
    } else {
      final List<String> folderList = new ArrayList<>();
      for (final String folder : new String(buildFolderListFile, StandardCharsets.UTF_8)
              .split("\\n")) {
        final String trimmed = folder.trim();
        if (trimmed.isEmpty()) {
          continue;
        }
        folderList.add(folder + '/');
      }
      for (final String folder : folderList) {
        ZipUtil.unpack(artifactZip, targetFolder, (@Nonnull final String name) -> {
          if (name.startsWith(folder)) {
            return name.substring(folder.length());
          }
          return null;
        });
      }
      return true;
    }
  }
  @Nonnull
  @Override
  protected final String getSpecialPartOfGoPath() {
    return this.extraGoPathSectionInOsFormat;
  }
}
______
package com.igormaznitsa.mvngolang;
import com.igormaznitsa.meta.annotation.MustNotContainNull;
import com.igormaznitsa.mvngolang.utils.MavenUtils;
import com.igormaznitsa.mvngolang.utils.ProxySettings;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.NotImplementedException;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.model.Model;
import org.apache.maven.model.Resource;
import org.apache.maven.model.io.xpp3.MavenXpp3Writer;
import org.apache.maven.plugins.annotations.*;
import org.apache.maven.project.MavenProject;
import org.apache.maven.project.MavenProjectHelper;
import org.apache.maven.shared.transfer.artifact.install.ArtifactInstaller;
import org.apache.maven.shared.transfer.repository.RepositoryManager;
import org.zeroturnaround.zip.ZipUtil;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import static com.igormaznitsa.mvngolang.utils.IOUtils.closeSilently;
@Mojo(name = "mvninstall", defaultPhase = LifecyclePhase.INSTALL, threadSafe = true, requiresDependencyResolution = ResolutionScope.COMPILE)
public class GolangMvnInstallMojo extends AbstractGoDependencyAwareMojo {
  public static final String MVNGOLANG_DEPENDENCIES_FILE = ".mvn-golang-dependencies";
  public static final String MVNGOLANG_BUILD_FOLDERS_FILE = ".mvn-golang-build-folders";
  @Component
  protected RepositoryManager repositoryManager;
  @Component
  protected ArtifactInstaller installer;
  @Component
  protected MavenProjectHelper projectHelper;
  @Parameter(name = "compression", defaultValue = "9")
  private int compression;
  public int getCompression() {
    return this.compression;
  }
  public void setCompression(final int level) {
    this.compression = level;
  }
  @Nullable
  @Override
  protected String getSkipMojoPropertySuffix() {
    return "install";
  }
  @Override
  public boolean isSkip() {
    return super.isSkip()
            || Boolean.parseBoolean(MavenUtils
            .findProperty(this.getSession(), this.getProject(), "maven.install.skip", "false"));
  }
  @Override
  protected boolean doMainBusiness(@Nullable final ProxySettings proxySettings,
                                   final int maxAttempts)
          throws IOException {
    final File archive = compressProjectFiles();
    this.getProject().getArtifact().setFile(archive);
    return false;
  }
  private void safeCopyDirectory(@Nullable final String src, @Nonnull final File dst,
                                 @Nullable @MustNotContainNull final List<File> dstList)
          throws IOException {
    if (!(src == null || src.isEmpty())) {
      final File srcFile = new File(src);
      if (srcFile.isDirectory()) {
        if (getLog().isDebugEnabled()) {
          getLog().debug(
                  String.format("Copying %s => %s", srcFile.getAbsolutePath(), dst.getAbsolutePath()));
        }
        FileUtils.copyDirectoryToDirectory(srcFile, dst);
        if (dstList != null) {
          dstList.add(new File(dst, srcFile.getName()));
        }
      }
    }
  }
  private void saveEffectivePom(@Nonnull final File folder) throws IOException {
    final Model model = this.getProject().getModel();
    Writer writer = null;
    try {
      writer = new OutputStreamWriter(new FileOutputStream(new File(folder, "pom.xml"), false),
              StandardCharsets.UTF_8);
      new MavenXpp3Writer().write(writer, model);
      if (getLog().isDebugEnabled()) {
        getLog().debug("Effective pom has been written");
      }
    } finally {
      closeSilently(writer);
    }
  }
  @Nonnull
  private File compressProjectFiles() throws IOException {
    final Artifact artifact = this.getProject().getArtifact();
    File buildFolder = new File(this.getProject().getBuild().getDirectory());
    if (!buildFolder.isDirectory() && !buildFolder.mkdirs()) {
      this.getLog().error("Can't create build folder: " + buildFolder);
      throw new IOException("Can't create build folder: " + buildFolder);
    }
    File resultZip = new File(buildFolder,
            artifact.getArtifactId() + '-' + artifact.getVersion() + '.' + artifact.getType());
    if (resultZip.isFile() && !resultZip.delete()) {
      throw new IOException("Can't delete file : " + resultZip);
    }
    final File folderToPack = new File(buildFolder, ".tmp_pack_folder_" +
            Long.toHexString(System.currentTimeMillis()).toUpperCase(Locale.ENGLISH));
    if (folderToPack.isDirectory()) {
      FileUtils.deleteDirectory(folderToPack);
    }
    if (!folderToPack.mkdirs()) {
      throw new IOException("Can't create temp folder : " + folderToPack);
    }
    final File mvnGolangDependencyListFile = new File(folderToPack, MVNGOLANG_DEPENDENCIES_FILE);
    final File mvnGolangBuildFolderListFile = new File(folderToPack, MVNGOLANG_BUILD_FOLDERS_FILE);
    try {
      saveEffectivePom(folderToPack);
      final List<File> buildFolders = new ArrayList<>();
      FileUtils.copyFileToDirectory(this.getProject().getFile(), folderToPack);
      safeCopyDirectory(this.getProject().getBuild().getTestSourceDirectory(), folderToPack, null);
      for (final Resource res : this.getProject().getBuild().getTestResources()) {
        safeCopyDirectory(res.getDirectory(), folderToPack, null);
      }
      for (final Resource res : this.getProject().getBuild().getResources()) {
        safeCopyDirectory(res.getDirectory(), folderToPack, buildFolders);
      }
      safeCopyDirectory(this.getSources(false).getAbsolutePath(), folderToPack, buildFolders);
      if (getLog().isDebugEnabled()) {
        getLog().debug(String.format("Packing folder %s to %s", folderToPack.getAbsolutePath(),
                resultZip.getAbsolutePath()));
      }
      if (mvnGolangBuildFolderListFile.isFile()) {
        this.getLog().warn(
                "Skip build source folder list descriptor create because detected existing one: " +
                        MVNGOLANG_BUILD_FOLDERS_FILE);
      } else {
        if (buildFolders.isEmpty()) {
          this.getLog().warn(
                  "Skip build source folder list descriptor because there is not either source or resource folder for build");
        } else {
          final String rooPath = FilenameUtils
                  .separatorsToUnix(FilenameUtils.normalize(folderToPack.getAbsolutePath()));
          final StringBuilder buffer = new StringBuilder();
          for (final File f : buildFolders) {
            String relativePath =
                    FilenameUtils.separatorsToUnix(FilenameUtils.normalize(f.getAbsolutePath()))
                            .substring(rooPath.length() + 1);
            if (buffer.length() > 0) {
              buffer.append('\n');
            }
            this.getLog().debug("Add build folder into descriptor: " + relativePath);
            buffer.append(relativePath);
          }
          final String fileContent = buffer.toString();
          this.getLog().debug(
                  "Formed list of mvn-golang project source and resource build folders\n---------" +
                          fileContent + "---------");
          FileUtils
                  .writeStringToFile(mvnGolangBuildFolderListFile, fileContent, StandardCharsets.UTF_8);
        }
      }
      if (mvnGolangDependencyListFile.isFile()) {
        this.getLog().warn("Skip dependency descriptor create because detected existing one: " +
                MVNGOLANG_DEPENDENCIES_FILE);
      } else {
        final List<Artifact> golangDependencies = new ArrayList<>();
        MavenProject currentProject = this.getProject();
        while (currentProject != null && !Thread.currentThread().isInterrupted()) {
          final Set<Artifact> dependencies = currentProject.getDependencyArtifacts();
          if (dependencies != null) {
            for (final Artifact a : dependencies) {
              if (AbstractGolangMojo.GOARTIFACT_PACKAGING.equals(a.getType())) {
                golangDependencies.add(a);
              }
            }
          }
          currentProject = currentProject.getParent();
        }
        final StringBuilder buffer = new StringBuilder();
        for (final Artifact a : golangDependencies) {
          buffer.append(MavenUtils.makeArtifactRecord(a)).append('\n');
        }
        final String flagFileContent = buffer.toString();
        this.getLog().debug(
                "Formed list of mvn-golang dependencies\n---------" + flagFileContent + "---------");
        FileUtils.writeStringToFile(mvnGolangDependencyListFile, flagFileContent,
                StandardCharsets.UTF_8);
      }
      this.getLog().debug("Restoring all backup go.mod in prepared folder to pack");
      restoreAllBackupGoMod(folderToPack);
      ZipUtil.pack(folderToPack, resultZip, Math.min(9, Math.max(1, this.compression)));
    } finally {
      FileUtils.deleteQuietly(folderToPack);
    }
    return resultZip;
  }
  private void restoreAllBackupGoMod(@Nonnull final File folder) throws IOException {
    final File backup = new File(folder, GO_MOD_FILE_NAME_BAK);
    if (backup.isFile()) {
      final File gomod = new File(folder, GO_MOD_FILE_NAME);
      if (gomod.isFile() && !gomod.delete()) {
        throw new IOException("Can't delete " + gomod);
      }
      if (!backup.renameTo(gomod)) {
        throw new IOException("Can't rename " + backup);
      }
    }
    final File[] foundFiles = folder.listFiles(
        pathname -> pathname.isDirectory() && !Files.isSymbolicLink(pathname.toPath()));
    if (foundFiles != null) {
      for (final File f : foundFiles) {
        restoreAllBackupGoMod(f);
      }
    }
  }
  @Nonnull
  @MustNotContainNull
  @Override
  public String[] getTailArguments() {
    throw new NotImplementedException("Must not be called");
  }
  @Nonnull
  @Override
  public String getGoCommand() {
    throw new NotImplementedException("Must not be called");
  }
  @Nonnull
  @MustNotContainNull
  @Override
  public String[] getCommandFlags() {
    throw new NotImplementedException("Must not be called");
  }
}
______
package com.igormaznitsa.mvngolang.utils;
import com.igormaznitsa.meta.annotation.MustNotContainNull;
import com.igormaznitsa.meta.common.utils.GetUtils;
import com.igormaznitsa.mvngolang.AbstractGolangMojo;
import com.igormaznitsa.mvngolang.GolangMvnInstallMojo;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.DefaultArtifact;
import org.apache.maven.artifact.handler.ArtifactHandler;
import org.apache.maven.artifact.repository.ArtifactRepository;
import org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;
import org.apache.maven.artifact.versioning.VersionRange;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecution;
import org.apache.maven.project.DefaultProjectBuildingRequest;
import org.apache.maven.project.MavenProject;
import org.apache.maven.project.ProjectBuildingRequest;
import org.apache.maven.shared.transfer.artifact.resolve.ArtifactResolver;
import org.apache.maven.shared.transfer.artifact.resolve.ArtifactResolverException;
import org.apache.maven.shared.transfer.artifact.resolve.ArtifactResult;
import org.zeroturnaround.zip.ZipUtil;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public final class MavenUtils {
  private static final Pattern ARTIFACT_RECORD_PATTERN =
      Pattern.compile("^([^:]+)::([^:]+)::([^:]*)::([^:]*)::([^:]*)::([^:]*)$");
  private MavenUtils() {
  }
  public static boolean isTestPhase(@Nonnull final MojoExecution execution) {
    final String phase = execution.getLifecyclePhase();
    return phase != null && (phase.equals("test") || phase.equals("process-test-resources") ||
        phase.equals("test-compile"));
  }
  @Nonnull
  public static ProjectBuildingRequest makeResolveArtifactProjectBuildingRequest(
      @Nonnull final MavenSession session,
      @Nonnull @MustNotContainNull final List<ArtifactRepository> remoteRepositories
  ) {
    final ProjectBuildingRequest result =
        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
    result.setRemoteRepositories(remoteRepositories);
    result.setLocalRepository(session.getLocalRepository());
    return result;
  }
  @Nonnull
  public static Artifact parseArtifactRecord(
      @Nonnull final String record,
      @Nonnull final ArtifactHandler handler
  ) throws InvalidVersionSpecificationException {
    final Matcher matcher = ARTIFACT_RECORD_PATTERN.matcher(record.trim());
    if (matcher.find()) {
      return new DefaultArtifact(
          matcher.group(1),
          matcher.group(2),
          VersionRange.createFromVersion(matcher.group(3)),
          matcher.group(4).isEmpty() ? null : matcher.group(4),
          matcher.group(5).isEmpty() ? null : matcher.group(5),
          matcher.group(6).isEmpty() ? null : matcher.group(6),
          handler);
    }
    throw new IllegalArgumentException("Can't recognize record as artifact: " + record);
  }
  @Nonnull
  public static String makeArtifactRecord(@Nonnull final Artifact artifact) {
    return artifact.getGroupId() +
        "::" + artifact.getArtifactId() +
        "::" + artifact.getVersionRange().toString() +
        "::" + GetUtils.ensureNonNull(artifact.getScope(), "compile") +
        "::" + GetUtils.ensureNonNull(artifact.getType(), "zip") +
        "::" + GetUtils.ensureNonNull(artifact.getClassifier(), "");
  }
  @Nonnull
  @MustNotContainNull
  public static List<Tuple<Artifact, File>> scanForMvnGoArtifacts(
          @Nonnull final MavenProject mavenProject,
          final boolean ignoreNonResolvedArtifact,
          final boolean includeTestDependencies,
          @Nonnull final AbstractMojo mojo,
          @Nonnull final MavenSession session,
          @Nonnull final MojoExecution execution,
          @Nonnull final ArtifactResolver resolver,
          @Nonnull @MustNotContainNull final List<ArtifactRepository> remoteRepositories
  ) throws ArtifactResolverException {
    final List<Tuple<Artifact, File>> result = new ArrayList<>();
    final Set<String> alreadyFoundArtifactRecords = new HashSet<>();
    MavenProject currentProject = mavenProject;
    while (currentProject != null && !Thread.currentThread().isInterrupted()) {
      final Set<Artifact> projectDependencies = currentProject.getDependencyArtifacts();
      final List<Artifact> artifacts = new ArrayList<>(
          projectDependencies == null ? Collections.emptySet() : projectDependencies);
      mojo.getLog().debug("Detected dependency artifacts: " + artifacts);
      while (!artifacts.isEmpty() && !Thread.currentThread().isInterrupted()) {
        final Artifact artifact = artifacts.remove(0);
        if (Artifact.SCOPE_TEST.equals(artifact.getScope()) && !includeTestDependencies) {
          continue;
        }
        if (artifact.getType().equals(AbstractGolangMojo.GOARTIFACT_PACKAGING)) {
          final ArtifactResult artifactResult;
          try {
            artifactResult = resolver.resolveArtifact(
                    makeResolveArtifactProjectBuildingRequest(session, remoteRepositories), artifact);
          } catch (ArtifactResolverException ex) {
            if (ignoreNonResolvedArtifact) {
              mojo.getLog().debug("Can't resolve artifact: " + artifact, ex);
              continue;
            } else {
              throw ex;
            }
          }
          final File zipFilePath = artifactResult.getArtifact().getFile();
          mojo.getLog().debug(
                  "Detected MVN-GOLANG marker inside ZIP dependency: " + artifact.getGroupId() + ':' +
                          artifact.getArtifactId() + ':' + artifact.getVersion() + ':' +
                          artifact.getType());
          if (ZipUtil
                  .containsEntry(zipFilePath, GolangMvnInstallMojo.MVNGOLANG_DEPENDENCIES_FILE)) {
            final byte[] artifactFlagFile = ZipUtil
                .unpackEntry(zipFilePath, GolangMvnInstallMojo.MVNGOLANG_DEPENDENCIES_FILE,
                    StandardCharsets.UTF_8);
            for (final String str : new String(artifactFlagFile, StandardCharsets.UTF_8)
                .split("\\R")) {
              if (str.trim().isEmpty() || alreadyFoundArtifactRecords.contains(str)) {
                continue;
              }
              mojo.getLog().debug("Adding mvn-golang dependency: " + str);
              alreadyFoundArtifactRecords.add(str);
              try {
                artifacts.add(parseArtifactRecord(str, new MvnGolangArtifactHandler()));
              } catch (InvalidVersionSpecificationException ex) {
                throw new ArtifactResolverException("Can't make artifact: " + str, ex);
              }
            }
          }
          final File artifactFile = artifactResult.getArtifact().getFile();
          mojo.getLog().debug("Artifact file: " + artifactFile);
          if (doesContainFile(result, artifactFile)) {
            mojo.getLog().debug("Artifact file ignored as duplication: " + artifactFile);
          } else {
            result.add(Tuple.of(artifact, artifactFile));
          }
        }
      }
      currentProject = currentProject.hasParent() ? currentProject.getParent() : null;
    }
    return result;
  }
  private static boolean doesContainFile(
      @Nonnull @MustNotContainNull final List<Tuple<Artifact, File>> list,
      @Nonnull final File file) {
    boolean result = false;
    for (final Tuple<Artifact, File> t : list) {
      if (t.right().equals(file)) {
        result = true;
        break;
      }
    }
    return result;
  }
  @Nullable
  public static String findProperty(
      @Nonnull final MavenSession session,
      @Nonnull final MavenProject project,
      @Nonnull final String key,
      @Nullable final String defaultValue
  ) {
    final Properties properties = new Properties(project.getProperties());
    properties.putAll(session.getSystemProperties());
    properties.putAll(session.getUserProperties());
    return properties.getProperty(key, defaultValue);
  }
}
______
package com.igormaznitsa.mvngolang;
import static com.igormaznitsa.meta.common.utils.Assertions.assertNotNull;
import static com.igormaznitsa.mvngolang.utils.MavenUtils.findProperty;
import com.igormaznitsa.meta.annotation.LazyInited;
import com.igormaznitsa.meta.annotation.MayContainNull;
import com.igormaznitsa.meta.annotation.MustNotContainNull;
import com.igormaznitsa.meta.annotation.ReturnsOriginal;
import com.igormaznitsa.meta.common.utils.ArrayUtils;
import com.igormaznitsa.meta.common.utils.GetUtils;
import com.igormaznitsa.meta.common.utils.StrUtils;
import com.igormaznitsa.mvngolang.utils.IOUtils;
import com.igormaznitsa.mvngolang.utils.ProxySettings;
import com.igormaznitsa.mvngolang.utils.SysUtils;
import com.igormaznitsa.mvngolang.utils.UnpackUtils;
import com.igormaznitsa.mvngolang.utils.WildCardMatcher;
import com.igormaznitsa.mvngolang.utils.XGoogHashHeader;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringReader;
import java.net.InetAddress;
import java.net.URLEncoder;
import java.net.UnknownHostException;
import java.nio.charset.Charset;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;
import java.util.regex.Pattern;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.filefilter.FileFilterUtils;
import org.apache.commons.io.filefilter.TrueFileFilter;
import org.apache.commons.lang3.SystemUtils;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpException;
import org.apache.http.HttpHost;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.StatusLine;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.NTCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.HttpClient;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.routing.HttpRoute;
import org.apache.http.conn.routing.HttpRoutePlanner;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.BasicHttpClientConnectionManager;
import org.apache.http.impl.conn.DefaultProxyRoutePlanner;
import org.apache.http.protocol.HttpContext;
import org.apache.http.util.EntityUtils;
import org.apache.maven.artifact.repository.ArtifactRepository;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecution;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.apache.maven.settings.Proxy;
import org.apache.maven.settings.Settings;
import org.apache.maven.shared.transfer.artifact.resolve.ArtifactResolver;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.zeroturnaround.exec.ProcessExecutor;
import org.zeroturnaround.exec.ProcessResult;
public abstract class AbstractGolangMojo extends AbstractMojo {
  public static final String GOARTIFACT_PACKAGING = "mvn-golang";
  public static final String GO_MOD_FILE_NAME = "go.mod";
  public static final String GO_SUM_FILE_NAME = "go.sum";
  public static final String ENV_GO111MODULE = "GO111MODULE";
  public static final String NAME_PATTERN = "go%s.%s-%s%s";
  private static final List<String> ALLOWED_SDKARCHIVE_CONTENT_TYPE = Collections.unmodifiableList(
      Arrays.asList("application/octet-stream", "application/zip", "application/x-tar",
          "application/x-gzip"));
  private static final ReentrantLock LOCKER = new ReentrantLock();
  private static final String[] BANNER =
      new String[] {"______  ___             _________     ______",
          "___   |/  /__   __________  ____/________  / ______ ______________ _",
          "__  /|_/ /__ | / /_  __ \\  / __ _  __ \\_  /  _  __ `/_  __ \\_  __ `/",
          "_  /  / / __ |/ /_  / / / /_/ / / /_/ /  /___/ /_/ /_  / / /  /_/ / ",
          "/_/  /_/  _____/ /_/ /_/\\____/  \\____
          "                                                           /____/",
          "                  https:
          ""
      };
  private static final Pattern GOBINFOLDER_PATTERN = Pattern
      .compile("(?:\\\\|/)go[0-9\\-\\+.]*(?:\\\\|/)bin(?:\\\\|/)?$", Pattern.CASE_INSENSITIVE);
  protected final Set<String> buildFlagsToIgnore = new HashSet<>();
  protected final List<String> tempBuildFlags = new ArrayList<>();
  @Parameter(defaultValue = "${settings}", readonly = true)
  protected Settings settings;
  @Component
  private ArtifactResolver artifactResolver;
  @Parameter(defaultValue = "${project.remoteArtifactRepositories}", readonly = true, required = true)
  private List<ArtifactRepository> remoteRepositories;
  @Parameter(defaultValue = "${project}", readonly = true, required = true)
  private MavenProject project;
  @Parameter(defaultValue = "${session}", readonly = true, required = true)
  private MavenSession session;
  @Parameter(defaultValue = "${mojoExecution}", readonly = true, required = true)
  private MojoExecution execution;
  @Parameter(name = "moduleMode", defaultValue = "false")
  private boolean moduleMode;
  @Parameter(name = "workingDir")
  private String workingDir;
  @Parameter(defaultValue = "true", name = "filterEnvPath")
  private boolean filterEnvPath = true;
  @Parameter(name = "checkSdkHash", defaultValue = "true")
  private boolean checkSdkHash = true;
  @Parameter(name = "useMavenProxy", defaultValue = "true")
  private boolean useMavenProxy;
  @Parameter(name = "disableSSLcheck", defaultValue = "false")
  private boolean disableSSLcheck;
  @Parameter(name = "supposeSdkArchiveFileName", defaultValue = "true")
  private boolean supposeSdkArchiveFileName;
  @Parameter(name = "proxy")
  private ProxySettings proxy;
  @Parameter(name = "skip", defaultValue = "false")
  private boolean skip;
  @Parameter(name = "ignoreErrorExitCode", defaultValue = "false")
  private boolean ignoreErrorExitCode;
  @Parameter(name = "reportsFolder", defaultValue = "${project.build.directory}${file.separator}reports")
  private String reportsFolder;
  @Parameter(name = "outLogFile")
  private String outLogFile;
  @Parameter(name = "errLogFile")
  private String errLogFile;
  @Parameter(name = "sdkSite", defaultValue = "https:
  private String sdkSite;
  @Parameter(defaultValue = "true", name = "hideBanner")
  private boolean hideBanner;
  @Parameter(defaultValue = "${user.home}${file.separator}.mvnGoLang", name = "storeFolder")
  private String storeFolder;
  @Parameter(defaultValue = "${user.home}${file.separator}.mvnGoLang${file.separator}.go_path", name = "goPath")
  private String goPath;
  private String target386;
  @Parameter(name = "targetArm")
  private String targetArm;
  @Parameter(defaultValue = "${project.build.directory}", name = "goBin")
  private String goBin;
  @Parameter(name = "goVersion", defaultValue = "1.21.7")
  private String goVersion;
  @Parameter(name = "goCache", defaultValue = "${project.build.directory}${file.separator}.goBuildCache")
  private String goCache;
  @Parameter(name = "goRoot")
  private String goRoot;
  @Parameter(name = "goRootBootstrap")
  private String goRootBootstrap;
  @Parameter(name = "enforceGoPathToEnd", defaultValue = "false")
  private boolean enforceGoPathToEnd;
  @Parameter(name = "execSubpath", defaultValue = "bin")
  private String execSubpath;
  @Parameter(name = "exec", defaultValue = "go")
  private String exec;
  @Parameter(name = "echoWarn")
  private String[] echoWarn;
  @Parameter(name = "echo")
  private String[] echo;
  @Parameter(name = "disableSdkLoad", defaultValue = "false")
  private boolean disableSdkLoad;
  @Parameter(defaultValue = "${project.build.sourceDirectory}", name = "sources")
  private String sources;
  @Parameter(name = "targetOs")
  private String targetOs;
  @Parameter(name = "os")
  private String os;
  @Parameter(name = "targetArch")
  private String targetArch;
  @Parameter(name = "arch")
  private String arch;
  @Parameter(name = "osxVersion")
  private String osxVersion;
  @Parameter(name = "buildFlags")
  private String[] buildFlags;
  @Parameter(name = "verbose", defaultValue = "false")
  private boolean verbose;
  @Parameter(name = "keepSdkArchive", defaultValue = "false")
  private boolean keepSdkArchive;
  @Parameter(name = "useGoTool")
  private String useGoTool;
  @Parameter(name = "useEnvVars", defaultValue = "false")
  private boolean useEnvVars;
  @Parameter(name = "env")
  private Map<?, ?> env;
  @Parameter(name = "sdkArchiveName")
  private String sdkArchiveName;
  @Parameter(name = "sdkDownloadUrl")
  private String sdkDownloadUrl;
  @Parameter(name = "connectionTimeout", defaultValue = "60000")
  private int connectionTimeout = 60000;
  @Parameter(name = "keepUnarchFolderIfError", defaultValue = "false")
  private boolean keepUnarchFolderIfError;
  @Parameter(name = "addToGoPath")
  private String[] addToGoPath;
  @LazyInited
  private CloseableHttpClient httpClient;
  @LazyInited
  private ByteArrayOutputStream consoleErrBuffer;
  @LazyInited
  private ByteArrayOutputStream consoleOutBuffer;
  @Nonnull
  private static String ensureNoSurroundingSlashes(@Nonnull final String str) {
    String result = str;
    if (!result.isEmpty() && (result.charAt(0) == '/' || result.charAt(0) == '\\')) {
      result = result.substring(1);
    }
    if (!result.isEmpty() &&
        (result.charAt(result.length() - 1) == '/' || result.charAt(result.length() - 1) == '\\')) {
      result = result.substring(0, result.length() - 1);
    }
    return result;
  }
  private static void deleteFileIfExists(@Nonnull final File file) throws IOException {
    if (file.isFile() && !file.delete()) {
      throw new IOException("Can't delete file : " + file);
    }
  }
  private static boolean isSafeEmpty(@Nullable final String value) {
    return value == null || value.isEmpty();
  }
  @Nonnull
  private static String extractExtensionOfArchive(@Nonnull final String archiveName) {
    final String lcName = archiveName.toLowerCase(Locale.ENGLISH);
    final String result;
    if (lcName.endsWith(".tar.gz")) {
      result = archiveName.substring(archiveName.length() - "tar.gz".length());
    } else {
      result = FilenameUtils.getExtension(archiveName);
    }
    return result;
  }
  @Nonnull
  protected static String adaptExecNameForOS(@Nonnull final String execName) {
    return execName + (SystemUtils.IS_OS_WINDOWS ? ".exe" : "");
  }
  @Nonnull
  private static String getPathToFolder(@Nonnull final String path) {
    String text = path;
    if (!text.endsWith("/") && !text.endsWith("\\")) {
      text = text + File.separatorChar;
    }
    return text;
  }
  @Nonnull
  private static String getPathToFolder(@Nonnull final File path) {
    return getPathToFolder(path.getAbsolutePath());
  }
  @Nullable
  protected static File findExisting(@Nonnull @MayContainNull final File... files) {
    File result = null;
    for (final File f : files) {
      if (f != null && f.isFile()) {
        result = f;
        break;
      }
    }
    return result;
  }
  @Nonnull
  private static String removeSrcFolderAtEndIfPresented(@Nonnull final String text) {
    String result = text;
    if (text.endsWith("/src") || text.endsWith("\\src")) {
      result = text.substring(0, text.length() - 4);
    }
    return result;
  }
  @Nonnull
  private static String extractComputerName() {
    String result = System.getenv("COMPUTERNAME");
    if (result == null) {
      result = System.getenv("HOSTNAME");
    }
    if (result == null) {
      try {
        result = InetAddress.getLocalHost().getHostName();
      } catch (UnknownHostException ex) {
      }
    }
    return GetUtils.ensureNonNull(result, "<Unknown computer>");
  }
  @Nonnull
  private static String extractDomainName() {
    final String result = System.getenv("USERDOMAIN");
    return GetUtils.ensureNonNull(result, "");
  }
  private static boolean tryRenameFolder(@Nonnull final File sourceFolder, @Nonnull final File targetFolder,
                                         final int attempts, final long retryDelayMs) {
    boolean result = false;
    for (int i = 0; i < attempts && !result; i++) {
      result = sourceFolder.renameTo(targetFolder);
      if (!result && i < attempts - 1) {
        try {
          Thread.sleep(retryDelayMs);
        } catch (InterruptedException ex) {
          Thread.currentThread().interrupt();
          return false;
        }
      }
    }
    return result;
  }
  @Nullable
  private static String nullIfBlank(@Nullable final String text) {
    return text == null || text.trim().isEmpty() ? null : text;
  }
  @Nullable
  public final String getWorkingDir() {
    return this.workingDir;
  }
  public final void setWorkingDir(@Nullable final String path) {
    this.workingDir = path;
  }
  public boolean isModuleMode() {
    return Boolean
        .parseBoolean(findMvnProperty("mvn.golang.module.mode", Boolean.toString(this.moduleMode)));
  }
  public void setModuleMode(final boolean value) {
    this.moduleMode = value;
  }
  @Nonnull
  public ArtifactResolver getArtifactResolver() {
    return assertNotNull("Artifact resolver component is not provided by Maven",
        this.artifactResolver);
  }
  @Nonnull
  @MustNotContainNull
  public List<ArtifactRepository> getRemoteRepositories() {
    return this.remoteRepositories;
  }
  protected boolean doesNeedSessionLock() {
    return false;
  }
  @Nonnull
  private String makeSessionLockFileName() {
    final String id =
        Long.toHexString(this.getSession().getStartTime().getTime()).toUpperCase(Locale.ENGLISH);
    return ".#mvn.go.session.lock." + id;
  }
  @Nonnull
  protected File getTempFileFolder() {
    return new File(System.getProperty("java.io.tmpdir"));
  }
  private void lockMvnGolangSession() throws MojoExecutionException {
    final File lockFile = new File(this.getTempFileFolder(), makeSessionLockFileName());
    this.getLog().debug("Locking project for mvn-golang sync processing, locker file: " + lockFile);
    while (!Thread.currentThread().isInterrupted()) {
      final boolean locked;
      try {
        locked = lockFile.createNewFile();
      } catch (IOException ex) {
        throw new MojoExecutionException(
            "Detected error during attempt to make locker file: " + lockFile, ex);
      }
      if (locked) {
        lockFile.deleteOnExit();
        this.getLog().debug("Locking file created: " + lockFile);
        return;
      } else {
        try {
          Thread.sleep(100);
        } catch (InterruptedException ex) {
          Thread.currentThread().interrupt();
          break;
        }
      }
    }
  }
  private void unlockMvnGolangSession() throws MojoExecutionException {
    final File locker = new File(this.getTempFileFolder(), makeSessionLockFileName());
    this.getLog().debug("Unlocking project for mvn-golang sync processing, locker file: " + locker);
    if (locker.isFile()) {
      if (!locker.delete()) {
        throw new MojoExecutionException("Can't delete locker file: " + locker);
      }
    } else {
      this.getLog().warn("Can't detect locker file, may be it was removed externally: " + locker);
    }
  }
  @Nonnull
  private File loadSDKAndUnpackIntoCache(
      @Nullable final ProxySettings proxySettings,
      @Nonnull final File cacheFolder,
      @Nonnull final String baseSdkName,
      final boolean notLoadIfNotInCache
  ) throws IOException, MojoExecutionException {
    synchronized (AbstractGolangMojo.class) {
      final File sdkFolder = new File(cacheFolder, baseSdkName);
      if (sdkFolder.isDirectory()) {
        return sdkFolder;
      }
      final File lockFile = new File(cacheFolder, ".lck" + baseSdkName);
      lockFile.deleteOnExit();
      try {
        if (!lockFile.createNewFile()) {
          this.getLog().info("Detected SDK loading, waiting for the process end");
          while (lockFile.exists()) {
            try {
              Thread.sleep(100L);
            } catch (InterruptedException ex) {
              throw new IOException("Wait of SDK loading is interrupted", ex);
            }
          }
          this.getLog().info("Loading process has been completed");
          return sdkFolder;
        }
        if (sdkFolder.isDirectory()) {
          if (this.isVerbose() || this.getLog().isDebugEnabled()) {
            this.getLog().info("SDK cache folder : " + sdkFolder);
          }
          return sdkFolder;
        } else if (notLoadIfNotInCache || this.session.isOffline()) {
          this.getLog().error(
              "Can't find cached Golang SDK and downloading is disabled or Maven in offline mode");
          throw new IOException(
              "Can't find " + baseSdkName + " in the cache but loading is directly disabled");
        }
        final String predefinedLink = this.getSdkDownloadUrl();
        final File archiveFile;
        final String linkForDownloading;
        if (isSafeEmpty(predefinedLink)) {
          this.logOptionally("There is not any predefined SDK URL");
          final String sdkFileName = this.findSdkArchiveFileName(proxySettings, baseSdkName);
          archiveFile = new File(cacheFolder, sdkFileName);
          linkForDownloading = this.getSdkSite() + sdkFileName;
        } else {
          final String extension = extractExtensionOfArchive(assertNotNull(predefinedLink));
          archiveFile = new File(cacheFolder, baseSdkName + '.' + extension);
          linkForDownloading = predefinedLink;
          this.logOptionally("Using predefined URL to download SDK : " + linkForDownloading);
          this.logOptionally("Detected extension of archive : " + extension);
        }
        if (archiveFile.exists()) {
          this.logOptionally(
              "Detected existing archive " + archiveFile + ", deleting it and reload");
          if (!archiveFile.delete()) {
            throw new IOException("Can't delete archive file: " + archiveFile);
          }
        }
        final HttpGet methodGet = new HttpGet(linkForDownloading);
        final RequestConfig config =
            this.processRequestConfig(proxySettings, this.getConnectionTimeout(),
                RequestConfig.custom()).build();
        methodGet.setConfig(config);
        boolean errorsDuringLoading = true;
        boolean showProgressBar;
        try {
          if (!archiveFile.isFile()) {
            this.getLog().warn("Loading SDK archive with URL : " + linkForDownloading);
            final HttpResponse response = this.getHttpClient(proxySettings).execute(methodGet);
            final StatusLine statusLine = response.getStatusLine();
            this.getLog().debug("HttpResponse: " + response);
            if (statusLine.getStatusCode() != HttpStatus.SC_OK) {
              throw new IOException(String
                  .format("Can't load SDK archive from %s : %d %s", linkForDownloading,
                      statusLine.getStatusCode(), statusLine.getReasonPhrase()));
            }
            final XGoogHashHeader xGoogHash =
                new XGoogHashHeader(response.getHeaders("x-goog-hash"));
            this.getLog().debug("XGoogHashHeader: " + xGoogHash);
            final HttpEntity entity = response.getEntity();
            final Header contentType = entity.getContentType();
            if (!ALLOWED_SDKARCHIVE_CONTENT_TYPE.contains(contentType.getValue())) {
              throw new IOException("Unsupported content type : " + contentType.getValue());
            }
            final long size = entity.getContentLength();
            try (final InputStream inStream = entity.getContent()) {
              showProgressBar = size > 0L && !this.session.isParallel();
              this.getLog().info("Downloading SDK archive into file : " + archiveFile);
              long loadedCounter = 0L;
              final byte[] buffer = new byte[1024 * 1024];
              int lastRenderedValue = -1;
              final int PROGRESSBAR_WIDTH = 10;
              final String LOADING_TITLE = "Loading " + size / (1024L * 1024L) + " Mb ";
              if (showProgressBar) {
                lastRenderedValue = IOUtils
                    .printTextProgressBar(LOADING_TITLE, 0, size, PROGRESSBAR_WIDTH,
                        lastRenderedValue);
              }
              final OutputStream fileOutStream =
                  new BufferedOutputStream(new FileOutputStream(archiveFile), 128 * 16384);
              try {
                while (!Thread.currentThread().isInterrupted()) {
                  final int readCounter = inStream.read(buffer);
                  if (readCounter < 0) {
                    break;
                  }
                  fileOutStream.write(buffer, 0, readCounter);
                  loadedCounter += readCounter;
                  if (showProgressBar) {
                    lastRenderedValue = IOUtils
                        .printTextProgressBar(LOADING_TITLE, loadedCounter, size, PROGRESSBAR_WIDTH,
                            lastRenderedValue);
                  }
                }
              } finally {
                if (showProgressBar) {
                  System.out.println();
                }
                IOUtils.closeSilently(fileOutStream);
              }
              if (Thread.currentThread().isInterrupted()) {
                throw new MojoExecutionException("Interrupted");
              }
              this.getLog().info("Archived SDK has been succesfully downloaded, its size is " +
                  (archiveFile.length() / 1024L) + " Kb");
            }
            if (this.isCheckSdkHash()) {
              if (xGoogHash.isValid() && xGoogHash.hasData()) {
                this.getLog().debug("Checking hash of file");
                final boolean fileHashOk = xGoogHash.isFileOk(this.getLog(), archiveFile);
                if (fileHashOk) {
                  this.getLog().info("Downloaded archive file hash is OK");
                } else {
                  this.getLog().error("Downloaded archive file hash is BAD");
                  throw new MojoExecutionException("Downloaded SDK archive has wrong hash");
                }
              } else {
                if (!xGoogHash.isValid()) {
                  throw new MojoExecutionException(
                      "Couldn't parse x-goog-hash from response: " + response);
                } else {
                  throw new MojoExecutionException(
                      "Parsed x-goog-hash doesn't contain data but marked as valid one: " +
                          xGoogHash);
                }
              }
            }
          } else {
            this.getLog().info("Archive file of SDK has been found in the cache : " + archiveFile);
          }
          errorsDuringLoading = false;
          final File interFolder =
              this.unpackArchToFolder(archiveFile, "go", new File(cacheFolder, ".#" + baseSdkName));
          this.getLog().info("Renaming " + interFolder.getName() + " to " + sdkFolder.getName());
          if (tryRenameFolder(interFolder, sdkFolder, 3, 5000L)) {
            this.logOptionally("Renamed successfully: " + interFolder + " -> " + sdkFolder);
          } else {
            throw new IOException(
                "Can't rename temp GoSDK folder: " + interFolder + " -> " + sdkFolder);
          }
          return sdkFolder;
        } finally {
          methodGet.releaseConnection();
          if (errorsDuringLoading || !this.isKeepSdkArchive()) {
            this.logOptionally("Deleting archive : " + archiveFile +
                (errorsDuringLoading ? " (because error during loading)" : ""));
            deleteFileIfExists(archiveFile);
          } else {
            this.logOptionally("Archive file is kept for special flag : " + archiveFile);
          }
        }
      } finally {
        final boolean deleted = FileUtils.deleteQuietly(lockFile);
        this.getLog().debug("Lock file " + lockFile + " deleted : " + deleted);
      }
    }
  }
  public boolean isFilterEnvPath() {
    return this.filterEnvPath;
  }
  @Nullable
  protected String findMvnProperty(@Nonnull final String key, @Nullable final String dflt) {
    if (this.session == null || this.project == null) {
      return null;
    }
    return findProperty(this.session, this.project, key, dflt);
  }
  public boolean isSkip() {
    final boolean result =
        Boolean.parseBoolean(findMvnProperty("mvn.golang.skip", Boolean.toString(this.skip)));
    final String skipMojoSuffix = this.getSkipMojoPropertySuffix();
    return skipMojoSuffix == null ? result : result
        || Boolean.parseBoolean(
        findMvnProperty(String.format("mvn.golang.%s.skip", skipMojoSuffix), "false"));
  }
  public boolean isEnforceGoPathToEnd() {
    return this.enforceGoPathToEnd;
  }
  @Nonnull
  public MavenProject getProject() {
    return this.project;
  }
  @Nonnull
  public MojoExecution getExecution() {
    return this.execution;
  }
  @Nonnull
  public MavenSession getSession() {
    return this.session;
  }
  public boolean isIgnoreErrorExitCode() {
    return this.ignoreErrorExitCode;
  }
  @Nonnull
  public Map<?, ?> getEnv() {
    return GetUtils.ensureNonNull(this.env, Collections.EMPTY_MAP);
  }
  @Nullable
  public String getSdkDownloadUrl() {
    return this.sdkDownloadUrl;
  }
  @Nonnull
  public String getExecSubpath() {
    return ensureNoSurroundingSlashes(assertNotNull(this.execSubpath));
  }
  public int getConnectionTimeout() {
    return this.connectionTimeout;
  }
  @Nonnull
  public String getExec() {
    return ensureNoSurroundingSlashes(assertNotNull(this.exec));
  }
  public boolean isUseEnvVars() {
    return this.useEnvVars;
  }
  public boolean isKeepSdkArchive() {
    return this.keepSdkArchive;
  }
  public boolean isKeepUnarchFolderIfError() {
    return this.keepUnarchFolderIfError;
  }
  @Nullable
  public String getSdkArchiveName() {
    return this.sdkArchiveName;
  }
  @Nonnull
  public String getReportsFolder() {
    return this.reportsFolder;
  }
  @Nullable
  public String getOutLogFile() {
    return this.outLogFile;
  }
  @Nullable
  public String getErrLogFile() {
    return this.errLogFile;
  }
  public boolean isCheckSdkHash() {
    return this.checkSdkHash;
  }
  @Nonnull
  public String getStoreFolder() {
    return this.storeFolder;
  }
  @Nullable
  public String getUseGoTool() {
    return this.useGoTool;
  }
  public boolean isVerbose() {
    return Boolean
        .parseBoolean(findMvnProperty("mvn.golang.verbose", Boolean.toString(this.verbose)));
  }
  public boolean isDisableSdkLoad() {
    return this.disableSdkLoad;
  }
  @Nonnull
  public String getSdkSite() {
    return assertNotNull(this.sdkSite);
  }
  @Nonnull
  @MustNotContainNull
  public String[] getBuildFlags() {
    final List<String> result = new ArrayList<>();
    for (final String s : ArrayUtils
        .joinArrays(GetUtils.ensureNonNull(this.buildFlags, ArrayUtils.EMPTY_STRING_ARRAY),
            getExtraBuildFlags())) {
      if (!this.buildFlagsToIgnore.contains(s)) {
        result.add(s);
      }
    }
    result.addAll(this.tempBuildFlags);
    return result.toArray(new String[0]);
  }
  @Nonnull
  @MustNotContainNull
  protected String[] getExtraBuildFlags() {
    return ArrayUtils.EMPTY_STRING_ARRAY;
  }
  @Nonnull
  @MustNotContainNull
  public File[] findGoPath(final boolean ensureExist) throws IOException {
    LOCKER.lock();
    try {
      final String foundGoPath = getGoPath();
      if (getLog().isDebugEnabled()) {
        getLog().debug("findGoPath(" + ensureExist + "), getGoPath() returns " + foundGoPath);
      }
      final List<File> result = new ArrayList<>();
      for (final String p : foundGoPath.split(String.format("\\%s", File.pathSeparator))) {
        final File folder = new File(p);
        result.add(folder);
        if (ensureExist && !folder.isDirectory() && !folder.mkdirs()) {
          throw new IOException("Can't create folder for GOPATH : " + folder.getAbsolutePath());
        }
      }
      return result.toArray(new File[0]);
    } finally {
      LOCKER.unlock();
    }
  }
  @Nullable
  public File findGoRootBootstrap(final boolean ensureExist) throws IOException {
    LOCKER.lock();
    try {
      final String value = getGoRootBootstrap();
      File result = null;
      if (value != null) {
        result = new File(value);
        if (ensureExist && !result.isDirectory()) {
          throw new IOException("Can't find folder for GOROOT_BOOTSTRAP: " + result);
        }
      }
      return result;
    } finally {
      LOCKER.unlock();
    }
  }
  @Nonnull
  public String getOs() {
    String result = this.os;
    if (isSafeEmpty(result)) {
      if (isSafeEmpty(result)) {
        result = assertNotNull(String.format("Can't recognize OS: %s", SystemUtils.OS_NAME),
            SysUtils.findGoSdkOsType());
      }
    }
    return result;
  }
  @Nullable
  public String getArch() {
    String result = this.arch;
    if (isSafeEmpty(result)) {
      result = assertNotNull(String.format("Can't recognize ARCH: %s", SystemUtils.OS_ARCH),
          SysUtils.decodeGoSdkArchType(SystemUtils.OS_ARCH));
    }
    return result;
  }
  @Nullable
  private String getValueOrEnv(@Nonnull final String varName, @Nullable final String configValue) {
    final String foundInEnvironment = System.getenv(varName);
    String result = configValue;
    if (foundInEnvironment != null && isUseEnvVars()) {
      if (!isSafeEmpty(configValue)) {
        getLog().warn(String.format("Value %s is replaced by environment value.", varName));
      }
      result = foundInEnvironment;
    }
    return result;
  }
  @Nullable
  public String getGoRoot() {
    return getValueOrEnv("GOROOT", this.goRoot);
  }
  @Nullable
  public String getGoCache() {
    return getValueOrEnv("GOCACHE", this.goCache);
  }
  @Nullable
  public String getGoRootBootstrap() {
    return getValueOrEnv("GOROOT_BOOTSTRAP", this.goRootBootstrap);
  }
  @Nullable
  public String getGoBin() {
    String result = getValueOrEnv("GOBIN", this.goBin);
    return "NONE".equals(result) ? null : result;
  }
  @Nonnull
  public String getGoPath() {
    return assertNotNull(getValueOrEnv("GOPATH", this.goPath));
  }
  @Nullable
  public String getTargetArm() {
    return getValueOrEnv("GOARM", this.targetArm);
  }
  @Nullable
  public String getTarget386() {
    return getValueOrEnv("GO386", this.target386);
  }
  @Nullable
  public String getTargetOS() {
    return getValueOrEnv("GOOS", this.targetOs);
  }
  @Nullable
  public String getTargetArch() {
    return getValueOrEnv("GOARCH", this.targetArch);
  }
  public boolean isUseMavenProxy() {
    return this.useMavenProxy;
  }
  public boolean getSupposeSdkArchiveFileName() {
    return this.supposeSdkArchiveFileName;
  }
  public boolean isDisableSslCheck() {
    return this.disableSSLcheck || Boolean.parseBoolean(
        findProperty(this.getSession(), this.getProject(), "mvn.golang.disable.ssl.check",
            "false"));
  }
  public void setDisableSslCheck(final boolean flag) {
    this.disableSSLcheck = flag;
  }
  @Nullable
  public ProxySettings getProxy() {
    return this.proxy;
  }
  @Nullable
  public String getOSXVersion() {
    return this.osxVersion;
  }
  @Nonnull
  public String getGoVersion() {
    return findProperty(this.session, this.project, "mvn.golang.go.version", this.goVersion);
  }
  @Nonnull
  public File getSources(final boolean ensureExist) throws IOException {
    final File result = new File(this.sources);
    if (ensureExist && !result.isDirectory()) {
      throw new IOException("Can't find GoLang project sources : " + result);
    }
    return result;
  }
  protected void addTmpBuildFlagIfNotPresented(@Nonnull @MustNotContainNull final String... flags) {
    for (final String s : flags) {
      if (this.tempBuildFlags.contains(s)) {
        continue;
      }
      boolean found = false;
      if (this.buildFlags != null) {
        for (final String b : this.buildFlags) {
          if (s.equals(b)) {
            found = true;
            break;
          }
        }
      }
      if (!found) {
        this.tempBuildFlags.add(s);
      }
    }
  }
  @Nullable
  private ProxySettings extractProxySettings() {
    final ProxySettings result;
    if (this.isUseMavenProxy()) {
      final Proxy activeMavenProxy = this.settings == null ? null : this.settings.getActiveProxy();
      result = activeMavenProxy == null ? null : new ProxySettings(activeMavenProxy);
      getLog().debug("Detected maven proxy : " + result);
    } else {
      result = this.proxy;
      if (result != null) {
        getLog().debug("Defined proxy : " + result);
      }
    }
    return result;
  }
  @ReturnsOriginal
  @Nonnull
  private RequestConfig.Builder processRequestConfig(@Nullable final ProxySettings proxySettings,
                                                     final int timeout,
                                                     @Nonnull final RequestConfig.Builder config) {
    this.getLog()
        .debug("Connection(timeout=" + timeout + "ms, proxySettings=" + proxySettings + ')');
    if (proxySettings != null) {
      final HttpHost proxyHost =
          new HttpHost(proxySettings.host, proxySettings.port, proxySettings.protocol);
      config.setProxy(proxyHost);
    }
    return config.setConnectTimeout(timeout).setSocketTimeout(timeout);
  }
  @Nonnull
  private String loadGoLangSdkList(@Nullable final ProxySettings proxySettings,
                                   @Nullable final String keyPrefix)
      throws IOException, MojoExecutionException {
    final String sdksite = getSdkSite() + (keyPrefix == null ? "" : "?prefix=" + keyPrefix);
    getLog().warn("Loading list of available GoLang SDKs from " + sdksite);
    final HttpGet get = new HttpGet(sdksite);
    final RequestConfig config =
        processRequestConfig(proxySettings, this.getConnectionTimeout(), RequestConfig.custom())
            .build();
    get.setConfig(config);
    get.addHeader("Accept", "application/xml");
    try {
      final HttpResponse response = getHttpClient(proxySettings).execute(get);
      final StatusLine statusLine = response.getStatusLine();
      if (statusLine.getStatusCode() == HttpStatus.SC_OK) {
        final String content = EntityUtils.toString(response.getEntity());
        getLog().info("GoLang SDK list has been loaded successfuly");
        getLog().debug(content);
        return content;
      } else {
        throw new IOException(String
            .format("Can't load list of SDKs from %s : %d %s", sdksite, statusLine.getStatusCode(),
                statusLine.getReasonPhrase()));
      }
    } finally {
      get.releaseConnection();
    }
  }
  @Nonnull
  private Document convertSdkListToDocument(@Nonnull final String sdkListAsString)
      throws IOException {
    try {
      final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      final DocumentBuilder builder = factory.newDocumentBuilder();
      return builder.parse(new InputSource(new StringReader(sdkListAsString)));
    } catch (ParserConfigurationException ex) {
      getLog().error("Can't configure XML parser", ex);
      throw new IOException("Can't configure XML parser", ex);
    } catch (SAXException ex) {
      getLog().error("Can't parse document", ex);
      throw new IOException("Can't parse document", ex);
    } catch (IOException ex) {
      getLog().error("Unexpected IOException", ex);
      throw new IOException("Unexpected IOException", ex);
    }
  }
  private void printEcho() {
    if (this.echoWarn != null) {
      for (final String s : this.echoWarn) {
        getLog().warn(s);
      }
    }
    if (this.echo != null) {
      for (final String s : this.echo) {
        getLog().info(s);
      }
    }
  }
  protected void logOptionally(@Nonnull final String message) {
    if (getLog().isDebugEnabled() || this.verbose) {
      getLog().info(message);
    }
  }
  protected void initConsoleBuffers() {
    getLog().debug("Initing console out and console err buffers");
    this.consoleErrBuffer = new ByteArrayOutputStream();
    this.consoleOutBuffer = new ByteArrayOutputStream();
  }
  @ReturnsOriginal
  @Nonnull
  private File unpackArchToFolder(@Nonnull final File archiveFile,
                                  @Nonnull final String folderInArchive,
                                  @Nonnull final File destinationFolder) throws IOException {
    getLog().info(String.format("Unpacking archive %s to folder %s", archiveFile.getName(),
        destinationFolder.getName()));
    boolean detectedError = true;
    try {
      final int unpackedFileCounter = UnpackUtils
          .unpackFileToFolder(getLog(), folderInArchive, archiveFile, destinationFolder, true);
      if (unpackedFileCounter == 0) {
        throw new IOException(
            "Couldn't find folder '" + folderInArchive + "' in archive or the archive is empty");
      } else {
        getLog().info("Unpacked " + unpackedFileCounter + " file(s)");
      }
      detectedError = false;
    } finally {
      if (detectedError && !isKeepUnarchFolderIfError()) {
        logOptionally("Deleting folder because error during unpack : " + destinationFolder);
        FileUtils.deleteQuietly(destinationFolder);
      }
    }
    return destinationFolder;
  }
  @Nonnull
  private String extractSDKFileName(@Nonnull final String listUrl, @Nonnull final Document doc,
                                    @Nonnull final String sdkBaseName,
                                    @Nonnull @MustNotContainNull final String[] allowedExtensions)
      throws IOException {
    getLog().debug("Looking for SDK started with base name : " + sdkBaseName);
    final Set<String> variants = new HashSet<>();
    for (final String ext : allowedExtensions) {
      variants.add(sdkBaseName + '.' + ext);
    }
    final List<String> listedSdk = new ArrayList<>();
    final Element root = doc.getDocumentElement();
    if ("ListBucketResult".equals(root.getTagName())) {
      final NodeList list = root.getElementsByTagName("Contents");
      for (int i = 0; i < list.getLength(); i++) {
        final Element element = (Element) list.item(i);
        final NodeList keys = element.getElementsByTagName("Key");
        if (keys.getLength() > 0) {
          final String text = keys.item(0).getTextContent();
          if (variants.contains(text)) {
            logOptionally("Detected compatible SDK in the SDK list : " + text);
            return text;
          } else {
            listedSdk.add(text);
          }
        }
      }
      if (this.supposeSdkArchiveFileName) {
        final String supposedSdkName =
            sdkBaseName + '.' + (SystemUtils.IS_OS_WINDOWS ? "zip" : "tar.gz");
        getLog().warn("Can't find SDK file in the loaded list");
        getLog().debug("..................................................");
        for (final String s : listedSdk) {
          getLog().debug(s);
        }
        getLog().debug("..................................................");
        getLog().warn("Supposed name of SDK archive is " + supposedSdkName +
            ", trying to load it directly! It can be disabled with <supposeSdkArchiveFileName>false</supposeSdkArchiveFileName>)");
        return supposedSdkName;
      }
      getLog().error("Can't find any SDK to be used as " + sdkBaseName);
      getLog().error("GoLang list contains listed SDKs (" + listUrl + ")");
      getLog().error(
          "It is possible directly define link to SDK through configuration parameter <sdkDownloadUrl>..</sdkDownloadUrl>");
      getLog().error("..................................................");
      for (final String s : listedSdk) {
        getLog().error(s);
      }
      throw new IOException("Can't find SDK : " + sdkBaseName);
    } else {
      throw new IOException("It is not a ListBucket file [" + root.getTagName() + ']');
    }
  }
  @Nonnull
  private String findSdkArchiveFileName(@Nullable final ProxySettings proxySettings,
                                        @Nonnull final String sdkBaseName)
      throws IOException, MojoExecutionException {
    String result = getSdkArchiveName();
    if (isSafeEmpty(result)) {
      final Document parsed = convertSdkListToDocument(
          loadGoLangSdkList(proxySettings, URLEncoder.encode(sdkBaseName, "UTF-8")));
      result =
          extractSDKFileName(getSdkSite(), parsed, sdkBaseName, new String[] {"tar.gz", "zip"});
    } else {
      getLog().info("SDK archive name is predefined : " + result);
    }
    return GetUtils.ensureNonNullStr(result);
  }
  private void warnIfContainsUC(@Nonnull final String message, @Nonnull final String str) {
    boolean detected = false;
    for (final char c : str.toCharArray()) {
      if (Character.isUpperCase(c)) {
        detected = true;
        break;
      }
    }
    if (detected) {
      getLog().warn(message + " : " + str);
    }
  }
  @Nonnull
  protected File findGoRoot(@Nullable final ProxySettings proxySettings)
      throws IOException, MojoFailureException, MojoExecutionException {
    final File result;
    LOCKER.lock();
    try {
      final String predefinedGoRoot = this.getGoRoot();
      if (isSafeEmpty(predefinedGoRoot)) {
        final File cacheFolder = new File(this.storeFolder);
        if (!cacheFolder.isDirectory()) {
          if (cacheFolder.isFile()) {
            throw new IOException("Can't create folder '" + cacheFolder +
                "' because there is presented a file with such name!");
          }
          logOptionally("Making SDK cache folder : " + cacheFolder);
          FileUtils.forceMkdir(cacheFolder);
        }
        final String definedOsxVersion = this.getOSXVersion();
        final String sdkVersion = this.getGoVersion();
        this.getLog().debug(
            String.format("SdkVersion = %s, osxVersion = %s", sdkVersion, definedOsxVersion));
        if (isSafeEmpty(sdkVersion)) {
          throw new MojoFailureException("GoLang SDK version is not defined!");
        }
        final String sdkBaseName = String
            .format(NAME_PATTERN, sdkVersion, this.getOs(), this.getArch(),
                isSafeEmpty(definedOsxVersion) ? "" : "-" + definedOsxVersion);
        warnIfContainsUC("Prefer usage of lower case chars only for SDK base name", sdkBaseName);
        result =
            loadSDKAndUnpackIntoCache(proxySettings, cacheFolder, sdkBaseName, isDisableSdkLoad());
      } else {
        logOptionally("Detected predefined SDK root folder : " + predefinedGoRoot);
        result = new File(predefinedGoRoot);
        if (!result.isDirectory()) {
          throw new MojoFailureException("Predefined SDK root is not a directory : " + result);
        }
      }
    } finally {
      LOCKER.unlock();
    }
    return result;
  }
  private void printBanner() {
    for (final String s : BANNER) {
      getLog().info(s);
    }
  }
  public boolean isHideBanner() {
    return this.hideBanner;
  }
  protected boolean doesNeedOneMoreAttempt(@Nonnull final ProcessResult result,
                                           @Nonnull final String consoleOut,
                                           @Nonnull final String consoleErr)
      throws IOException, MojoExecutionException {
    return false;
  }
  protected void doLogging(
      final int resultCode,
      final boolean error,
      @Nonnull final String outLog,
      @Nonnull final String errLog
  ) throws MojoExecutionException {
    if (getLog().isDebugEnabled()) {
      getLog().debug("OUT_LOG: " + outLog);
      getLog().debug("ERR_LOG: " + errLog);
    }
    this.processLogFiles(outLog, errLog);
    this.printLogs(
        error || isEnforcePrintOutput() || (this.isVerbose() && this.isCommandSupportVerbose()),
        error, outLog, errLog);
  }
  protected boolean doMainBusiness(@Nullable final ProxySettings proxySettings,
                                   final int maxAttempts)
      throws InterruptedException, MojoFailureException, MojoExecutionException, IOException {
    int iterations = 0;
    boolean error = false;
    while (!Thread.currentThread().isInterrupted()) {
      final ProcessExecutor executor = prepareExecutor(proxySettings);
      if (executor == null) {
        logOptionally("The Mojo should not be executed");
        break;
      }
      final ProcessResult result = executor.executeNoTimeout();
      final int resultCode = result.getExitValue();
      error = resultCode != 0 && !isIgnoreErrorExitCode();
      iterations++;
      final String outLog = extractOutAsString();
      final String errLog = extractErrorOutAsString();
      this.doLogging(resultCode, error, outLog, errLog);
      if (doesNeedOneMoreAttempt(result, outLog, errLog)) {
        if (iterations > maxAttempts) {
          throw new MojoExecutionException(
              "Too many iterations detected, may be some loop and bug at mojo " +
                  this.getClass().getName());
        }
        getLog().warn("Make one more attempt...");
      } else {
        if (!isIgnoreErrorExitCode()) {
          assertProcessResult(result);
        }
        break;
      }
    }
    return error;
  }
  @Override
  public final void execute() throws MojoExecutionException, MojoFailureException {
    if (this.isSkip()) {
      getLog().info("Skipping mvn-golang execution");
    } else {
      if (this.doesNeedSessionLock()) {
        lockMvnGolangSession();
        if (Thread.currentThread().isInterrupted()) {
          throw new MojoFailureException("Current thread is interrupted");
        }
      }
      try {
        if (!isHideBanner()) {
          printBanner();
        }
        doInit();
        printEcho();
        final ProxySettings proxySettings = extractProxySettings();
        beforeExecution(proxySettings);
        Exception exception = null;
        boolean errorDuringMainBusiness = false;
        try {
          errorDuringMainBusiness = doMainBusiness(proxySettings, 10);
        } catch (final IOException | InterruptedException | MojoExecutionException |
                       MojoFailureException ex) {
          if (ex instanceof InterruptedException) {
            Thread.currentThread().interrupt();
          }
          exception = ex;
        } finally {
          afterExecution(null, errorDuringMainBusiness || exception != null);
        }
        if (exception != null) {
          throw new MojoExecutionException(exception.getMessage(), exception);
        } else if (errorDuringMainBusiness) {
          throw new MojoFailureException("Mojo execution failed, see log");
        }
      } finally {
        if (this.doesNeedSessionLock()) {
          unlockMvnGolangSession();
        }
      }
    }
  }
  public void doInit() throws MojoFailureException, MojoExecutionException {
  }
  public void beforeExecution(@Nullable final ProxySettings proxySettings)
      throws MojoFailureException, MojoExecutionException {
  }
  public void afterExecution(@Nullable final ProxySettings proxySettings, final boolean error)
      throws MojoFailureException, MojoExecutionException {
  }
  public boolean isEnforcePrintOutput() {
    return false;
  }
  @Nonnull
  private String extractOutAsString() {
    return new String(this.consoleOutBuffer.toByteArray(), Charset.defaultCharset());
  }
  @Nonnull
  private String extractErrorOutAsString() {
    return new String(this.consoleErrBuffer.toByteArray(), Charset.defaultCharset());
  }
  protected void printLogs(final boolean forcePrint, final boolean errorDetected,
                           @Nonnull final String outLog, @Nonnull final String errLog) {
    final boolean outLogNotEmpty = !outLog.isEmpty();
    final boolean errLogNotEmpty = !errLog.isEmpty();
    if (outLogNotEmpty) {
      if (forcePrint || getLog().isDebugEnabled()) {
        getLog().info("");
        getLog().info("---------Exec.Out---------");
        for (final String str : outLog.split("\n")) {
          getLog().info(StrUtils.trimRight(str));
        }
        getLog().info("");
      } else {
        getLog().debug("There is not any log out from the process");
      }
    }
    if (errLogNotEmpty) {
      if (forcePrint) {
        if (errorDetected) {
          getLog().error("");
          getLog().error("---------Exec.Err---------");
          for (final String str : errLog.split("\n")) {
            getLog().error(StrUtils.trimRight(str));
          }
          getLog().error("");
        } else {
          getLog().warn("");
          getLog().warn("---------Exec.Err---------");
          for (final String str : errLog.split("\n")) {
            getLog().warn(StrUtils.trimRight(str));
          }
          getLog().warn("");
        }
      } else {
        getLog().debug("---------Exec.Err---------");
        for (final String str : errLog.split("\n")) {
          getLog().debug(StrUtils.trimRight(str));
        }
      }
    } else {
      getLog().debug("Error log buffer is empty");
    }
  }
  private void assertProcessResult(@Nonnull final ProcessResult result)
      throws MojoFailureException {
    final int code = result.getExitValue();
    if (code != 0) {
      throw new MojoFailureException("Process exit code : " + code);
    }
  }
  public boolean isSourceFolderRequired() {
    return false;
  }
  public boolean isMojoMustNotBeExecuted() throws MojoFailureException {
    try {
      return isSourceFolderRequired() && !this.getSources(false).isDirectory();
    } catch (IOException ex) {
      throw new MojoFailureException("Can't check source folder", ex);
    }
  }
  @Nonnull
  @MustNotContainNull
  public abstract String[] getTailArguments();
  @Nonnull
  @MustNotContainNull
  public String[] getOptionalExtraTailArguments() {
    return ArrayUtils.EMPTY_STRING_ARRAY;
  }
  @Nonnull
  public String makeExecutableFileSubpath() {
    return getExecSubpath() + File.separatorChar + getExec();
  }
  @Nonnull
  public abstract String getGoCommand();
  @Nonnull
  @MustNotContainNull
  public abstract String[] getCommandFlags();
  @Nullable
  private String getEnvPath() {
    String path = System.getenv("PATH");
    if (path == null) {
      this.getLog().warn("Can't find any defined PATH in environment");
    } else {
      this.getLog().debug("Found env.PATH: " + path);
    }
    final boolean filter = this.isFilterEnvPath();
    if (path != null) {
      final StringBuilder buffer = new StringBuilder();
      for (final String s : path.split(Pattern.quote(File.pathSeparator))) {
        if (filter && GOBINFOLDER_PATTERN.matcher(s).find()) {
          getLog().debug("Removing item '" + s + "' from PATH because it looks like go/bin");
          continue;
        }
        if (buffer.length() > 0) {
          buffer.append(File.pathSeparator);
        }
        buffer.append(s);
        getLog().debug("Add item '" + s + "' to PATH");
      }
      path = buffer.toString();
    }
    this.getLog().debug("Prepared PATH var content:" + path);
    return path;
  }
  private void addEnvVar(@Nonnull final ProcessExecutor executor, @Nonnull final String name,
                         @Nonnull final String value) {
    logOptionally(" $" + name + " = " + value);
    executor.environment(name, value);
  }
  @Nonnull
  private synchronized HttpClient getHttpClient(@Nullable final ProxySettings proxy)
      throws MojoExecutionException {
    if (this.httpClient == null) {
      final HttpClientBuilder builder = HttpClients.custom();
      if (proxy != null) {
        if (proxy.hasCredentials()) {
          final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
          credentialsProvider.setCredentials(new AuthScope(proxy.host, proxy.port),
              new NTCredentials(GetUtils.ensureNonNull(proxy.username, ""), proxy.password,
                  extractComputerName(), extractDomainName()));
          builder.setDefaultCredentialsProvider(credentialsProvider);
          getLog().debug(String
              .format("Credentials provider has been created for proxy (username : %s): %s",
                  proxy.username, proxy));
        }
        final String[] ignoreForAddresses =
            proxy.nonProxyHosts == null ? new String[0] : proxy.nonProxyHosts.split("\\|");
        final WildCardMatcher[] matchers;
        if (ignoreForAddresses.length > 0) {
          matchers = new WildCardMatcher[ignoreForAddresses.length];
          for (int i = 0; i < ignoreForAddresses.length; i++) {
            matchers[i] = new WildCardMatcher(ignoreForAddresses[i]);
          }
        } else {
          matchers = new WildCardMatcher[0];
        }
        getLog().debug("Regular routing mode");
        final HttpRoutePlanner routePlanner =
            new DefaultProxyRoutePlanner(new HttpHost(proxy.host, proxy.port, proxy.protocol)) {
              @Override
              @Nonnull
              public HttpRoute determineRoute(@Nonnull final HttpHost host,
                                              @Nonnull final HttpRequest request,
                                              @Nonnull final HttpContext context)
                  throws HttpException {
                HttpRoute result = null;
                final String hostName = host.getHostName();
                for (final WildCardMatcher m : matchers) {
                  if (m.match(hostName)) {
                    getLog().debug("Ignoring proxy for host : " + hostName);
                    result = new HttpRoute(host);
                    break;
                  }
                }
                if (result == null) {
                  result = super.determineRoute(host, request, context);
                }
                getLog().debug("Made connection route : " + result);
                return result;
              }
            };
        builder.setRoutePlanner(routePlanner);
        getLog().debug("Proxy will ignore: " + Arrays.toString(matchers));
      }
      builder.setUserAgent("mvn-golang-wrapper-agent/1.0");
      builder.disableCookieManagement();
      if (this.isDisableSslCheck()) {
        this.getLog().warn("SSL certificate check is disabled");
        try {
          final SSLContext sslcontext = SSLContext.getInstance("TLS");
          X509TrustManager tm = new X509TrustManager() {
            @Override
            public void checkClientTrusted(
                @Nonnull @MustNotContainNull final X509Certificate[] arg0,
                @Nonnull final String arg1) throws CertificateException {
            }
            @Override
            public void checkServerTrusted(
                @Nonnull @MustNotContainNull final X509Certificate[] arg0, @Nonnull String arg1)
                throws CertificateException {
            }
            @Override
            @Nullable
            @MustNotContainNull
            public X509Certificate[] getAcceptedIssuers() {
              return null;
            }
          };
          sslcontext.init(null, new TrustManager[] {tm}, null);
          final SSLConnectionSocketFactory sslfactory =
              new SSLConnectionSocketFactory(sslcontext, NoopHostnameVerifier.INSTANCE);
          final Registry<ConnectionSocketFactory> r =
              RegistryBuilder.<ConnectionSocketFactory>create()
                  .register("https", sslfactory)
                  .register("http", new PlainConnectionSocketFactory()).build();
          builder.setConnectionManager(new BasicHttpClientConnectionManager(r));
          builder.setSSLSocketFactory(sslfactory);
          builder.setSSLContext(sslcontext);
        } catch (final KeyManagementException | NoSuchAlgorithmException ex) {
          throw new MojoExecutionException("Can't disable SSL certificate check", ex);
        }
      } else {
        this.getLog().debug("SSL check is enabled");
      }
      this.httpClient = builder.build();
    }
    return this.httpClient;
  }
  protected void registerOutputBuffers(@Nonnull final ProcessExecutor executor) {
    executor.redirectOutput(this.consoleOutBuffer);
    executor.redirectError(this.consoleErrBuffer);
  }
  protected void registerEnvVars(
      @Nonnull final ProcessExecutor result,
      @Nonnull final File theGoRoot,
      @Nullable final String theGoBin,
      @Nullable final String theGoCache,
      @Nonnull final File sourcesFile,
      @MustNotContainNull @Nonnull final File[] goPathParts
  ) throws IOException {
    logOptionally("....Environment vars....");
    addEnvVar(result, "GOROOT", theGoRoot.getAbsolutePath());
    this.project.getProperties().setProperty("mvn.golang.last.goroot", theGoRoot.getAbsolutePath());
    String preparedGoPath = IOUtils.makeOsFilePathWithoutDuplications(goPathParts);
    if (isEnforceGoPathToEnd()) {
      preparedGoPath = IOUtils.makeOsFilePathWithoutDuplications(makePathFromExtraGoPathElements(),
          removeSrcFolderAtEndIfPresented(sourcesFile.getAbsolutePath()), getSpecialPartOfGoPath(),
          preparedGoPath);
    } else {
      preparedGoPath = IOUtils
          .makeOsFilePathWithoutDuplications(preparedGoPath, makePathFromExtraGoPathElements(),
              removeSrcFolderAtEndIfPresented(sourcesFile.getAbsolutePath()),
              getSpecialPartOfGoPath());
    }
    addEnvVar(result, "GOPATH", preparedGoPath);
    this.project.getProperties().setProperty("mvn.golang.last.gopath", preparedGoPath);
    if (theGoBin == null) {
      getLog().warn("GOBIN is disabled by direct order");
    } else {
      addEnvVar(result, "GOBIN", theGoBin);
      this.project.getProperties().setProperty("mvn.golang.last.gobin", theGoBin);
    }
    if (theGoBin == null) {
      getLog().warn("GOCACHE is not provided by direct order");
    } else {
      addEnvVar(result, "GOCACHE", theGoCache);
      this.project.getProperties().setProperty("mvn.golang.last.gocache", theGoCache);
    }
    final String trgtOs = this.getTargetOS();
    final String trgtArch = this.getTargetArch();
    final String trgtArm = this.getTargetArm();
    final String trgt386 = this.getTarget386();
    if (trgt386 != null) {
      addEnvVar(result, "GO386", trgt386);
      this.project.getProperties().setProperty("mvn.golang.last.go386", trgt386);
    }
    if (trgtOs != null) {
      addEnvVar(result, "GOOS", trgtOs);
      this.project.getProperties().setProperty("mvn.golang.last.goos", trgtOs);
    }
    if (trgtArm != null) {
      addEnvVar(result, "GOARM", trgtArm);
      this.project.getProperties().setProperty("mvn.golang.last.goarm", trgtArm);
    }
    if (trgtArch != null) {
      addEnvVar(result, "GOARCH", trgtArch);
      this.project.getProperties().setProperty("mvn.golang.last.goarch", trgtArch);
    }
    final File gorootbootstrap = findGoRootBootstrap(true);
    if (gorootbootstrap != null) {
      addEnvVar(result, "GOROOT_BOOTSTRAP", gorootbootstrap.getAbsolutePath());
      this.project.getProperties()
          .setProperty("mvn.golang.last.goroot_bootstrap", gorootbootstrap.getAbsolutePath());
    }
    String thePath = GetUtils.ensureNonNull(getEnvPath(), "");
    thePath = IOUtils
        .makeOsFilePathWithoutDuplications((theGoRoot + File.separator + getExecSubpath()), thePath,
            theGoBin);
    addEnvVar(result, "PATH", thePath);
    this.project.getProperties().setProperty("mvn.golang.last.path", thePath);
    boolean go111moduleDetected = false;
    for (final Map.Entry<?, ?> record : getEnv().entrySet()) {
      if (ENV_GO111MODULE.equals(record.getKey().toString())) {
        go111moduleDetected = true;
      }
      addEnvVar(result, record.getKey().toString(),
          GetUtils.ensureNonNull(record.getValue(), "").toString());
    }
    if (this.isModuleMode()) {
      if (go111moduleDetected) {
        this.getLog().warn(String
            .format("Module mode is true but %s detected among custom environment parameters",
                ENV_GO111MODULE));
      } else {
        this.getLog().warn(
            String.format("Forcing '%s = on' because module mode is activated", ENV_GO111MODULE));
        addEnvVar(result, ENV_GO111MODULE, "on");
      }
    }
  }
  @Nonnull
  @MustNotContainNull
  protected List<File> findAllGoModsInFolder(@Nonnull @MustNotContainNull final File folder)
      throws IOException {
    return new ArrayList<>(FileUtils
        .listFiles(folder, FileFilterUtils.nameFileFilter(GO_MOD_FILE_NAME),
            TrueFileFilter.INSTANCE));
  }
  @Nonnull
  protected File getWorkingDirectoryForExecutor() throws IOException {
    final String forcedWorkingDirdir = this.getWorkingDir();
    if (forcedWorkingDirdir != null) {
      final File result = new File(forcedWorkingDirdir);
      if (!result.isDirectory()) {
        throw new IOException("Working directory doesn't exist: " + result);
      }
      return result;
    }
    if (this.isModuleMode()) {
      final File srcFolder = this.getSources(false);
      if (srcFolder.isDirectory()) {
        final List<File> foundGoMods = this.findAllGoModsInFolder(srcFolder);
        this.getLog().debug(String
            .format("Detected %d go.mod files in source folder %s", foundGoMods.size(), srcFolder));
        foundGoMods.sort(Comparator.comparing(File::toString));
        if (foundGoMods.isEmpty()) {
          this.getLog().error(
              "Module mode is activated but there is no any go.mod file in the source folder: " +
                  srcFolder);
          throw new IOException("Can't find any go.mod folder in the source folder: " + srcFolder);
        } else {
          final File gomodFolder = foundGoMods.get(0).getParentFile();
          this.getLog().info(String
              .format("Detected module folder '%s' in use as working folder", gomodFolder));
          return gomodFolder;
        }
      } else {
        this.getLog().debug("Source folder is not found: " + srcFolder);
      }
    }
    return this.getSources(isSourceFolderRequired());
  }
  @Nonnull
  protected String getSpecialPartOfGoPath() {
    return "";
  }
  @Nonnull
  protected String makePathFromExtraGoPathElements() {
    String result = "";
    if (this.addToGoPath != null) {
      result = IOUtils.makeOsFilePathWithoutDuplications(this.addToGoPath);
    }
    return result;
  }
  public boolean isCommandSupportVerbose() {
    return false;
  }
  @Nullable
  protected String getSkipMojoPropertySuffix() {
    return null;
  }
  @Nullable
  protected ProcessExecutor prepareExecutor(@Nullable final ProxySettings proxySettings)
      throws IOException, MojoFailureException, MojoExecutionException {
    initConsoleBuffers();
    final String execNameAdaptedForOs = adaptExecNameForOS(makeExecutableFileSubpath());
    final File detectedRoot = findGoRoot(proxySettings);
    final String gobin = getGoBin();
    final String gocache = getGoCache();
    final File[] gopathParts = findGoPath(true);
    if (isMojoMustNotBeExecuted()) {
      return null;
    }
    final String toolName =
        FilenameUtils.normalize(GetUtils.ensureNonNull(getUseGoTool(), execNameAdaptedForOs));
    final File executableFileInPathOrRoot = new File(getPathToFolder(detectedRoot) + toolName);
    final File executableFileInBin =
        gobin == null ? null : new File(getPathToFolder(gobin) + adaptExecNameForOS(getExec()));
    final File[] exeVariants = new File[] {executableFileInBin, executableFileInPathOrRoot};
    final File foundExecutableTool = findExisting(exeVariants);
    if (foundExecutableTool == null) {
      throw new MojoFailureException(
          "Can't find executable file : " + Arrays.toString(exeVariants));
    } else {
      logOptionally("Executable file detected : " + foundExecutableTool);
    }
    final List<String> commandLine = new ArrayList<>();
    commandLine.add(foundExecutableTool.getAbsolutePath());
    final String gocommand = getGoCommand();
    if (!gocommand.isEmpty()) {
      commandLine.add(getGoCommand());
    }
    boolean verboseAdded = false;
    for (final String s : getCommandFlags()) {
      if (s.equals("-v")) {
        verboseAdded = true;
      }
      commandLine.add(s);
    }
    if (this.isVerbose() && !verboseAdded && isCommandSupportVerbose()) {
      commandLine.add("-v");
    }
    commandLine.addAll(Arrays.asList(getBuildFlags()));
    commandLine.addAll(Arrays.asList(getTailArguments()));
    commandLine.addAll(Arrays.asList(getOptionalExtraTailArguments()));
    final StringBuilder cli = new StringBuilder();
    int index = 0;
    for (final String s : commandLine) {
      if (cli.length() > 0) {
        cli.append(' ');
      }
      if (index == 0) {
        cli.append(execNameAdaptedForOs);
      } else {
        cli.append(s);
      }
      index++;
    }
    getLog().info(String.format("Prepared command line : %s", cli));
    final ProcessExecutor result = new ProcessExecutor(commandLine);
    final File workingDirectory = this.getWorkingDirectoryForExecutor();
    if (workingDirectory.isDirectory()) {
      logOptionally("Working directory: " + workingDirectory);
      result.directory(workingDirectory);
    } else {
      logOptionally("Working directory is not set because provided folder doesn't exist: " +
          workingDirectory);
    }
    logOptionally("");
    registerEnvVars(result, detectedRoot, gobin, gocache,
        this.getSources(this.isSourceFolderRequired()), gopathParts);
    logOptionally("........................");
    registerOutputBuffers(result);
    return result;
  }
  private void processLogFiles(@Nonnull final String logOut, @Nonnull final String logErr)
      throws MojoExecutionException {
    final File reportsFolderFile = new File(this.getReportsFolder());
    final String targetOutFileName = nullIfBlank(this.getOutLogFile());
    final String targetErrFileName = nullIfBlank(this.getErrLogFile());
    if (targetErrFileName != null ^ targetOutFileName != null) {
      if (targetOutFileName == null && !logOut.isEmpty()) {
        this.getLog()
            .warn("File logging for ERR stream is ON but also detected text in output stream!");
      }
      if (targetErrFileName == null && !logErr.isEmpty()) {
        this.getLog()
            .warn("File logging for OUT stream is ON but also detected text in error stream!");
      }
    }
    this.getLog().debug("log.file.out: " + targetOutFileName);
    this.getLog().debug("log.file.err: " + targetErrFileName);
    final File targetOutFile =
        targetOutFileName == null ? null : new File(reportsFolderFile, targetOutFileName);
    final File targetErrFile =
        targetErrFileName == null ? null : new File(reportsFolderFile, targetErrFileName);
    if (targetOutFile == null) {
      this.getLog().debug("Log file to write output stream is not set");
    } else {
      getLog().debug("Reports folder : " + reportsFolderFile);
      if (!reportsFolderFile.isDirectory() && !reportsFolderFile.mkdirs()) {
        throw new MojoExecutionException(
            "Can't create folder for console logs : " + reportsFolderFile);
      }
      try {
        getLog().debug(
            "Writing " + logOut.length() + " chars as output console log : " + targetOutFile);
        FileUtils.write(targetOutFile, logOut, "UTF-8");
      } catch (IOException ex) {
        throw new MojoExecutionException(
            "Can't save console output log into file : " + targetOutFile, ex);
      }
    }
    if (targetErrFile == null) {
      this.getLog().debug("Log file to write error stream is not set");
    } else {
      getLog().debug("Reports folder : " + reportsFolderFile);
      if (!reportsFolderFile.isDirectory() && !reportsFolderFile.mkdirs()) {
        throw new MojoExecutionException(
            "Can't create folder for console logs : " + reportsFolderFile);
      }
      try {
        getLog().debug(
            "Writing " + logErr.length() + " chars as error console log : " + targetErrFile);
        FileUtils.write(targetErrFile, logErr, "UTF-8");
      } catch (IOException ex) {
        throw new MojoExecutionException(
            "Can't save console error log into file : " + targetErrFile, ex);
      }
    }
  }
}
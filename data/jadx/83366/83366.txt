SEVERITY = 4

package jadx.core.dex.visitors.blocks;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.api.plugins.input.data.attributes.IJadxAttrType;
import jadx.api.plugins.input.data.attributes.IJadxAttribute;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.attributes.AType;
import jadx.core.dex.attributes.nodes.LoopInfo;
import jadx.core.dex.instructions.InsnType;
import jadx.core.dex.instructions.args.InsnArg;
import jadx.core.dex.instructions.args.LiteralArg;
import jadx.core.dex.instructions.args.RegisterArg;
import jadx.core.dex.nodes.BlockNode;
import jadx.core.dex.nodes.Edge;
import jadx.core.dex.nodes.InsnNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.trycatch.ExcHandlerAttr;
import jadx.core.dex.trycatch.TryCatchBlockAttr;
import jadx.core.dex.visitors.AbstractVisitor;
import jadx.core.utils.BlockUtils;
import jadx.core.utils.Utils;
import jadx.core.utils.exceptions.JadxRuntimeException;
import static jadx.core.dex.visitors.blocks.BlockSplitter.connect;
public class BlockProcessor extends AbstractVisitor {
	private static final Logger LOG = LoggerFactory.getLogger(BlockProcessor.class);
	private static final boolean DEBUG_MODS = false;
	@Override
	public void visit(MethodNode mth) {
		if (mth.isNoCode() || mth.getBasicBlocks().isEmpty()) {
			return;
		}
		processBlocksTree(mth);
	}
	private static void processBlocksTree(MethodNode mth) {
		removeUnreachableBlocks(mth);
		computeDominators(mth);
		if (independentBlockTreeMod(mth)) {
			checkForUnreachableBlocks(mth);
			computeDominators(mth);
		}
		if (FixMultiEntryLoops.process(mth)) {
			computeDominators(mth);
		}
		updateCleanSuccessors(mth);
		int blocksCount = mth.getBasicBlocks().size();
		int modLimit = Math.max(100, blocksCount);
		if (DEBUG_MODS) {
			mth.addAttr(new DebugModAttr());
		}
		int i = 0;
		while (modifyBlocksTree(mth)) {
			computeDominators(mth);
			if (i++ > modLimit) {
				mth.addWarn("CFG modification limit reached, blocks count: " + blocksCount);
				break;
			}
		}
		if (DEBUG_MODS && i != 0) {
			String stats = "CFG modifications count: " + i
					+ ", blocks count: " + blocksCount + '\n'
					+ mth.get(DebugModAttr.TYPE).formatStats() + '\n';
			mth.addDebugComment(stats);
			LOG.debug("Method: {}\n{}", mth, stats);
			mth.remove(DebugModAttr.TYPE);
		}
		checkForUnreachableBlocks(mth);
		DominatorTree.computeDominanceFrontier(mth);
		registerLoops(mth);
		processNestedLoops(mth);
		PostDominatorTree.compute(mth);
		updateCleanSuccessors(mth);
	}
	public static void updateBlocksData(MethodNode mth) {
		clearBlocksState(mth);
		DominatorTree.compute(mth);
		markLoops(mth);
		DominatorTree.computeDominanceFrontier(mth);
		registerLoops(mth);
		processNestedLoops(mth);
		PostDominatorTree.compute(mth);
		updateCleanSuccessors(mth);
	}
	static void updateCleanSuccessors(MethodNode mth) {
		mth.getBasicBlocks().forEach(BlockNode::updateCleanSuccessors);
	}
	private static void checkForUnreachableBlocks(MethodNode mth) {
		for (BlockNode block : mth.getBasicBlocks()) {
			if (block.getPredecessors().isEmpty() && block != mth.getEnterBlock()) {
				throw new JadxRuntimeException("Unreachable block: " + block);
			}
		}
	}
	private static boolean deduplicateBlockInsns(MethodNode mth, BlockNode block) {
		if (block.contains(AFlag.LOOP_START) || block.contains(AFlag.LOOP_END)) {
			List<BlockNode> predecessors = block.getPredecessors();
			int predsCount = predecessors.size();
			if (predsCount > 1) {
				InsnNode lastInsn = BlockUtils.getLastInsn(block);
				if (lastInsn != null && lastInsn.getType() == InsnType.IF) {
					return false;
				}
				if (BlockUtils.checkFirstInsn(block, insn -> insn.contains(AType.EXC_HANDLER))) {
					return false;
				}
				int sameInsnCount = getSameLastInsnCount(predecessors);
				if (sameInsnCount > 0) {
					List<InsnNode> insns = getLastInsns(predecessors.get(0), sameInsnCount);
					insertAtStart(block, insns);
					predecessors.forEach(pred -> getLastInsns(pred, sameInsnCount).clear());
					mth.addDebugComment("Move duplicate insns, count: " + sameInsnCount + " to block " + block);
					return true;
				}
			}
		}
		return false;
	}
	private static List<InsnNode> getLastInsns(BlockNode blockNode, int sameInsnCount) {
		List<InsnNode> instructions = blockNode.getInstructions();
		int size = instructions.size();
		return instructions.subList(size - sameInsnCount, size);
	}
	private static void insertAtStart(BlockNode block, List<InsnNode> insns) {
		List<InsnNode> blockInsns = block.getInstructions();
		List<InsnNode> newInsnList = new ArrayList<>(insns.size() + blockInsns.size());
		newInsnList.addAll(insns);
		newInsnList.addAll(blockInsns);
		blockInsns.clear();
		blockInsns.addAll(newInsnList);
	}
	private static int getSameLastInsnCount(List<BlockNode> predecessors) {
		int sameInsnCount = 0;
		while (true) {
			InsnNode insn = null;
			for (BlockNode pred : predecessors) {
				InsnNode curInsn = getInsnsFromEnd(pred, sameInsnCount);
				if (curInsn == null) {
					return sameInsnCount;
				}
				if (insn == null) {
					insn = curInsn;
				} else {
					if (!isSame(insn, curInsn)) {
						return sameInsnCount;
					}
				}
			}
			sameInsnCount++;
		}
	}
	private static boolean isSame(InsnNode insn, InsnNode curInsn) {
		return isInsnsEquals(insn, curInsn) && insn.canReorder();
	}
	private static boolean isInsnsEquals(InsnNode insn, InsnNode otherInsn) {
		if (insn == otherInsn) {
			return true;
		}
		if (insn.isSame(otherInsn)
				&& sameArgs(insn.getResult(), otherInsn.getResult())) {
			int argsCount = insn.getArgsCount();
			for (int i = 0; i < argsCount; i++) {
				if (!sameArgs(insn.getArg(i), otherInsn.getArg(i))) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	private static boolean sameArgs(@Nullable InsnArg arg, @Nullable InsnArg otherArg) {
		if (arg == otherArg) {
			return true;
		}
		if (arg == null || otherArg == null) {
			return false;
		}
		if (arg.getClass().equals(otherArg.getClass())) {
			if (arg.isRegister()) {
				return ((RegisterArg) arg).getRegNum() == ((RegisterArg) otherArg).getRegNum();
			}
			if (arg.isLiteral()) {
				return ((LiteralArg) arg).getLiteral() == ((LiteralArg) otherArg).getLiteral();
			}
			throw new JadxRuntimeException("Unexpected InsnArg types: " + arg + " and " + otherArg);
		}
		return false;
	}
	private static InsnNode getInsnsFromEnd(BlockNode block, int number) {
		List<InsnNode> instructions = block.getInstructions();
		int insnCount = instructions.size();
		if (insnCount <= number) {
			return null;
		}
		return instructions.get(insnCount - number - 1);
	}
	private static void computeDominators(MethodNode mth) {
		clearBlocksState(mth);
		DominatorTree.compute(mth);
		markLoops(mth);
	}
	private static void markLoops(MethodNode mth) {
		mth.getBasicBlocks().forEach(block -> {
			block.getSuccessors().forEach(successor -> {
				if (block.getDoms().get(successor.getId()) || block == successor) {
					successor.add(AFlag.LOOP_START);
					block.add(AFlag.LOOP_END);
					Set<BlockNode> loopBlocks = BlockUtils.getAllPathsBlocks(successor, block);
					LoopInfo loop = new LoopInfo(successor, block, loopBlocks);
					successor.addAttr(AType.LOOP, loop);
					block.addAttr(AType.LOOP, loop);
				}
			});
		});
	}
	private static void registerLoops(MethodNode mth) {
		mth.resetLoops();
		mth.getBasicBlocks().forEach(block -> {
			if (block.contains(AFlag.LOOP_START)) {
				block.getAll(AType.LOOP).forEach(mth::registerLoop);
			}
		});
	}
	private static void processNestedLoops(MethodNode mth) {
		if (mth.getLoopsCount() == 0) {
			return;
		}
		for (LoopInfo outLoop : mth.getLoops()) {
			for (LoopInfo innerLoop : mth.getLoops()) {
				if (outLoop == innerLoop) {
					continue;
				}
				if (outLoop.getLoopBlocks().containsAll(innerLoop.getLoopBlocks())) {
					LoopInfo parentLoop = innerLoop.getParentLoop();
					if (parentLoop != null) {
						if (parentLoop.getLoopBlocks().containsAll(outLoop.getLoopBlocks())) {
							outLoop.setParentLoop(parentLoop);
							innerLoop.setParentLoop(outLoop);
						} else {
							parentLoop.setParentLoop(outLoop);
						}
					} else {
						innerLoop.setParentLoop(outLoop);
					}
				}
			}
		}
	}
	private static boolean modifyBlocksTree(MethodNode mth) {
		for (BlockNode block : mth.getBasicBlocks()) {
			if (checkLoops(mth, block)) {
				return true;
			}
		}
		if (mergeConstReturn(mth)) {
			return true;
		}
		return splitExitBlocks(mth);
	}
	private static boolean mergeConstReturn(MethodNode mth) {
		if (mth.isVoidReturn()) {
			return false;
		}
		boolean changed = false;
		for (BlockNode retBlock : new ArrayList<>(mth.getPreExitBlocks())) {
			BlockNode pred = Utils.getOne(retBlock.getPredecessors());
			if (pred != null) {
				InsnNode constInsn = Utils.getOne(pred.getInstructions());
				if (constInsn != null && constInsn.isConstInsn()) {
					RegisterArg constArg = constInsn.getResult();
					InsnNode returnInsn = BlockUtils.getLastInsn(retBlock);
					if (returnInsn != null && returnInsn.getType() == InsnType.RETURN) {
						InsnArg retArg = returnInsn.getArg(0);
						if (constArg.sameReg(retArg)) {
							mergeConstAndReturnBlocks(mth, retBlock, pred);
							changed = true;
						}
					}
				}
			}
		}
		if (changed) {
			removeMarkedBlocks(mth);
			if (DEBUG_MODS) {
				mth.get(DebugModAttr.TYPE).addEvent("Merge const return");
			}
		}
		return changed;
	}
	private static void mergeConstAndReturnBlocks(MethodNode mth, BlockNode retBlock, BlockNode pred) {
		pred.getInstructions().addAll(retBlock.getInstructions());
		pred.copyAttributesFrom(retBlock);
		BlockSplitter.removeConnection(pred, retBlock);
		retBlock.getInstructions().clear();
		retBlock.add(AFlag.REMOVE);
		BlockNode exitBlock = mth.getExitBlock();
		BlockSplitter.removeConnection(retBlock, exitBlock);
		BlockSplitter.connect(pred, exitBlock);
		pred.updateCleanSuccessors();
	}
	private static boolean independentBlockTreeMod(MethodNode mth) {
		boolean changed = false;
		List<BlockNode> basicBlocks = mth.getBasicBlocks();
		for (BlockNode basicBlock : basicBlocks) {
			if (deduplicateBlockInsns(mth, basicBlock)) {
				changed = true;
			}
		}
		if (BlockExceptionHandler.process(mth)) {
			changed = true;
		}
		for (BlockNode basicBlock : basicBlocks) {
			if (BlockSplitter.removeEmptyBlock(basicBlock)) {
				changed = true;
			}
		}
		if (BlockSplitter.removeEmptyDetachedBlocks(mth)) {
			changed = true;
		}
		return changed;
	}
	private static boolean simplifyLoopEnd(MethodNode mth, LoopInfo loop) {
		BlockNode loopEnd = loop.getEnd();
		if (loopEnd.getSuccessors().size() <= 1) {
			return false;
		}
		BlockNode newLoopEnd = BlockSplitter.startNewBlock(mth, -1);
		newLoopEnd.add(AFlag.SYNTHETIC);
		newLoopEnd.add(AFlag.LOOP_END);
		BlockNode loopStart = loop.getStart();
		BlockSplitter.replaceConnection(loopEnd, loopStart, newLoopEnd);
		BlockSplitter.connect(newLoopEnd, loopStart);
		if (DEBUG_MODS) {
			mth.get(DebugModAttr.TYPE).addEvent("Simplify loop end");
		}
		return true;
	}
	private static boolean checkLoops(MethodNode mth, BlockNode block) {
		if (!block.contains(AFlag.LOOP_START)) {
			return false;
		}
		List<LoopInfo> loops = block.getAll(AType.LOOP);
		int loopsCount = loops.size();
		if (loopsCount == 0) {
			return false;
		}
		for (LoopInfo loop : loops) {
			if (insertBlocksForBreak(mth, loop)) {
				return true;
			}
		}
		if (loopsCount > 1 && splitLoops(mth, block, loops)) {
			return true;
		}
		if (loopsCount == 1) {
			LoopInfo loop = loops.get(0);
			return insertBlocksForContinue(mth, loop)
					|| insertPreHeader(mth, loop)
					|| simplifyLoopEnd(mth, loop);
		}
		return false;
	}
	private static boolean insertPreHeader(MethodNode mth, LoopInfo loop) {
		BlockNode start = loop.getStart();
		List<BlockNode> preds = start.getPredecessors();
		int predsCount = preds.size() - 1; 
		if (predsCount == 1) {
			return false;
		}
		if (predsCount == 0) {
			if (!start.contains(AFlag.MTH_ENTER_BLOCK)) {
				mth.addWarnComment("Unexpected block without predecessors: " + start);
			}
			BlockNode newEnterBlock = BlockSplitter.startNewBlock(mth, -1);
			newEnterBlock.add(AFlag.SYNTHETIC);
			newEnterBlock.add(AFlag.MTH_ENTER_BLOCK);
			mth.setEnterBlock(newEnterBlock);
			start.remove(AFlag.MTH_ENTER_BLOCK);
			BlockSplitter.connect(newEnterBlock, start);
		} else {
			BlockNode preHeader = BlockSplitter.startNewBlock(mth, -1);
			preHeader.add(AFlag.SYNTHETIC);
			BlockNode loopEnd = loop.getEnd();
			for (BlockNode pred : new ArrayList<>(preds)) {
				if (pred != loopEnd) {
					BlockSplitter.replaceConnection(pred, start, preHeader);
				}
			}
			BlockSplitter.connect(preHeader, start);
		}
		if (DEBUG_MODS) {
			mth.get(DebugModAttr.TYPE).addEvent("Insert loop pre header");
		}
		return true;
	}
	private static boolean insertBlocksForBreak(MethodNode mth, LoopInfo loop) {
		boolean change = false;
		List<Edge> edges = loop.getExitEdges();
		if (!edges.isEmpty()) {
			for (Edge edge : edges) {
				BlockNode target = edge.getTarget();
				BlockNode source = edge.getSource();
				if (!target.contains(AFlag.SYNTHETIC) && !source.contains(AFlag.SYNTHETIC)) {
					BlockSplitter.insertBlockBetween(mth, source, target);
					change = true;
				}
			}
		}
		if (DEBUG_MODS && change) {
			mth.get(DebugModAttr.TYPE).addEvent("Insert loop break blocks");
		}
		return change;
	}
	private static boolean insertBlocksForContinue(MethodNode mth, LoopInfo loop) {
		BlockNode loopEnd = loop.getEnd();
		boolean change = false;
		List<BlockNode> preds = loopEnd.getPredecessors();
		if (preds.size() > 1) {
			for (BlockNode pred : new ArrayList<>(preds)) {
				if (!pred.contains(AFlag.SYNTHETIC)) {
					BlockSplitter.insertBlockBetween(mth, pred, loopEnd);
					change = true;
				}
			}
		}
		if (DEBUG_MODS && change) {
			mth.get(DebugModAttr.TYPE).addEvent("Insert loop continue block");
		}
		return change;
	}
	private static boolean splitLoops(MethodNode mth, BlockNode block, List<LoopInfo> loops) {
		boolean oneHeader = true;
		for (LoopInfo loop : loops) {
			if (loop.getStart() != block) {
				oneHeader = false;
				break;
			}
		}
		if (!oneHeader) {
			return false;
		}
		BlockNode newLoopEnd = BlockSplitter.startNewBlock(mth, block.getStartOffset());
		newLoopEnd.add(AFlag.SYNTHETIC);
		connect(newLoopEnd, block);
		for (LoopInfo la : loops) {
			BlockSplitter.replaceConnection(la.getEnd(), block, newLoopEnd);
		}
		if (DEBUG_MODS) {
			mth.get(DebugModAttr.TYPE).addEvent("Split loops");
		}
		return true;
	}
	private static boolean splitExitBlocks(MethodNode mth) {
		boolean changed = false;
		for (BlockNode preExitBlock : mth.getPreExitBlocks()) {
			if (splitReturn(mth, preExitBlock)) {
				changed = true;
			} else if (splitThrow(mth, preExitBlock)) {
				changed = true;
			}
		}
		if (changed) {
			updateExitBlockConnections(mth);
			if (DEBUG_MODS) {
				mth.get(DebugModAttr.TYPE).addEvent("Split exit block");
			}
		}
		return changed;
	}
	private static void updateExitBlockConnections(MethodNode mth) {
		BlockNode exitBlock = mth.getExitBlock();
		BlockSplitter.removePredecessors(exitBlock);
		for (BlockNode block : mth.getBasicBlocks()) {
			if (block != exitBlock
					&& block.getSuccessors().isEmpty()
					&& !block.contains(AFlag.REMOVE)) {
				BlockSplitter.connect(block, exitBlock);
			}
		}
	}
	private static boolean splitReturn(MethodNode mth, BlockNode returnBlock) {
		if (returnBlock.contains(AFlag.SYNTHETIC)
				|| returnBlock.contains(AFlag.ORIG_RETURN)
				|| returnBlock.contains(AType.EXC_HANDLER)) {
			return false;
		}
		List<BlockNode> preds = returnBlock.getPredecessors();
		if (preds.size() < 2) {
			return false;
		}
		InsnNode returnInsn = BlockUtils.getLastInsn(returnBlock);
		if (returnInsn == null) {
			return false;
		}
		if (returnInsn.getArgsCount() == 1
				&& returnBlock.getInstructions().size() == 1
				&& !isArgAssignInPred(preds, returnInsn.getArg(0))) {
			return false;
		}
		boolean first = true;
		for (BlockNode pred : new ArrayList<>(preds)) {
			if (first) {
				returnBlock.add(AFlag.ORIG_RETURN);
				first = false;
			} else {
				BlockNode newRetBlock = BlockSplitter.startNewBlock(mth, -1);
				newRetBlock.add(AFlag.SYNTHETIC);
				newRetBlock.add(AFlag.RETURN);
				for (InsnNode oldInsn : returnBlock.getInstructions()) {
					InsnNode copyInsn = oldInsn.copyWithoutSsa();
					copyInsn.add(AFlag.SYNTHETIC);
					newRetBlock.getInstructions().add(copyInsn);
				}
				BlockSplitter.replaceConnection(pred, returnBlock, newRetBlock);
			}
		}
		return true;
	}
	private static boolean splitThrow(MethodNode mth, BlockNode exitBlock) {
		if (exitBlock.contains(AFlag.IGNORE_THROW_SPLIT)) {
			return false;
		}
		List<BlockNode> preds = exitBlock.getPredecessors();
		if (preds.size() < 2) {
			return false;
		}
		InsnNode throwInsn = BlockUtils.getLastInsn(exitBlock);
		if (throwInsn == null || throwInsn.getType() != InsnType.THROW) {
			return false;
		}
		Map<BlockNode, ExcHandlerAttr> handlersMap = new HashMap<>(preds.size());
		Set<BlockNode> handlers = new HashSet<>(preds.size());
		for (BlockNode pred : preds) {
			BlockUtils.visitPredecessorsUntil(mth, pred, block -> {
				ExcHandlerAttr excHandlerAttr = block.get(AType.EXC_HANDLER);
				if (excHandlerAttr == null) {
					return false;
				}
				boolean correctHandler = excHandlerAttr.getHandler().getBlocks().contains(block);
				if (correctHandler && isArgAssignInPred(Collections.singletonList(block), throwInsn.getArg(0))) {
					handlersMap.put(pred, excHandlerAttr);
					handlers.add(block);
				}
				return correctHandler;
			});
		}
		if (handlers.size() == 1) {
			exitBlock.add(AFlag.IGNORE_THROW_SPLIT);
			return false;
		}
		boolean first = true;
		for (BlockNode pred : new ArrayList<>(preds)) {
			if (first) {
				first = false;
			} else {
				BlockNode newThrowBlock = BlockSplitter.startNewBlock(mth, -1);
				newThrowBlock.add(AFlag.SYNTHETIC);
				for (InsnNode oldInsn : exitBlock.getInstructions()) {
					InsnNode copyInsn = oldInsn.copyWithoutSsa();
					copyInsn.add(AFlag.SYNTHETIC);
					newThrowBlock.getInstructions().add(copyInsn);
				}
				newThrowBlock.copyAttributesFrom(exitBlock);
				ExcHandlerAttr excHandlerAttr = handlersMap.get(pred);
				if (excHandlerAttr != null) {
					excHandlerAttr.getHandler().addBlock(newThrowBlock);
				}
				BlockSplitter.replaceConnection(pred, exitBlock, newThrowBlock);
			}
		}
		return true;
	}
	private static boolean isArgAssignInPred(List<BlockNode> preds, InsnArg arg) {
		if (arg.isRegister()) {
			int regNum = ((RegisterArg) arg).getRegNum();
			for (BlockNode pred : preds) {
				for (InsnNode insnNode : pred.getInstructions()) {
					RegisterArg result = insnNode.getResult();
					if (result != null && result.getRegNum() == regNum) {
						return true;
					}
				}
			}
		}
		return false;
	}
	public static void removeMarkedBlocks(MethodNode mth) {
		mth.getBasicBlocks().removeIf(block -> {
			if (block.contains(AFlag.REMOVE)) {
				if (!block.getPredecessors().isEmpty() || !block.getSuccessors().isEmpty()) {
					LOG.warn("Block {} not deleted, method: {}", block, mth);
				} else {
					TryCatchBlockAttr tryBlockAttr = block.get(AType.TRY_BLOCK);
					if (tryBlockAttr != null) {
						tryBlockAttr.removeBlock(block);
					}
					return true;
				}
			}
			return false;
		});
	}
	private static void removeUnreachableBlocks(MethodNode mth) {
		Set<BlockNode> toRemove = new LinkedHashSet<>();
		for (BlockNode block : mth.getBasicBlocks()) {
			computeUnreachableFromBlock(toRemove, block, mth);
		}
		removeFromMethod(toRemove, mth);
	}
	public static void removeUnreachableBlock(BlockNode blockToRemove, MethodNode mth) {
		Set<BlockNode> toRemove = new LinkedHashSet<>();
		computeUnreachableFromBlock(toRemove, blockToRemove, mth);
		removeFromMethod(toRemove, mth);
	}
	private static void computeUnreachableFromBlock(Set<BlockNode> toRemove, BlockNode block, MethodNode mth) {
		if (block.getPredecessors().isEmpty() && block != mth.getEnterBlock()) {
			BlockSplitter.collectSuccessors(block, mth.getEnterBlock(), toRemove);
		}
	}
	private static void removeFromMethod(Set<BlockNode> toRemove, MethodNode mth) {
		if (toRemove.isEmpty()) {
			return;
		}
		long notEmptyBlocks = toRemove.stream().filter(block -> !block.getInstructions().isEmpty()).count();
		if (notEmptyBlocks != 0) {
			int insnsCount = toRemove.stream().mapToInt(block -> block.getInstructions().size()).sum();
			mth.addWarnComment("Unreachable blocks removed: " + notEmptyBlocks + ", instructions: " + insnsCount);
		}
		toRemove.forEach(BlockSplitter::detachBlock);
		mth.getBasicBlocks().removeAll(toRemove);
	}
	private static void clearBlocksState(MethodNode mth) {
		mth.getBasicBlocks().forEach(block -> {
			block.remove(AType.LOOP);
			block.remove(AFlag.LOOP_START);
			block.remove(AFlag.LOOP_END);
			block.setDoms(null);
			block.setIDom(null);
			block.setDomFrontier(null);
			block.getDominatesOn().clear();
		});
	}
	private static final class DebugModAttr implements IJadxAttribute {
		static final IJadxAttrType<DebugModAttr> TYPE = IJadxAttrType.create("DebugModAttr");
		private final Map<String, Integer> statMap = new HashMap<>();
		public void addEvent(String name) {
			statMap.merge(name, 1, Integer::sum);
		}
		public String formatStats() {
			return statMap.entrySet().stream()
					.map(entry -> " " + entry.getKey() + ": " + entry.getValue())
					.collect(Collectors.joining("\n"));
		}
		@Override
		public IJadxAttrType<DebugModAttr> getAttrType() {
			return TYPE;
		}
	}
}
______
package jadx.core.dex.visitors.blocks;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.api.plugins.utils.Utils;
import jadx.core.Consts;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.attributes.AType;
import jadx.core.dex.attributes.nodes.TmpEdgeAttr;
import jadx.core.dex.info.ClassInfo;
import jadx.core.dex.instructions.InsnType;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.instructions.args.InsnArg;
import jadx.core.dex.instructions.args.NamedArg;
import jadx.core.dex.instructions.args.RegisterArg;
import jadx.core.dex.nodes.BlockNode;
import jadx.core.dex.nodes.InsnNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.trycatch.CatchAttr;
import jadx.core.dex.trycatch.ExcHandlerAttr;
import jadx.core.dex.trycatch.ExceptionHandler;
import jadx.core.dex.trycatch.TryCatchBlockAttr;
import jadx.core.dex.visitors.typeinference.TypeCompare;
import jadx.core.utils.BlockUtils;
import jadx.core.utils.InsnRemover;
import jadx.core.utils.ListUtils;
import jadx.core.utils.blocks.BlockSet;
import jadx.core.utils.exceptions.JadxRuntimeException;
public class BlockExceptionHandler {
	private static final Logger LOG = LoggerFactory.getLogger(BlockExceptionHandler.class);
	public static boolean process(MethodNode mth) {
		if (mth.isNoExceptionHandlers()) {
			return false;
		}
		BlockProcessor.updateCleanSuccessors(mth);
		DominatorTree.computeDominanceFrontier(mth);
		processCatchAttr(mth);
		initExcHandlers(mth);
		List<TryCatchBlockAttr> tryBlocks = prepareTryBlocks(mth);
		connectExcHandlers(mth, tryBlocks);
		mth.addAttr(AType.TRY_BLOCKS_LIST, tryBlocks);
		mth.getBasicBlocks().forEach(BlockNode::updateCleanSuccessors);
		for (ExceptionHandler eh : mth.getExceptionHandlers()) {
			removeMonitorExitFromExcHandler(mth, eh);
		}
		BlockProcessor.removeMarkedBlocks(mth);
		BlockSet sorted = new BlockSet(mth);
		BlockUtils.visitDFS(mth, sorted::set);
		removeUnusedExcHandlers(mth, tryBlocks, sorted);
		return true;
	}
	private static void connectExcHandlers(MethodNode mth, List<TryCatchBlockAttr> tryBlocks) {
		if (tryBlocks.isEmpty()) {
			return;
		}
		int limit = tryBlocks.size() * 3;
		int count = 0;
		Deque<TryCatchBlockAttr> queue = new ArrayDeque<>(tryBlocks);
		while (!queue.isEmpty()) {
			TryCatchBlockAttr tryBlock = queue.removeFirst();
			boolean complete = wrapBlocksWithTryCatch(mth, tryBlock);
			if (!complete) {
				queue.addLast(tryBlock); 
			}
			if (count++ > limit) {
				throw new JadxRuntimeException("Try blocks wrapping queue limit reached! Please report as an issue!");
			}
		}
	}
	private static void processCatchAttr(MethodNode mth) {
		for (BlockNode block : mth.getBasicBlocks()) {
			for (InsnNode insn : block.getInstructions()) {
				if (insn.contains(AType.EXC_CATCH) && !insn.canThrowException()) {
					insn.remove(AType.EXC_CATCH);
				}
			}
		}
		for (BlockNode block : mth.getBasicBlocks()) {
			CatchAttr commonCatchAttr = getCommonCatchAttr(block);
			if (commonCatchAttr != null) {
				block.addAttr(commonCatchAttr);
				for (InsnNode insn : block.getInstructions()) {
					if (insn.contains(AFlag.TRY_ENTER)) {
						block.add(AFlag.TRY_ENTER);
					}
					if (insn.contains(AFlag.TRY_LEAVE)) {
						block.add(AFlag.TRY_LEAVE);
					}
				}
			}
		}
	}
	@Nullable
	private static CatchAttr getCommonCatchAttr(BlockNode block) {
		CatchAttr commonCatchAttr = null;
		for (InsnNode insn : block.getInstructions()) {
			CatchAttr catchAttr = insn.get(AType.EXC_CATCH);
			if (catchAttr != null) {
				if (commonCatchAttr == null) {
					commonCatchAttr = catchAttr;
					continue;
				}
				if (!commonCatchAttr.equals(catchAttr)) {
					return null;
				}
			}
		}
		return commonCatchAttr;
	}
	@SuppressWarnings("ForLoopReplaceableByForEach")
	private static void initExcHandlers(MethodNode mth) {
		List<BlockNode> blocks = mth.getBasicBlocks();
		int blocksCount = blocks.size();
		for (int i = 0; i < blocksCount; i++) { 
			BlockNode block = blocks.get(i);
			InsnNode firstInsn = BlockUtils.getFirstInsn(block);
			if (firstInsn == null) {
				continue;
			}
			ExcHandlerAttr excHandlerAttr = firstInsn.get(AType.EXC_HANDLER);
			if (excHandlerAttr == null) {
				continue;
			}
			firstInsn.remove(AType.EXC_HANDLER);
			removeTmpConnection(block);
			ExceptionHandler excHandler = excHandlerAttr.getHandler();
			if (block.getPredecessors().isEmpty()) {
				excHandler.setHandlerBlock(block);
				block.addAttr(excHandlerAttr);
				excHandler.addBlock(block);
				BlockUtils.collectBlocksDominatedByWithExcHandlers(mth, block, block)
						.forEach(excHandler::addBlock);
			} else {
				BlockNode emptyHandlerBlock = BlockSplitter.startNewBlock(mth, block.getStartOffset());
				emptyHandlerBlock.add(AFlag.SYNTHETIC);
				emptyHandlerBlock.addAttr(excHandlerAttr);
				BlockSplitter.connect(emptyHandlerBlock, block);
				excHandler.setHandlerBlock(emptyHandlerBlock);
				excHandler.addBlock(emptyHandlerBlock);
			}
			fixMoveExceptionInsn(block, excHandlerAttr);
		}
	}
	private static void removeTmpConnection(BlockNode block) {
		TmpEdgeAttr tmpEdgeAttr = block.get(AType.TMP_EDGE);
		if (tmpEdgeAttr != null) {
			BlockSplitter.removeConnection(tmpEdgeAttr.getBlock(), block);
			block.remove(AType.TMP_EDGE);
		}
	}
	private static List<TryCatchBlockAttr> prepareTryBlocks(MethodNode mth) {
		Map<ExceptionHandler, List<BlockNode>> blocksByHandler = new HashMap<>();
		for (BlockNode block : mth.getBasicBlocks()) {
			CatchAttr catchAttr = block.get(AType.EXC_CATCH);
			if (catchAttr != null) {
				for (ExceptionHandler eh : catchAttr.getHandlers()) {
					blocksByHandler
							.computeIfAbsent(eh, c -> new ArrayList<>())
							.add(block);
				}
			}
		}
		if (Consts.DEBUG_EXC_HANDLERS) {
			LOG.debug("Input exception handlers:");
			blocksByHandler.forEach((eh, blocks) -> LOG.debug(" {}, throw blocks: {}, handler blocks: {}", eh, blocks, eh.getBlocks()));
		}
		if (blocksByHandler.isEmpty()) {
			mth.getExceptionHandlers().forEach(eh -> removeExcHandler(mth, eh));
		} else {
			blocksByHandler.forEach((eh, blocks) -> {
				if (blocks.isEmpty()) {
					removeExcHandler(mth, eh);
				}
			});
		}
		BlockSplitter.detachMarkedBlocks(mth);
		mth.clearExceptionHandlers();
		if (mth.isNoExceptionHandlers()) {
			return Collections.emptyList();
		}
		blocksByHandler.forEach((eh, blocks) -> {
			blocks.removeAll(eh.getBlocks());
		});
		List<TryCatchBlockAttr> tryBlocks = new ArrayList<>();
		blocksByHandler.forEach((eh, blocks) -> {
			List<ExceptionHandler> handlers = new ArrayList<>(1);
			handlers.add(eh);
			tryBlocks.add(new TryCatchBlockAttr(tryBlocks.size(), handlers, blocks));
		});
		if (tryBlocks.size() > 1) {
			while (true) {
				boolean restart = combineTryCatchBlocks(tryBlocks);
				if (!restart) {
					break;
				}
			}
		}
		checkForMultiCatch(mth, tryBlocks);
		clearTryBlocks(mth, tryBlocks);
		sortHandlers(mth, tryBlocks);
		if (Consts.DEBUG_EXC_HANDLERS) {
			LOG.debug("Result try-catch blocks:");
			tryBlocks.forEach(tryBlock -> LOG.debug(" {}", tryBlock));
		}
		return tryBlocks;
	}
	private static void clearTryBlocks(MethodNode mth, List<TryCatchBlockAttr> tryBlocks) {
		tryBlocks.forEach(tc -> tc.getBlocks().removeIf(b -> b.contains(AFlag.REMOVE)));
		tryBlocks.removeIf(tb -> tb.getBlocks().isEmpty() || tb.getHandlers().isEmpty());
		mth.clearExceptionHandlers();
		BlockSplitter.detachMarkedBlocks(mth);
	}
	private static boolean combineTryCatchBlocks(List<TryCatchBlockAttr> tryBlocks) {
		for (TryCatchBlockAttr outerTryBlock : tryBlocks) {
			for (TryCatchBlockAttr innerTryBlock : tryBlocks) {
				if (outerTryBlock == innerTryBlock || innerTryBlock.getOuterTryBlock() != null) {
					continue;
				}
				if (checkTryCatchRelation(tryBlocks, outerTryBlock, innerTryBlock)) {
					return true;
				}
			}
		}
		return false;
	}
	private static boolean checkTryCatchRelation(List<TryCatchBlockAttr> tryBlocks,
			TryCatchBlockAttr outerTryBlock, TryCatchBlockAttr innerTryBlock) {
		if (outerTryBlock.getBlocks().equals(innerTryBlock.getBlocks())) {
			List<ExceptionHandler> handlers = Utils.concatDistinct(outerTryBlock.getHandlers(), innerTryBlock.getHandlers());
			tryBlocks.add(new TryCatchBlockAttr(tryBlocks.size(), handlers, outerTryBlock.getBlocks()));
			tryBlocks.remove(outerTryBlock);
			tryBlocks.remove(innerTryBlock);
			return true;
		}
		Set<BlockNode> handlerBlocks = innerTryBlock.getHandlers().stream()
				.flatMap(eh -> eh.getBlocks().stream())
				.collect(Collectors.toSet());
		boolean catchInHandler = handlerBlocks.stream().anyMatch(isHandlersIntersects(outerTryBlock));
		boolean catchInTry = innerTryBlock.getBlocks().stream().anyMatch(isHandlersIntersects(outerTryBlock));
		boolean blocksOutsideHandler = outerTryBlock.getBlocks().stream().anyMatch(b -> !handlerBlocks.contains(b));
		if (catchInHandler && (catchInTry || blocksOutsideHandler)) {
			List<BlockNode> mergedBlocks = Utils.concatDistinct(outerTryBlock.getBlocks(), innerTryBlock.getBlocks());
			innerTryBlock.getHandlers().removeAll(outerTryBlock.getHandlers());
			innerTryBlock.setOuterTryBlock(outerTryBlock);
			outerTryBlock.addInnerTryBlock(innerTryBlock);
			outerTryBlock.setBlocks(mergedBlocks);
			return false;
		}
		Set<ExceptionHandler> innerHandlerSet = new HashSet<>(innerTryBlock.getHandlers());
		if (innerHandlerSet.containsAll(outerTryBlock.getHandlers())) {
			List<BlockNode> mergedBlocks = Utils.concatDistinct(outerTryBlock.getBlocks(), innerTryBlock.getBlocks());
			List<ExceptionHandler> handlers = Utils.concatDistinct(outerTryBlock.getHandlers(), innerTryBlock.getHandlers());
			tryBlocks.add(new TryCatchBlockAttr(tryBlocks.size(), handlers, mergedBlocks));
			tryBlocks.remove(outerTryBlock);
			tryBlocks.remove(innerTryBlock);
			return true;
		}
		return false;
	}
	@NotNull
	private static Predicate<BlockNode> isHandlersIntersects(TryCatchBlockAttr outerTryBlock) {
		return block -> {
			CatchAttr catchAttr = block.get(AType.EXC_CATCH);
			return catchAttr != null && Objects.equals(catchAttr.getHandlers(), outerTryBlock.getHandlers());
		};
	}
	private static void removeExcHandler(MethodNode mth, ExceptionHandler excHandler) {
		excHandler.markForRemove();
		BlockSplitter.removeConnection(mth.getEnterBlock(), excHandler.getHandlerBlock());
	}
	private static boolean wrapBlocksWithTryCatch(MethodNode mth, TryCatchBlockAttr tryCatchBlock) {
		List<BlockNode> blocks = tryCatchBlock.getBlocks();
		BlockNode top = searchTopBlock(mth, blocks);
		if (top.getPredecessors().isEmpty() && top != mth.getEnterBlock()) {
			return false;
		}
		BlockNode bottom = searchBottomBlock(mth, blocks);
		BlockNode splitReturn;
		if (bottom != null && bottom.isReturnBlock()) {
			if (Consts.DEBUG_EXC_HANDLERS) {
				LOG.debug("TryCatch #{} bottom block ({}) is return, split", tryCatchBlock.id(), bottom);
			}
			splitReturn = bottom;
			bottom = BlockSplitter.blockSplitTop(mth, bottom);
			bottom.add(AFlag.SYNTHETIC);
		} else {
			splitReturn = null;
		}
		if (Consts.DEBUG_EXC_HANDLERS) {
			LOG.debug("TryCatch #{} split: top {}, bottom: {}", tryCatchBlock.id(), top, bottom);
		}
		BlockNode topSplitterBlock = getTopSplitterBlock(mth, top);
		topSplitterBlock.add(AFlag.EXC_TOP_SPLITTER);
		topSplitterBlock.add(AFlag.SYNTHETIC);
		int totalHandlerBlocks = tryCatchBlock.getHandlers().stream().mapToInt(eh -> eh.getBlocks().size()).sum();
		BlockNode bottomSplitterBlock;
		if (bottom == null || totalHandlerBlocks == 0) {
			bottomSplitterBlock = null;
		} else {
			BlockNode existBottomSplitter = BlockUtils.getBlockWithFlag(bottom.getSuccessors(), AFlag.EXC_BOTTOM_SPLITTER);
			bottomSplitterBlock = existBottomSplitter != null ? existBottomSplitter : BlockSplitter.startNewBlock(mth, -1);
			bottomSplitterBlock.add(AFlag.EXC_BOTTOM_SPLITTER);
			bottomSplitterBlock.add(AFlag.SYNTHETIC);
			BlockSplitter.connect(bottom, bottomSplitterBlock);
			if (splitReturn != null) {
				BlockSet bottomPreds = BlockSet.from(mth, bottom.getPredecessors());
				for (ExceptionHandler handler : tryCatchBlock.getHandlers()) {
					if (bottomPreds.intersects(handler.getBlocks())) {
						BlockNode lastBlock = bottomPreds.intersect(handler.getBlocks()).getOne();
						if (lastBlock != null) {
							BlockSplitter.replaceConnection(lastBlock, bottom, splitReturn);
						}
					}
				}
			}
		}
		if (Consts.DEBUG_EXC_HANDLERS) {
			LOG.debug("TryCatch #{} result splitters: top {}, bottom: {}",
					tryCatchBlock.id(), topSplitterBlock, bottomSplitterBlock);
		}
		connectSplittersAndHandlers(tryCatchBlock, topSplitterBlock, bottomSplitterBlock);
		for (BlockNode block : blocks) {
			TryCatchBlockAttr currentTCBAttr = block.get(AType.TRY_BLOCK);
			if (currentTCBAttr == null || currentTCBAttr.getInnerTryBlocks().contains(tryCatchBlock)) {
				block.addAttr(tryCatchBlock);
			}
		}
		tryCatchBlock.setTopSplitter(topSplitterBlock);
		topSplitterBlock.updateCleanSuccessors();
		if (bottomSplitterBlock != null) {
			bottomSplitterBlock.updateCleanSuccessors();
		}
		return true;
	}
	private static BlockNode getTopSplitterBlock(MethodNode mth, BlockNode top) {
		if (top == mth.getEnterBlock()) {
			BlockNode fixedTop = mth.getEnterBlock().getSuccessors().get(0);
			return BlockSplitter.blockSplitTop(mth, fixedTop);
		}
		BlockNode existPredTopSplitter = BlockUtils.getBlockWithFlag(top.getPredecessors(), AFlag.EXC_TOP_SPLITTER);
		if (existPredTopSplitter != null) {
			return existPredTopSplitter;
		}
		if (top.getCleanSuccessors().size() == 1 && top.getInstructions().isEmpty()) {
			BlockNode otherTopSplitter = BlockUtils.getBlockWithFlag(top.getCleanSuccessors(), AFlag.EXC_TOP_SPLITTER);
			if (otherTopSplitter != null && otherTopSplitter.getPredecessors().size() == 1) {
				return otherTopSplitter;
			}
		}
		return BlockSplitter.blockSplitTop(mth, top);
	}
	private static BlockNode searchTopBlock(MethodNode mth, List<BlockNode> blocks) {
		BlockNode top = BlockUtils.getTopBlock(blocks);
		if (top != null) {
			return adjustTopBlock(top);
		}
		BlockNode topDom = BlockUtils.getCommonDominator(mth, blocks);
		if (topDom != null) {
			if (topDom.getSuccessors().size() == 1) {
				BlockNode upBlock = topDom.getSuccessors().get(0);
				if (blocks.contains(upBlock)) {
					return upBlock;
				}
			}
			return adjustTopBlock(topDom);
		}
		throw new JadxRuntimeException("Failed to find top block for try-catch from: " + blocks);
	}
	private static BlockNode adjustTopBlock(BlockNode topBlock) {
		if (topBlock.getSuccessors().size() == 1 && !topBlock.contains(AType.EXC_CATCH)) {
			return topBlock.getSuccessors().get(0);
		}
		return topBlock;
	}
	@Nullable
	private static BlockNode searchBottomBlock(MethodNode mth, List<BlockNode> blocks) {
		BlockNode bottom = BlockUtils.getBottomBlock(blocks);
		if (bottom != null) {
			return bottom;
		}
		BlockNode pathCross = BlockUtils.getPathCross(mth, blocks);
		if (pathCross == null) {
			return null;
		}
		List<BlockNode> preds = new ArrayList<>(pathCross.getPredecessors());
		preds.removeAll(blocks);
		List<BlockNode> outsidePredecessors = preds.stream()
				.filter(p -> !BlockUtils.atLeastOnePathExists(blocks, p))
				.collect(Collectors.toList());
		if (outsidePredecessors.isEmpty()) {
			return pathCross;
		}
		BlockNode splitCross = BlockSplitter.blockSplitTop(mth, pathCross);
		splitCross.add(AFlag.SYNTHETIC);
		for (BlockNode outsidePredecessor : outsidePredecessors) {
			BlockSplitter.replaceConnection(outsidePredecessor, splitCross, pathCross);
		}
		return splitCross;
	}
	private static void connectSplittersAndHandlers(TryCatchBlockAttr tryCatchBlock, BlockNode topSplitterBlock,
			@Nullable BlockNode bottomSplitterBlock) {
		for (ExceptionHandler handler : tryCatchBlock.getHandlers()) {
			BlockNode handlerBlock = handler.getHandlerBlock();
			BlockSplitter.connect(topSplitterBlock, handlerBlock);
			if (bottomSplitterBlock != null) {
				BlockSplitter.connect(bottomSplitterBlock, handlerBlock);
			}
		}
		TryCatchBlockAttr outerTryBlock = tryCatchBlock.getOuterTryBlock();
		if (outerTryBlock != null) {
			connectSplittersAndHandlers(outerTryBlock, topSplitterBlock, bottomSplitterBlock);
		}
	}
	private static void fixMoveExceptionInsn(BlockNode block, ExcHandlerAttr excHandlerAttr) {
		ExceptionHandler excHandler = excHandlerAttr.getHandler();
		ArgType argType = excHandler.getArgType();
		InsnNode me = BlockUtils.getLastInsn(block);
		if (me != null && me.getType() == InsnType.MOVE_EXCEPTION) {
			RegisterArg resArg = InsnArg.reg(me.getResult().getRegNum(), argType);
			resArg.copyAttributesFrom(me);
			me.setResult(resArg);
			me.add(AFlag.DONT_INLINE);
			resArg.add(AFlag.CUSTOM_DECLARE);
			excHandler.setArg(resArg);
			me.addAttr(excHandlerAttr);
			return;
		}
		excHandler.setArg(new NamedArg("unused", argType));
	}
	private static void removeMonitorExitFromExcHandler(MethodNode mth, ExceptionHandler excHandler) {
		for (BlockNode excBlock : excHandler.getBlocks()) {
			InsnRemover remover = new InsnRemover(mth, excBlock);
			for (InsnNode insn : excBlock.getInstructions()) {
				if (insn.getType() == InsnType.MONITOR_ENTER) {
					break;
				}
				if (insn.getType() == InsnType.MONITOR_EXIT) {
					remover.addAndUnbind(insn);
				}
			}
			remover.perform();
		}
	}
	private static void checkForMultiCatch(MethodNode mth, List<TryCatchBlockAttr> tryBlocks) {
		boolean merged = false;
		for (TryCatchBlockAttr tryBlock : tryBlocks) {
			if (mergeMultiCatch(mth, tryBlock)) {
				merged = true;
			}
		}
		if (merged) {
			BlockSplitter.detachMarkedBlocks(mth);
			mth.clearExceptionHandlers();
		}
	}
	private static boolean mergeMultiCatch(MethodNode mth, TryCatchBlockAttr tryCatch) {
		if (tryCatch.getHandlers().size() < 2) {
			return false;
		}
		for (ExceptionHandler handler : tryCatch.getHandlers()) {
			if (handler.getBlocks().size() != 1) {
				return false;
			}
			BlockNode block = handler.getHandlerBlock();
			if (block.getInstructions().size() != 1
					|| !BlockUtils.checkLastInsnType(block, InsnType.MOVE_EXCEPTION)) {
				return false;
			}
		}
		List<BlockNode> handlerBlocks = ListUtils.map(tryCatch.getHandlers(), ExceptionHandler::getHandlerBlock);
		List<BlockNode> successorBlocks = handlerBlocks.stream()
				.flatMap(h -> h.getSuccessors().stream())
				.distinct()
				.collect(Collectors.toList());
		if (successorBlocks.size() != 1) {
			return false;
		}
		BlockNode successorBlock = successorBlocks.get(0);
		if (!ListUtils.unorderedEquals(successorBlock.getPredecessors(), handlerBlocks)) {
			return false;
		}
		List<RegisterArg> regs = tryCatch.getHandlers().stream()
				.map(h -> Objects.requireNonNull(BlockUtils.getLastInsn(h.getHandlerBlock())).getResult())
				.distinct()
				.collect(Collectors.toList());
		if (regs.size() != 1) {
			return false;
		}
		ExceptionHandler resultHandler = tryCatch.getHandlers().get(0);
		tryCatch.getHandlers().removeIf(handler -> {
			if (handler == resultHandler) {
				return false;
			}
			resultHandler.addCatchTypes(mth, handler.getCatchTypes());
			handler.markForRemove();
			return true;
		});
		return true;
	}
	private static void sortHandlers(MethodNode mth, List<TryCatchBlockAttr> tryBlocks) {
		TypeCompare typeCompare = mth.root().getTypeCompare();
		Comparator<ArgType> comparator = typeCompare.getReversedComparator();
		for (TryCatchBlockAttr tryBlock : tryBlocks) {
			for (ExceptionHandler handler : tryBlock.getHandlers()) {
				handler.getCatchTypes().sort((first, second) -> compareByTypeAndName(comparator, first, second));
			}
			tryBlock.getHandlers().sort((first, second) -> {
				if (first.equals(second)) {
					throw new JadxRuntimeException("Same handlers in try block: " + tryBlock);
				}
				if (first.isCatchAll()) {
					return 1;
				}
				if (second.isCatchAll()) {
					return -1;
				}
				return compareByTypeAndName(comparator,
						ListUtils.first(first.getCatchTypes()), ListUtils.first(second.getCatchTypes()));
			});
		}
	}
	@SuppressWarnings("ComparatorResultComparison")
	private static int compareByTypeAndName(Comparator<ArgType> comparator, ClassInfo first, ClassInfo second) {
		int r = comparator.compare(first.getType(), second.getType());
		if (r == -2) {
			return first.compareTo(second);
		}
		return r;
	}
	private static void removeUnusedExcHandlers(MethodNode mth, List<TryCatchBlockAttr> tryBlocks, BlockSet blocks) {
		for (ExceptionHandler eh : mth.getExceptionHandlers()) {
			boolean notProcessed = true;
			BlockNode handlerBlock = eh.getHandlerBlock();
			if (handlerBlock == null || blocks.get(handlerBlock)) {
				continue;
			}
			for (TryCatchBlockAttr tcb : tryBlocks) {
				if (tcb.getHandlers().contains(eh)) {
					notProcessed = false;
					break;
				}
			}
			if (notProcessed) {
				BlockProcessor.removeUnreachableBlock(handlerBlock, mth);
			}
		}
	}
}
SEVERITY = 5

package jadx.core.dex.nodes;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.api.DecompilationMode;
import jadx.api.ICodeCache;
import jadx.api.ICodeWriter;
import jadx.api.JadxArgs;
import jadx.api.JadxDecompiler;
import jadx.api.ResourceFile;
import jadx.api.ResourceType;
import jadx.api.ResourcesLoader;
import jadx.api.data.ICodeData;
import jadx.api.impl.passes.DecompilePassWrapper;
import jadx.api.impl.passes.PreparePassWrapper;
import jadx.api.plugins.input.ICodeLoader;
import jadx.api.plugins.input.data.IClassData;
import jadx.api.plugins.pass.JadxPass;
import jadx.api.plugins.pass.types.JadxDecompilePass;
import jadx.api.plugins.pass.types.JadxPassType;
import jadx.api.plugins.pass.types.JadxPreparePass;
import jadx.core.Jadx;
import jadx.core.ProcessClass;
import jadx.core.clsp.ClspGraph;
import jadx.core.dex.attributes.AttributeStorage;
import jadx.core.dex.info.ClassInfo;
import jadx.core.dex.info.ConstStorage;
import jadx.core.dex.info.FieldInfo;
import jadx.core.dex.info.InfoStorage;
import jadx.core.dex.info.MethodInfo;
import jadx.core.dex.info.PackageInfo;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.nodes.utils.MethodUtils;
import jadx.core.dex.nodes.utils.TypeUtils;
import jadx.core.dex.visitors.DepthTraversal;
import jadx.core.dex.visitors.IDexTreeVisitor;
import jadx.core.dex.visitors.typeinference.TypeCompare;
import jadx.core.dex.visitors.typeinference.TypeUpdate;
import jadx.core.export.GradleInfoStorage;
import jadx.core.utils.CacheStorage;
import jadx.core.utils.DebugChecks;
import jadx.core.utils.ErrorsCounter;
import jadx.core.utils.PassMerge;
import jadx.core.utils.StringUtils;
import jadx.core.utils.Utils;
import jadx.core.utils.android.AndroidResourcesUtils;
import jadx.core.utils.exceptions.JadxRuntimeException;
import jadx.core.xmlgen.IResTableParser;
import jadx.core.xmlgen.ManifestAttributes;
import jadx.core.xmlgen.ResourceStorage;
import jadx.core.xmlgen.entry.ResourceEntry;
import jadx.core.xmlgen.entry.ValuesParser;
public class RootNode {
	private static final Logger LOG = LoggerFactory.getLogger(RootNode.class);
	private final JadxArgs args;
	private final ErrorsCounter errorsCounter = new ErrorsCounter();
	private final StringUtils stringUtils;
	private final ConstStorage constValues;
	private final InfoStorage infoStorage = new InfoStorage();
	private final CacheStorage cacheStorage = new CacheStorage();
	private final TypeUpdate typeUpdate;
	private final MethodUtils methodUtils;
	private final TypeUtils typeUtils;
	private final AttributeStorage attributes = new AttributeStorage();
	private final List<ICodeDataUpdateListener> codeDataUpdateListeners = new ArrayList<>();
	private final GradleInfoStorage gradleInfoStorage = new GradleInfoStorage();
	private final Map<ClassInfo, ClassNode> clsMap = new HashMap<>();
	private final Map<String, ClassNode> rawClsMap = new HashMap<>();
	private List<ClassNode> classes = new ArrayList<>();
	private final Map<String, PackageNode> pkgMap = new HashMap<>();
	private final List<PackageNode> packages = new ArrayList<>();
	private List<IDexTreeVisitor> preDecompilePasses;
	private ProcessClass processClasses;
	private ClspGraph clsp;
	private @Nullable String appPackage;
	private @Nullable ClassNode appResClass;
	private @Nullable JadxDecompiler decompiler;
	private @Nullable ManifestAttributes manifestAttributes;
	public RootNode(JadxArgs args) {
		this.args = args;
		this.preDecompilePasses = Jadx.getPreDecompilePassesList();
		this.processClasses = new ProcessClass(Jadx.getPassesList(args));
		this.stringUtils = new StringUtils(args);
		this.constValues = new ConstStorage(args);
		this.typeUpdate = new TypeUpdate(this);
		this.methodUtils = new MethodUtils(this);
		this.typeUtils = new TypeUtils(this);
	}
	public void init() {
		if (args.isDeobfuscationOn() || !args.getRenameFlags().isEmpty()) {
			args.getAliasProvider().init(this);
		}
		if (args.isDeobfuscationOn()) {
			args.getRenameCondition().init(this);
		}
	}
	public void loadClasses(List<ICodeLoader> loadedInputs) {
		for (ICodeLoader codeLoader : loadedInputs) {
			codeLoader.visitClasses(cls -> {
				try {
					addClassNode(new ClassNode(RootNode.this, cls));
				} catch (Exception e) {
					addDummyClass(cls, e);
				}
				Utils.checkThreadInterrupt();
			});
		}
		if (classes.size() != clsMap.size()) {
			markDuplicatedClasses(classes);
		}
		classes = new ArrayList<>(clsMap.values());
		int mthCount = classes.stream().mapToInt(c -> c.getMethods().size()).sum();
		int insnsCount = classes.stream().flatMap(c -> c.getMethods().stream()).mapToInt(MethodNode::getInsnsCount).sum();
		LOG.info("Loaded classes: {}, methods: {}, instructions: {}", classes.size(), mthCount, insnsCount);
		classes.sort(Comparator.comparing(ClassNode::getFullName));
		if (args.isMoveInnerClasses()) {
			initInnerClasses();
		}
		Collections.sort(packages);
	}
	private void addDummyClass(IClassData classData, Exception exc) {
		try {
			String typeStr = classData.getType();
			String name = null;
			try {
				ClassInfo clsInfo = ClassInfo.fromName(this, typeStr);
				if (clsInfo != null) {
					name = clsInfo.getShortName();
				}
			} catch (Exception e) {
				LOG.error("Failed to get name for class with type {}", typeStr, e);
			}
			if (name == null || name.isEmpty()) {
				name = "CLASS_" + typeStr;
			}
			ClassNode clsNode = ClassNode.addSyntheticClass(this, name, classData.getAccessFlags());
			ErrorsCounter.error(clsNode, "Load error", exc);
		} catch (Exception innerExc) {
			LOG.error("Failed to load class from file: {}", classData.getInputFileName(), exc);
		}
	}
	private static void markDuplicatedClasses(List<ClassNode> classes) {
		classes.stream()
				.collect(Collectors.groupingBy(ClassNode::getClassInfo))
				.entrySet()
				.stream()
				.filter(entry -> entry.getValue().size() > 1)
				.forEach(entry -> {
					List<String> sources = Utils.collectionMap(entry.getValue(), ClassNode::getInputFileName);
					LOG.warn("Found duplicated class: {}, count: {}. Only one will be loaded!\n  {}",
							entry.getKey(), entry.getValue().size(), String.join("\n  ", sources));
					entry.getValue().forEach(cls -> {
						String thisSource = cls.getInputFileName();
						String otherSourceStr = sources.stream()
								.filter(s -> !s.equals(thisSource))
								.sorted()
								.collect(Collectors.joining("\n  "));
						cls.addWarnComment("Classes with same name are omitted:\n  " + otherSourceStr + '\n');
					});
				});
	}
	public void addClassNode(ClassNode clsNode) {
		classes.add(clsNode);
		clsMap.put(clsNode.getClassInfo(), clsNode);
		rawClsMap.put(clsNode.getRawName(), clsNode);
	}
	public void loadResources(ResourcesLoader resLoader, List<ResourceFile> resources) {
		ResourceFile arsc = getResourceFile(resources);
		if (arsc == null) {
			LOG.debug("'resources.arsc' or 'resources.pb' file not found");
			return;
		}
		try {
			IResTableParser parser = ResourcesLoader.decodeStream(arsc, (size, is) -> resLoader.decodeTable(arsc, is));
			if (parser != null) {
				processResources(parser.getResStorage());
				updateObfuscatedFiles(parser, resources);
				initManifestAttributes().updateAttributes(parser);
			}
		} catch (Exception e) {
			LOG.error("Failed to parse 'resources.pb'/'.arsc' file", e);
		}
	}
	private @Nullable ResourceFile getResourceFile(List<ResourceFile> resources) {
		for (ResourceFile rf : resources) {
			if (rf.getType() == ResourceType.ARSC) {
				return rf;
			}
		}
		return null;
	}
	public void processResources(ResourceStorage resStorage) {
		constValues.setResourcesNames(resStorage.getResourcesNames());
		appPackage = resStorage.getAppPackage();
		appResClass = AndroidResourcesUtils.searchAppResClass(this, resStorage);
	}
	public void initClassPath() {
		try {
			if (this.clsp == null) {
				ClspGraph newClsp = new ClspGraph(this);
				if (args.isLoadJadxClsSetFile()) {
					newClsp.loadClsSetFile();
				}
				newClsp.addApp(classes);
				newClsp.initCache();
				this.clsp = newClsp;
			}
		} catch (Exception e) {
			throw new JadxRuntimeException("Error loading jadx class set", e);
		}
	}
	private void updateObfuscatedFiles(IResTableParser parser, List<ResourceFile> resources) {
		if (args.isSkipResources()) {
			return;
		}
		long start = System.currentTimeMillis();
		int renamedCount = 0;
		ResourceStorage resStorage = parser.getResStorage();
		ValuesParser valuesParser = new ValuesParser(parser.getStrings(), resStorage.getResourcesNames());
		Map<String, ResourceEntry> entryNames = new HashMap<>();
		for (ResourceEntry resEntry : resStorage.getResources()) {
			String val = valuesParser.getSimpleValueString(resEntry);
			if (val != null) {
				entryNames.put(val, resEntry);
			}
		}
		for (ResourceFile resource : resources) {
			ResourceEntry resEntry = entryNames.get(resource.getOriginalName());
			if (resEntry != null) {
				if (resource.setAlias(resEntry)) {
					renamedCount++;
				}
			}
		}
		if (LOG.isDebugEnabled()) {
			LOG.debug("Renamed obfuscated resources: {}, duration: {}ms", renamedCount, System.currentTimeMillis() - start);
		}
	}
	private void initInnerClasses() {
		List<ClassNode> inner = new ArrayList<>();
		for (ClassNode cls : classes) {
			if (cls.getClassInfo().isInner()) {
				inner.add(cls);
			}
		}
		List<ClassNode> updated = new ArrayList<>();
		for (ClassNode cls : inner) {
			ClassInfo clsInfo = cls.getClassInfo();
			ClassNode parent = resolveParentClass(clsInfo);
			if (parent == null) {
				clsMap.remove(clsInfo);
				clsInfo.notInner(this);
				clsMap.put(clsInfo, cls);
				updated.add(cls);
			} else {
				parent.addInnerClass(cls);
			}
		}
		for (ClassNode updCls : updated) {
			for (ClassNode innerCls : updCls.getInnerClasses()) {
				innerCls.getClassInfo().updateNames(this);
			}
		}
		classes.forEach(ClassNode::updateParentClass);
		for (PackageNode pkg : packages) {
			pkg.getClasses().removeIf(cls -> cls.getClassInfo().isInner());
		}
	}
	public void mergePasses(Map<JadxPassType, List<JadxPass>> customPasses) {
		DecompilationMode mode = args.getDecompilationMode();
		if (mode == DecompilationMode.FALLBACK || mode == DecompilationMode.SIMPLE) {
			return;
		}
		new PassMerge(preDecompilePasses)
				.merge(customPasses.get(JadxPreparePass.TYPE), p -> new PreparePassWrapper((JadxPreparePass) p));
		new PassMerge(processClasses.getPasses())
				.merge(customPasses.get(JadxDecompilePass.TYPE), p -> new DecompilePassWrapper((JadxDecompilePass) p));
		if (args.isRunDebugChecks()) {
			preDecompilePasses = DebugChecks.insertPasses(preDecompilePasses);
			processClasses = new ProcessClass(DebugChecks.insertPasses(processClasses.getPasses()));
		}
	}
	public void runPreDecompileStage() {
		boolean debugEnabled = LOG.isDebugEnabled();
		for (IDexTreeVisitor pass : preDecompilePasses) {
			Utils.checkThreadInterrupt();
			long start = debugEnabled ? System.currentTimeMillis() : 0;
			try {
				pass.init(this);
			} catch (Exception e) {
				LOG.error("Visitor init failed: {}", pass.getClass().getSimpleName(), e);
			}
			for (ClassNode cls : classes) {
				if (cls.isInner()) {
					continue;
				}
				DepthTraversal.visit(pass, cls);
			}
			if (debugEnabled) {
				LOG.debug("Prepare pass: '{}' - {}ms", pass, System.currentTimeMillis() - start);
			}
		}
	}
	public void runPreDecompileStageForClass(ClassNode cls) {
		for (IDexTreeVisitor pass : preDecompilePasses) {
			DepthTraversal.visit(pass, cls);
		}
	}
	public void resetPasses() {
		preDecompilePasses.clear();
		preDecompilePasses.addAll(Jadx.getPreDecompilePassesList());
		processClasses.getPasses().clear();
		processClasses.getPasses().addAll(Jadx.getPassesList(args));
	}
	public void restartVisitors() {
		for (ClassNode cls : classes) {
			cls.unload();
			cls.clearAttributes();
			cls.unloadFromCache();
		}
		runPreDecompileStage();
	}
	public List<ClassNode> getClasses() {
		return classes;
	}
	public List<ClassNode> getClassesWithoutInner() {
		return getClasses(false);
	}
	public List<ClassNode> getClasses(boolean includeInner) {
		if (includeInner) {
			return classes;
		}
		List<ClassNode> notInnerClasses = new ArrayList<>();
		for (ClassNode cls : classes) {
			if (!cls.getClassInfo().isInner()) {
				notInnerClasses.add(cls);
			}
		}
		return notInnerClasses;
	}
	public List<PackageNode> getPackages() {
		return packages;
	}
	public @Nullable PackageNode resolvePackage(String fullPkg) {
		return pkgMap.get(fullPkg);
	}
	public @Nullable PackageNode resolvePackage(@Nullable PackageInfo pkgInfo) {
		return pkgInfo == null ? null : pkgMap.get(pkgInfo.getFullName());
	}
	public void addPackage(PackageNode pkg) {
		pkgMap.put(pkg.getPkgInfo().getFullName(), pkg);
		packages.add(pkg);
	}
	public void removePackage(PackageNode pkg) {
		if (pkgMap.remove(pkg.getPkgInfo().getFullName()) != null) {
			packages.remove(pkg);
			PackageNode parentPkg = pkg.getParentPkg();
			if (parentPkg != null) {
				parentPkg.getSubPackages().remove(pkg);
				if (parentPkg.isEmpty()) {
					removePackage(parentPkg);
				}
			}
			for (PackageNode subPkg : pkg.getSubPackages()) {
				removePackage(subPkg);
			}
		}
	}
	public void sortPackages() {
		Collections.sort(packages);
	}
	public void removeClsFromPackage(PackageNode pkg, ClassNode cls) {
		boolean removed = pkg.getClasses().remove(cls);
		if (removed && pkg.isEmpty()) {
			removePackage(pkg);
		}
	}
	public void runPackagesUpdate() {
		for (PackageNode pkg : getPackages()) {
			if (pkg.isRoot()) {
				pkg.updatePackages();
			}
		}
	}
	@Nullable
	public ClassNode resolveClass(ClassInfo clsInfo) {
		return clsMap.get(clsInfo);
	}
	@Nullable
	public ClassNode resolveClass(ArgType clsType) {
		if (!clsType.isTypeKnown() || clsType.isGenericType()) {
			return null;
		}
		if (clsType.getWildcardBound() == ArgType.WildcardBound.UNBOUND) {
			return null;
		}
		if (clsType.isGeneric()) {
			clsType = ArgType.object(clsType.getObject());
		}
		return resolveClass(ClassInfo.fromType(this, clsType));
	}
	@Nullable
	public ClassNode resolveClass(String fullName) {
		ClassInfo clsInfo = ClassInfo.fromName(this, fullName);
		return resolveClass(clsInfo);
	}
	@Nullable
	public ClassNode resolveRawClass(String rawFullName) {
		return rawClsMap.get(rawFullName);
	}
	@Nullable
	public ClassNode resolveParentClass(ClassInfo clsInfo) {
		ClassInfo parentInfo = clsInfo.getParentClass();
		ClassNode parentNode = resolveClass(parentInfo);
		if (parentNode == null && parentInfo != null) {
			String parClsName = parentInfo.getFullName();
			int sep = parClsName.lastIndexOf('.');
			if (sep > 0 && sep != parClsName.length() - 1) {
				String mthName = parClsName.substring(sep + 1);
				String upperParClsName = parClsName.substring(0, sep);
				ClassNode tmpParent = resolveClass(upperParClsName);
				if (tmpParent != null && tmpParent.searchMethodByShortName(mthName) != null) {
					parentNode = tmpParent;
					clsInfo.convertToInner(parentNode);
				}
			}
		}
		return parentNode;
	}
	@Nullable
	public ClassNode searchClassByFullAlias(String fullName) {
		for (ClassNode cls : classes) {
			ClassInfo classInfo = cls.getClassInfo();
			if (classInfo.getFullName().equals(fullName)
					|| classInfo.getAliasFullName().equals(fullName)) {
				return cls;
			}
		}
		return null;
	}
	public Map<String, ClassNode> buildFullAliasClassCache() {
		Map<String, ClassNode> classNameCache = new HashMap<>(classes.size());
		for (ClassNode cls : classes) {
			ClassInfo classInfo = cls.getClassInfo();
			String fullName = classInfo.getFullName();
			String alias = classInfo.getAliasFullName();
			classNameCache.put(fullName, cls);
			if (alias != null && !fullName.equals(alias)) {
				classNameCache.put(alias, cls);
			}
		}
		return classNameCache;
	}
	public List<ClassNode> searchClassByShortName(String shortName) {
		List<ClassNode> list = new ArrayList<>();
		for (ClassNode cls : classes) {
			if (cls.getClassInfo().getShortName().equals(shortName)) {
				list.add(cls);
			}
		}
		return list;
	}
	@Nullable
	public MethodNode resolveMethod(@NotNull MethodInfo mth) {
		ClassNode cls = resolveClass(mth.getDeclClass());
		if (cls == null) {
			return null;
		}
		MethodNode methodNode = cls.searchMethod(mth);
		if (methodNode != null) {
			return methodNode;
		}
		return deepResolveMethod(cls, mth.makeSignature(false));
	}
	public @NotNull MethodNode resolveDirectMethod(String rawClsName, String mthShortId) {
		ClassNode clsNode = resolveRawClass(rawClsName);
		if (clsNode == null) {
			throw new RuntimeException("Class not found: " + rawClsName);
		}
		MethodNode methodNode = clsNode.searchMethodByShortId(mthShortId);
		if (methodNode == null) {
			throw new RuntimeException("Method not found: " + rawClsName + "." + mthShortId);
		}
		return methodNode;
	}
	@Nullable
	private MethodNode deepResolveMethod(@NotNull ClassNode cls, String signature) {
		for (MethodNode m : cls.getMethods()) {
			if (m.getMethodInfo().getShortId().startsWith(signature)) {
				return m;
			}
		}
		MethodNode found;
		ArgType superClass = cls.getSuperClass();
		if (superClass != null) {
			ClassNode superNode = resolveClass(superClass);
			if (superNode != null) {
				found = deepResolveMethod(superNode, signature);
				if (found != null) {
					return found;
				}
			}
		}
		for (ArgType iFaceType : cls.getInterfaces()) {
			ClassNode iFaceNode = resolveClass(iFaceType);
			if (iFaceNode != null) {
				found = deepResolveMethod(iFaceNode, signature);
				if (found != null) {
					return found;
				}
			}
		}
		return null;
	}
	@Nullable
	public FieldNode resolveField(FieldInfo field) {
		ClassNode cls = resolveClass(field.getDeclClass());
		if (cls == null) {
			return null;
		}
		FieldNode fieldNode = cls.searchField(field);
		if (fieldNode != null) {
			return fieldNode;
		}
		return deepResolveField(cls, field);
	}
	@Nullable
	private FieldNode deepResolveField(@NotNull ClassNode cls, FieldInfo fieldInfo) {
		FieldNode field = cls.searchFieldByNameAndType(fieldInfo);
		if (field != null) {
			return field;
		}
		ArgType superClass = cls.getSuperClass();
		if (superClass != null) {
			ClassNode superNode = resolveClass(superClass);
			if (superNode != null) {
				FieldNode found = deepResolveField(superNode, fieldInfo);
				if (found != null) {
					return found;
				}
			}
		}
		for (ArgType iFaceType : cls.getInterfaces()) {
			ClassNode iFaceNode = resolveClass(iFaceType);
			if (iFaceNode != null) {
				FieldNode found = deepResolveField(iFaceNode, fieldInfo);
				if (found != null) {
					return found;
				}
			}
		}
		return null;
	}
	public ProcessClass getProcessClasses() {
		return processClasses;
	}
	public List<IDexTreeVisitor> getPasses() {
		return processClasses.getPasses();
	}
	public List<IDexTreeVisitor> getPreDecompilePasses() {
		return preDecompilePasses;
	}
	public void initPasses() {
		processClasses.initPasses(this);
	}
	public ICodeWriter makeCodeWriter() {
		JadxArgs jadxArgs = this.args;
		return jadxArgs.getCodeWriterProvider().apply(jadxArgs);
	}
	public void registerCodeDataUpdateListener(ICodeDataUpdateListener listener) {
		this.codeDataUpdateListeners.add(listener);
	}
	public void notifyCodeDataListeners() {
		ICodeData codeData = args.getCodeData();
		codeDataUpdateListeners.forEach(l -> l.updated(codeData));
	}
	public ClspGraph getClsp() {
		return clsp;
	}
	public ErrorsCounter getErrorsCounter() {
		return errorsCounter;
	}
	@Nullable
	public String getAppPackage() {
		return appPackage;
	}
	@Nullable
	public ClassNode getAppResClass() {
		return appResClass;
	}
	public StringUtils getStringUtils() {
		return stringUtils;
	}
	public ConstStorage getConstValues() {
		return constValues;
	}
	public InfoStorage getInfoStorage() {
		return infoStorage;
	}
	public CacheStorage getCacheStorage() {
		return cacheStorage;
	}
	public JadxArgs getArgs() {
		return args;
	}
	public void setDecompilerRef(JadxDecompiler jadxDecompiler) {
		this.decompiler = jadxDecompiler;
	}
	public @Nullable JadxDecompiler getDecompiler() {
		return decompiler;
	}
	public TypeUpdate getTypeUpdate() {
		return typeUpdate;
	}
	public TypeCompare getTypeCompare() {
		return typeUpdate.getTypeCompare();
	}
	public ICodeCache getCodeCache() {
		return args.getCodeCache();
	}
	public MethodUtils getMethodUtils() {
		return methodUtils;
	}
	public TypeUtils getTypeUtils() {
		return typeUtils;
	}
	public AttributeStorage getAttributes() {
		return attributes;
	}
	public GradleInfoStorage getGradleInfoStorage() {
		return gradleInfoStorage;
	}
	public synchronized ManifestAttributes initManifestAttributes() {
		ManifestAttributes attrs = manifestAttributes;
		if (attrs == null) {
			attrs = new ManifestAttributes(args.getSecurity());
			manifestAttributes = attrs;
		}
		return attrs;
	}
}
_______
package jadx.api.impl.passes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.api.plugins.pass.JadxPass;
import jadx.api.plugins.pass.types.JadxPreparePass;
import jadx.core.dex.nodes.RootNode;
import jadx.core.dex.visitors.AbstractVisitor;
import jadx.core.utils.exceptions.JadxException;
public class PreparePassWrapper extends AbstractVisitor implements IPassWrapperVisitor {
	private static final Logger LOG = LoggerFactory.getLogger(PreparePassWrapper.class);
	private final JadxPreparePass preparePass;
	public PreparePassWrapper(JadxPreparePass preparePass) {
		this.preparePass = preparePass;
	}
	@Override
	public JadxPass getPass() {
		return preparePass;
	}
	@Override
	public void init(RootNode root) throws JadxException {
		try {
			preparePass.init(root);
		} catch (Exception e) {
			LOG.error("Error in prepare pass init: {}", this, e);
		}
	}
	@Override
	public String getName() {
		return preparePass.getInfo().getName();
	}
}
_______
package jadx.core;
import java.util.List;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.api.ICodeInfo;
import jadx.api.impl.SimpleCodeInfo;
import jadx.core.codegen.CodeGen;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.nodes.ClassNode;
import jadx.core.dex.nodes.LoadStage;
import jadx.core.dex.nodes.RootNode;
import jadx.core.dex.visitors.DepthTraversal;
import jadx.core.dex.visitors.IDexTreeVisitor;
import jadx.core.utils.exceptions.JadxRuntimeException;
import static jadx.core.dex.nodes.ProcessState.GENERATED_AND_UNLOADED;
import static jadx.core.dex.nodes.ProcessState.LOADED;
import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;
import static jadx.core.dex.nodes.ProcessState.PROCESS_COMPLETE;
import static jadx.core.dex.nodes.ProcessState.PROCESS_STARTED;
public class ProcessClass {
	private static final Logger LOG = LoggerFactory.getLogger(ProcessClass.class);
	private static final ICodeInfo NOT_GENERATED = new SimpleCodeInfo("");
	private final List<IDexTreeVisitor> passes;
	public ProcessClass(List<IDexTreeVisitor> passesList) {
		this.passes = passesList;
	}
	@Nullable
	private ICodeInfo process(ClassNode cls, boolean codegen) {
		if (!codegen && cls.getState() == PROCESS_COMPLETE) {
			return null;
		}
		synchronized (cls.getClassInfo()) {
			try {
				if (cls.contains(AFlag.CLASS_DEEP_RELOAD)) {
					cls.remove(AFlag.CLASS_DEEP_RELOAD);
					cls.deepUnload();
					cls.add(AFlag.CLASS_UNLOADED);
				}
				if (cls.contains(AFlag.CLASS_UNLOADED)) {
					cls.root().runPreDecompileStageForClass(cls);
					cls.remove(AFlag.CLASS_UNLOADED);
				}
				if (cls.getState() == GENERATED_AND_UNLOADED) {
					cls.setState(NOT_LOADED);
				}
				if (codegen) {
					cls.setLoadStage(LoadStage.CODEGEN_STAGE);
					if (cls.contains(AFlag.RELOAD_AT_CODEGEN_STAGE)) {
						cls.remove(AFlag.RELOAD_AT_CODEGEN_STAGE);
						cls.unload();
					}
				} else {
					cls.setLoadStage(LoadStage.PROCESS_STAGE);
				}
				if (cls.getState() == NOT_LOADED) {
					cls.load();
				}
				if (cls.getState() == LOADED) {
					cls.setState(PROCESS_STARTED);
					for (IDexTreeVisitor visitor : passes) {
						DepthTraversal.visit(visitor, cls);
					}
					cls.setState(PROCESS_COMPLETE);
				}
				if (codegen) {
					ICodeInfo code = CodeGen.generate(cls);
					if (!cls.contains(AFlag.DONT_UNLOAD_CLASS)) {
						cls.unload();
						cls.setState(GENERATED_AND_UNLOADED);
					}
					return code;
				}
				return null;
			} catch (Throwable e) {
				if (codegen) {
					throw e;
				}
				cls.addError("Class process error: " + e.getClass().getSimpleName(), e);
				return null;
			}
		}
	}
	@NotNull
	public ICodeInfo generateCode(ClassNode cls) {
		ClassNode topParentClass = cls.getTopParentClass();
		if (topParentClass != cls) {
			return generateCode(topParentClass);
		}
		try {
			if (cls.contains(AFlag.DONT_GENERATE)) {
				process(cls, false);
				return NOT_GENERATED;
			}
			for (ClassNode depCls : cls.getDependencies()) {
				process(depCls, false);
			}
			if (!cls.getCodegenDeps().isEmpty()) {
				process(cls, false);
				for (ClassNode codegenDep : cls.getCodegenDeps()) {
					process(codegenDep, false);
				}
			}
			ICodeInfo code = process(cls, true);
			if (code == null) {
				throw new JadxRuntimeException("Codegen failed");
			}
			return code;
		} catch (Throwable e) {
			throw new JadxRuntimeException("Failed to generate code for class: " + cls.getFullName(), e);
		}
	}
	public void forceProcess(ClassNode cls) {
		ClassNode topParentClass = cls.getTopParentClass();
		if (topParentClass != cls) {
			forceProcess(topParentClass);
			return;
		}
		try {
			process(cls, false);
		} catch (Throwable e) {
			throw new JadxRuntimeException("Failed to process class: " + cls.getFullName(), e);
		}
	}
	public @Nullable ICodeInfo forceGenerateCode(ClassNode cls) {
		try {
			return process(cls, true);
		} catch (Throwable e) {
			throw new JadxRuntimeException("Failed to generate code for class: " + cls.getFullName(), e);
		}
	}
	public void initPasses(RootNode root) {
		for (IDexTreeVisitor pass : passes) {
			try {
				pass.init(root);
			} catch (Exception e) {
				LOG.error("Visitor init failed: {}", pass.getClass().getSimpleName(), e);
			}
		}
	}
	public List<IDexTreeVisitor> getPasses() {
		return passes;
	}
}
_______
package jadx.core.clsp;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.core.Consts;
import jadx.core.dex.info.MethodInfo;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.nodes.ClassNode;
import jadx.core.dex.nodes.IMethodDetails;
import jadx.core.dex.nodes.RootNode;
import jadx.core.utils.exceptions.DecodeException;
import jadx.core.utils.exceptions.JadxRuntimeException;
public class ClspGraph {
	private static final Logger LOG = LoggerFactory.getLogger(ClspGraph.class);
	private final RootNode root;
	private Map<String, ClspClass> nameMap;
	private Map<String, Set<String>> superTypesCache;
	private Map<String, List<String>> implementsCache;
	private final Set<String> missingClasses = new HashSet<>();
	public ClspGraph(RootNode rootNode) {
		this.root = rootNode;
	}
	public void loadClsSetFile() throws IOException, DecodeException {
		ClsSet set = new ClsSet(root);
		set.loadFromClstFile();
		addClasspath(set);
	}
	public void addClasspath(ClsSet set) {
		if (nameMap == null) {
			nameMap = new HashMap<>(set.getClassesCount());
			set.addToMap(nameMap);
		} else {
			throw new JadxRuntimeException("Classpath already loaded");
		}
	}
	public void addApp(List<ClassNode> classes) {
		if (nameMap == null) {
			nameMap = new HashMap<>(classes.size());
		}
		for (ClassNode cls : classes) {
			addClass(cls);
		}
	}
	public void initCache() {
		fillSuperTypesCache();
		fillImplementsCache();
	}
	public boolean isClsKnown(String fullName) {
		return nameMap.containsKey(fullName);
	}
	public ClspClass getClsDetails(ArgType type) {
		return nameMap.get(type.getObject());
	}
	@Nullable
	public IMethodDetails getMethodDetails(MethodInfo methodInfo) {
		ClspClass cls = nameMap.get(methodInfo.getDeclClass().getRawName());
		if (cls == null) {
			return null;
		}
		ClspMethod clspMethod = getMethodFromClass(cls, methodInfo);
		if (clspMethod != null) {
			return clspMethod;
		}
		for (ArgType parent : cls.getParents()) {
			ClspClass clspParent = getClspClass(parent);
			if (clspParent != null) {
				ClspMethod methodFromParent = getMethodFromClass(clspParent, methodInfo);
				if (methodFromParent != null) {
					return methodFromParent;
				}
			}
		}
		return new SimpleMethodDetails(methodInfo);
	}
	private ClspMethod getMethodFromClass(ClspClass cls, MethodInfo methodInfo) {
		return cls.getMethodsMap().get(methodInfo.getShortId());
	}
	private void addClass(ClassNode cls) {
		ArgType clsType = cls.getClassInfo().getType();
		String rawName = clsType.getObject();
		ClspClass clspClass = new ClspClass(clsType, -1, cls.getAccessFlags().rawValue(), ClspClassSource.APP);
		clspClass.setParents(ClsSet.makeParentsArray(cls));
		nameMap.put(rawName, clspClass);
	}
	public boolean isImplements(String clsName, String implClsName) {
		Set<String> anc = getSuperTypes(clsName);
		return anc.contains(implClsName);
	}
	public List<String> getImplementations(String clsName) {
		List<String> list = implementsCache.get(clsName);
		return list == null ? Collections.emptyList() : list;
	}
	private void fillImplementsCache() {
		Map<String, List<String>> map = new HashMap<>(nameMap.size());
		List<String> classes = new ArrayList<>(nameMap.keySet());
		Collections.sort(classes);
		for (String cls : classes) {
			for (String st : getSuperTypes(cls)) {
				map.computeIfAbsent(st, v -> new ArrayList<>()).add(cls);
			}
		}
		implementsCache = map;
	}
	public String getCommonAncestor(String clsName, String implClsName) {
		if (clsName.equals(implClsName)) {
			return clsName;
		}
		ClspClass cls = nameMap.get(implClsName);
		if (cls == null) {
			missingClasses.add(clsName);
			return null;
		}
		if (isImplements(clsName, implClsName)) {
			return implClsName;
		}
		Set<String> anc = getSuperTypes(clsName);
		return searchCommonParent(anc, cls);
	}
	private String searchCommonParent(Set<String> anc, ClspClass cls) {
		for (ArgType p : cls.getParents()) {
			String name = p.getObject();
			if (anc.contains(name)) {
				return name;
			}
			ClspClass nCls = getClspClass(p);
			if (nCls != null) {
				String r = searchCommonParent(anc, nCls);
				if (r != null) {
					return r;
				}
			}
		}
		return null;
	}
	public Set<String> getSuperTypes(String clsName) {
		Set<String> result = superTypesCache.get(clsName);
		return result == null ? Collections.emptySet() : result;
	}
	private static final Set<String> OBJECT_SINGLE_SET = Collections.singleton(Consts.CLASS_OBJECT);
	private void fillSuperTypesCache() {
		Map<String, Set<String>> map = new HashMap<>(nameMap.size());
		Set<String> tmpSet = new HashSet<>();
		for (Map.Entry<String, ClspClass> entry : nameMap.entrySet()) {
			ClspClass cls = entry.getValue();
			tmpSet.clear();
			addSuperTypes(cls, tmpSet);
			Set<String> result;
			int size = tmpSet.size();
			switch (size) {
				case 0: {
					result = Collections.emptySet();
					break;
				}
				case 1: {
					String supCls = tmpSet.iterator().next();
					if (supCls.equals(Consts.CLASS_OBJECT)) {
						result = OBJECT_SINGLE_SET;
					} else {
						result = Collections.singleton(supCls);
					}
					break;
				}
				default: {
					result = new HashSet<>(tmpSet);
					break;
				}
			}
			map.put(cls.getName(), result);
		}
		superTypesCache = map;
	}
	private void addSuperTypes(ClspClass cls, Set<String> result) {
		for (ArgType parentType : cls.getParents()) {
			if (parentType == null) {
				continue;
			}
			ClspClass parentCls = getClspClass(parentType);
			if (parentCls != null) {
				boolean isNew = result.add(parentCls.getName());
				if (isNew) {
					addSuperTypes(parentCls, result);
				}
			} else {
				result.add(parentType.getObject());
			}
		}
	}
	@Nullable
	private ClspClass getClspClass(ArgType clsType) {
		ClspClass clspClass = nameMap.get(clsType.getObject());
		if (clspClass == null) {
			missingClasses.add(clsType.getObject());
		}
		return clspClass;
	}
	public void printMissingClasses() {
		int count = missingClasses.size();
		if (count == 0) {
			return;
		}
		LOG.warn("Found {} references to unknown classes", count);
		if (LOG.isDebugEnabled()) {
			List<String> clsNames = new ArrayList<>(missingClasses);
			Collections.sort(clsNames);
			for (String cls : clsNames) {
				LOG.debug("  {}", cls);
			}
		}
	}
}
_______
package jadx.core.dex.nodes;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import jadx.api.JavaPackage;
import jadx.api.metadata.ICodeNodeRef;
import jadx.core.dex.attributes.nodes.LineAttrNode;
import jadx.core.dex.info.PackageInfo;
import static jadx.core.utils.StringUtils.containsChar;
public class PackageNode extends LineAttrNode
		implements IPackageUpdate, IDexNode, ICodeNodeRef, Comparable<PackageNode> {
	private final RootNode root;
	private final PackageInfo pkgInfo;
	private final @Nullable PackageNode parentPkg;
	private final List<PackageNode> subPackages = new ArrayList<>();
	private final List<ClassNode> classes = new ArrayList<>();
	private PackageInfo aliasPkgInfo;
	private JavaPackage javaNode;
	public static PackageNode getForClass(RootNode root, String fullPkg, ClassNode cls) {
		PackageNode pkg = getOrBuild(root, fullPkg);
		pkg.getClasses().add(cls);
		return pkg;
	}
	public static PackageNode getOrBuild(RootNode root, String fullPkg) {
		PackageNode existPkg = root.resolvePackage(fullPkg);
		if (existPkg != null) {
			return existPkg;
		}
		PackageInfo pgkInfo = PackageInfo.fromFullPkg(root, fullPkg);
		PackageNode parentPkg = getParentPkg(root, pgkInfo);
		PackageNode pkgNode = new PackageNode(root, parentPkg, pgkInfo);
		if (parentPkg != null) {
			parentPkg.getSubPackages().add(pkgNode);
		}
		root.addPackage(pkgNode);
		return pkgNode;
	}
	private static @Nullable PackageNode getParentPkg(RootNode root, PackageInfo pgkInfo) {
		PackageInfo parentPkg = pgkInfo.getParentPkg();
		if (parentPkg == null) {
			return null;
		}
		return getOrBuild(root, parentPkg.getFullName());
	}
	private PackageNode(RootNode root, @Nullable PackageNode parentPkg, PackageInfo pkgInfo) {
		this.root = root;
		this.parentPkg = parentPkg;
		this.pkgInfo = pkgInfo;
		this.aliasPkgInfo = pkgInfo;
	}
	@Override
	public void rename(String newName) {
		rename(newName, true);
	}
	public void rename(String newName, boolean runUpdates) {
		String alias;
		boolean isFullAlias;
		if (containsChar(newName, '/')) {
			alias = newName.replace('/', '.');
			isFullAlias = true;
		} else if (newName.startsWith(".")) {
			alias = newName.substring(1);
			isFullAlias = true;
		} else {
			alias = newName;
			isFullAlias = containsChar(newName, '.');
		}
		if (isFullAlias) {
			setFullAlias(alias, runUpdates);
		} else {
			setLeafAlias(alias, runUpdates);
		}
	}
	public void setLeafAlias(String alias, boolean runUpdates) {
		if (pkgInfo.getName().equals(alias)) {
			aliasPkgInfo = pkgInfo;
		} else {
			aliasPkgInfo = PackageInfo.fromShortName(root, getParentAliasPkgInfo(), alias);
		}
		if (runUpdates) {
			updatePackages(this);
		}
	}
	public void setFullAlias(String fullAlias, boolean runUpdates) {
		if (pkgInfo.getFullName().equals(fullAlias)) {
			aliasPkgInfo = pkgInfo;
		} else {
			aliasPkgInfo = PackageInfo.fromFullPkg(root, fullAlias);
		}
		if (runUpdates) {
			updatePackages(this);
		}
	}
	@Override
	public void onParentPackageUpdate(PackageNode updatedPkg) {
		aliasPkgInfo = PackageInfo.fromShortName(root, getParentAliasPkgInfo(), aliasPkgInfo.getName());
		updatePackages(updatedPkg);
	}
	public void updatePackages() {
		updatePackages(this);
	}
	private void updatePackages(PackageNode updatedPkg) {
		for (PackageNode subPackage : subPackages) {
			subPackage.onParentPackageUpdate(updatedPkg);
		}
		for (ClassNode cls : classes) {
			cls.onParentPackageUpdate(updatedPkg);
		}
	}
	public String getName() {
		return pkgInfo.getName();
	}
	public String getFullName() {
		return pkgInfo.getFullName();
	}
	public PackageInfo getPkgInfo() {
		return pkgInfo;
	}
	public PackageInfo getAliasPkgInfo() {
		return aliasPkgInfo;
	}
	public boolean hasAlias() {
		if (pkgInfo == aliasPkgInfo) {
			return false;
		}
		return !pkgInfo.getName().equals(aliasPkgInfo.getName());
	}
	public boolean hasParentAlias() {
		if (pkgInfo == aliasPkgInfo) {
			return false;
		}
		return !Objects.equals(pkgInfo.getParentPkg(), aliasPkgInfo.getParentPkg());
	}
	public void removeAlias() {
		aliasPkgInfo = pkgInfo;
	}
	public @Nullable PackageNode getParentPkg() {
		return parentPkg;
	}
	public @Nullable PackageInfo getParentAliasPkgInfo() {
		return parentPkg == null ? null : parentPkg.aliasPkgInfo;
	}
	public boolean isRoot() {
		return parentPkg == null;
	}
	public boolean isLeaf() {
		return subPackages.isEmpty();
	}
	public List<PackageNode> getSubPackages() {
		return subPackages;
	}
	public List<ClassNode> getClasses() {
		return classes;
	}
	public JavaPackage getJavaNode() {
		return javaNode;
	}
	public void setJavaNode(JavaPackage javaNode) {
		this.javaNode = javaNode;
	}
	public boolean isEmpty() {
		return classes.isEmpty() && subPackages.isEmpty();
	}
	@Override
	public String typeName() {
		return "package";
	}
	@Override
	public AnnType getAnnType() {
		return AnnType.PKG;
	}
	@Override
	public RootNode root() {
		return root;
	}
	@Override
	public String getInputFileName() {
		return "";
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof PackageNode)) {
			return false;
		}
		return pkgInfo.equals(((PackageNode) o).pkgInfo);
	}
	@Override
	public int hashCode() {
		return pkgInfo.hashCode();
	}
	@Override
	public int compareTo(@NotNull PackageNode other) {
		return getPkgInfo().getFullName().compareTo(other.getPkgInfo().getFullName());
	}
	@Override
	public String toString() {
		return getPkgInfo().getFullName();
	}
}
_______
package jadx.core.dex.nodes.utils;
import java.util.ArrayList;
import java.util.List;
import org.jetbrains.annotations.Nullable;
import jadx.core.clsp.ClspClass;
import jadx.core.clsp.ClspMethod;
import jadx.core.dex.attributes.AType;
import jadx.core.dex.attributes.nodes.MethodBridgeAttr;
import jadx.core.dex.attributes.nodes.MethodOverrideAttr;
import jadx.core.dex.attributes.nodes.SkipMethodArgsAttr;
import jadx.core.dex.info.ClassInfo;
import jadx.core.dex.info.MethodInfo;
import jadx.core.dex.instructions.BaseInvokeNode;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.instructions.args.InsnArg;
import jadx.core.dex.nodes.ClassNode;
import jadx.core.dex.nodes.IMethodDetails;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.nodes.RootNode;
import jadx.core.utils.Utils;
public class MethodUtils {
	private final RootNode root;
	public MethodUtils(RootNode rootNode) {
		this.root = rootNode;
	}
	@Nullable
	public IMethodDetails getMethodDetails(BaseInvokeNode invokeNode) {
		IMethodDetails methodDetails = invokeNode.get(AType.METHOD_DETAILS);
		if (methodDetails != null) {
			return methodDetails;
		}
		return getMethodDetails(invokeNode.getCallMth());
	}
	@Nullable
	public IMethodDetails getMethodDetails(MethodInfo callMth) {
		MethodNode mthNode = root.resolveMethod(callMth);
		if (mthNode != null) {
			return mthNode;
		}
		return root.getClsp().getMethodDetails(callMth);
	}
	@Nullable
	public MethodNode resolveMethod(BaseInvokeNode invokeNode) {
		IMethodDetails methodDetails = getMethodDetails(invokeNode);
		if (methodDetails instanceof MethodNode) {
			return (MethodNode) methodDetails;
		}
		return null;
	}
	public boolean isSkipArg(BaseInvokeNode invokeNode, InsnArg arg) {
		MethodNode mth = resolveMethod(invokeNode);
		if (mth == null) {
			return false;
		}
		SkipMethodArgsAttr skipArgsAttr = mth.get(AType.SKIP_MTH_ARGS);
		if (skipArgsAttr == null) {
			return false;
		}
		int argIndex = invokeNode.getArgIndex(arg);
		return skipArgsAttr.isSkip(argIndex);
	}
	public boolean isMethodArgsOverloaded(ArgType startCls, MethodInfo mthInfo) {
		return processMethodArgsOverloaded(startCls, mthInfo, null);
	}
	public List<IMethodDetails> collectOverloadedMethods(ArgType startCls, MethodInfo mthInfo) {
		List<IMethodDetails> list = new ArrayList<>();
		processMethodArgsOverloaded(startCls, mthInfo, list);
		return list;
	}
	@Nullable
	public ArgType getMethodGenericReturnType(BaseInvokeNode invokeNode) {
		IMethodDetails methodDetails = getMethodDetails(invokeNode);
		if (methodDetails != null) {
			ArgType returnType = methodDetails.getReturnType();
			if (returnType != null && returnType.containsGeneric()) {
				return returnType;
			}
		}
		return null;
	}
	private boolean processMethodArgsOverloaded(ArgType startCls, MethodInfo mthInfo, @Nullable List<IMethodDetails> collectedMths) {
		if (startCls == null || !startCls.isObject()) {
			return false;
		}
		boolean isMthConstructor = mthInfo.isConstructor() || mthInfo.isClassInit();
		ClassNode classNode = root.resolveClass(startCls);
		if (classNode != null) {
			for (MethodNode mth : classNode.getMethods()) {
				if (mthInfo.isOverloadedBy(mth.getMethodInfo())) {
					if (collectedMths == null) {
						return true;
					}
					collectedMths.add(mth);
				}
			}
			if (!isMthConstructor) {
				if (processMethodArgsOverloaded(classNode.getSuperClass(), mthInfo, collectedMths)) {
					if (collectedMths == null) {
						return true;
					}
				}
				for (ArgType parentInterface : classNode.getInterfaces()) {
					if (processMethodArgsOverloaded(parentInterface, mthInfo, collectedMths)) {
						if (collectedMths == null) {
							return true;
						}
					}
				}
			}
		} else {
			ClspClass clsDetails = root.getClsp().getClsDetails(startCls);
			if (clsDetails == null) {
				return false;
			}
			for (ClspMethod clspMth : clsDetails.getMethodsMap().values()) {
				if (mthInfo.isOverloadedBy(clspMth.getMethodInfo())) {
					if (collectedMths == null) {
						return true;
					}
					collectedMths.add(clspMth);
				}
			}
			if (!isMthConstructor) {
				for (ArgType parent : clsDetails.getParents()) {
					if (processMethodArgsOverloaded(parent, mthInfo, collectedMths)) {
						if (collectedMths == null) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}
	@Nullable
	public IMethodDetails getOverrideBaseMth(MethodNode mth) {
		MethodOverrideAttr overrideAttr = mth.get(AType.METHOD_OVERRIDE);
		if (overrideAttr == null) {
			return null;
		}
		return Utils.getOne(overrideAttr.getBaseMethods());
	}
	public ClassInfo getMethodOriginDeclClass(MethodNode mth) {
		IMethodDetails baseMth = getOverrideBaseMth(mth);
		if (baseMth != null) {
			return baseMth.getMethodInfo().getDeclClass();
		}
		MethodBridgeAttr bridgeAttr = mth.get(AType.BRIDGED_BY);
		if (bridgeAttr != null) {
			return getMethodOriginDeclClass(bridgeAttr.getBridgeMth());
		}
		return mth.getMethodInfo().getDeclClass();
	}
}
_______
package jadx.core.dex.visitors.typeinference;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Supplier;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.core.Consts;
import jadx.core.clsp.ClspClass;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.instructions.ArithNode;
import jadx.core.dex.instructions.BaseInvokeNode;
import jadx.core.dex.instructions.IndexInsnNode;
import jadx.core.dex.instructions.InsnType;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.instructions.args.InsnArg;
import jadx.core.dex.instructions.args.PrimitiveType;
import jadx.core.dex.instructions.args.RegisterArg;
import jadx.core.dex.instructions.args.SSAVar;
import jadx.core.dex.nodes.IMethodDetails;
import jadx.core.dex.nodes.InsnNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.nodes.RootNode;
import jadx.core.dex.nodes.utils.TypeUtils;
import jadx.core.utils.exceptions.JadxOverflowException;
import jadx.core.utils.exceptions.JadxRuntimeException;
import static jadx.core.dex.visitors.typeinference.TypeUpdateResult.CHANGED;
import static jadx.core.dex.visitors.typeinference.TypeUpdateResult.REJECT;
import static jadx.core.dex.visitors.typeinference.TypeUpdateResult.SAME;
public final class TypeUpdate {
	private static final Logger LOG = LoggerFactory.getLogger(TypeUpdate.class);
	private final RootNode root;
	private final Map<InsnType, ITypeListener> listenerRegistry;
	private final TypeCompare comparator;
	public TypeUpdate(RootNode root) {
		this.root = root;
		this.listenerRegistry = initListenerRegistry();
		this.comparator = new TypeCompare(root);
	}
	public TypeUpdateResult apply(MethodNode mth, SSAVar ssaVar, ArgType candidateType) {
		return apply(mth, ssaVar, candidateType, TypeUpdateFlags.FLAGS_EMPTY);
	}
	public TypeUpdateResult applyWithWiderAllow(MethodNode mth, SSAVar ssaVar, ArgType candidateType) {
		return apply(mth, ssaVar, candidateType, TypeUpdateFlags.FLAGS_WIDER);
	}
	public TypeUpdateResult applyWithWiderIgnSame(MethodNode mth, SSAVar ssaVar, ArgType candidateType) {
		return apply(mth, ssaVar, candidateType, TypeUpdateFlags.FLAGS_WIDER_IGNORE_SAME);
	}
	public TypeUpdateResult applyWithWiderIgnoreUnknown(MethodNode mth, SSAVar ssaVar, ArgType candidateType) {
		return apply(mth, ssaVar, candidateType, TypeUpdateFlags.FLAGS_WIDER_IGNORE_UNKNOWN);
	}
	private TypeUpdateResult apply(MethodNode mth, SSAVar ssaVar, ArgType candidateType, TypeUpdateFlags flags) {
		if (candidateType == null || !candidateType.isTypeKnown()) {
			return REJECT;
		}
		TypeUpdateInfo updateInfo = new TypeUpdateInfo(mth, flags);
		TypeUpdateResult result = updateTypeChecked(updateInfo, ssaVar.getAssign(), candidateType);
		if (result == REJECT) {
			return result;
		}
		if (updateInfo.isEmpty()) {
			return SAME;
		}
		if (Consts.DEBUG_TYPE_INFERENCE) {
			LOG.debug("Applying type {} to {}:", candidateType, ssaVar.toShortString());
			updateInfo.getSortedUpdates().forEach(upd -> LOG.debug("  {} -> {} in {}",
					upd.getType(), upd.getArg().toShortString(), upd.getArg().getParentInsn()));
		}
		updateInfo.applyUpdates();
		return CHANGED;
	}
	private TypeUpdateResult updateTypeChecked(TypeUpdateInfo updateInfo, InsnArg arg, ArgType candidateType) {
		if (candidateType == null) {
			throw new JadxRuntimeException("Null type update for arg: " + arg);
		}
		if (updateInfo.isProcessed(arg)) {
			return CHANGED;
		}
		TypeUpdateResult res = verifyType(updateInfo, arg, candidateType);
		if (res != null) {
			return res;
		}
		if (arg instanceof RegisterArg) {
			RegisterArg reg = (RegisterArg) arg;
			return updateTypeForSsaVar(updateInfo, reg.getSVar(), candidateType);
		}
		return requestUpdate(updateInfo, arg, candidateType);
	}
	private @Nullable TypeUpdateResult verifyType(TypeUpdateInfo updateInfo, InsnArg arg, ArgType candidateType) {
		ArgType currentType = arg.getType();
		if (Objects.equals(currentType, candidateType)) {
			if (!updateInfo.getFlags().isIgnoreSame()) {
				return SAME;
			}
		} else {
			if (candidateType.isWildcard()) {
				if (Consts.DEBUG_TYPE_INFERENCE) {
					LOG.debug("Wildcard type rejected for {}: candidate={}, current={}", arg, candidateType, currentType);
				}
				return REJECT;
			}
			TypeCompareEnum compareResult = comparator.compareTypes(candidateType, currentType);
			if (compareResult.isConflict()) {
				if (Consts.DEBUG_TYPE_INFERENCE) {
					LOG.debug("Type rejected for {}: candidate={} in conflict with current={}", arg, candidateType, currentType);
				}
				return REJECT;
			}
			if (compareResult == TypeCompareEnum.UNKNOWN && updateInfo.getFlags().isIgnoreUnknown()) {
				return REJECT;
			}
			if (arg.isTypeImmutable() && currentType != ArgType.UNKNOWN) {
				if (compareResult == TypeCompareEnum.EQUAL) {
					return SAME;
				}
				if (Consts.DEBUG_TYPE_INFERENCE) {
					LOG.debug("Type rejected for {} due to conflict: candidate={}, current={}", arg, candidateType, currentType);
				}
				return REJECT;
			}
			if (compareResult.isWider() && !updateInfo.getFlags().isAllowWider()) {
				if (Consts.DEBUG_TYPE_INFERENCE) {
					LOG.debug("Type rejected for {}: candidate={} is wider than current={}", arg, candidateType, currentType);
				}
				return REJECT;
			}
			if (candidateType.containsTypeVariable()) {
				ArgType unknownTypeVar = root.getTypeUtils().checkForUnknownTypeVars(updateInfo.getMth(), candidateType);
				if (unknownTypeVar != null) {
					if (Consts.DEBUG_TYPE_INFERENCE) {
						LOG.debug("Type rejected for {}: candidate: '{}' has unknown type var: '{}'", arg, candidateType, unknownTypeVar);
					}
					return REJECT;
				}
			}
		}
		return null;
	}
	private TypeUpdateResult updateTypeForSsaVar(TypeUpdateInfo updateInfo, SSAVar ssaVar, ArgType candidateType) {
		TypeInfo typeInfo = ssaVar.getTypeInfo();
		ArgType immutableType = ssaVar.getImmutableType();
		if (immutableType != null && !Objects.equals(immutableType, candidateType)) {
			if (Consts.DEBUG_TYPE_INFERENCE) {
				LOG.info("Reject change immutable type {} to {} for {}", immutableType, candidateType, ssaVar);
			}
			return REJECT;
		}
		if (!inBounds(updateInfo, ssaVar, typeInfo.getBounds(), candidateType)) {
			return REJECT;
		}
		TypeUpdateResult result = requestUpdate(updateInfo, ssaVar.getAssign(), candidateType);
		boolean allSame = result == SAME;
		if (result != REJECT) {
			List<RegisterArg> useList = ssaVar.getUseList();
			for (RegisterArg arg : useList) {
				result = requestUpdate(updateInfo, arg, candidateType);
				if (result == REJECT) {
					break;
				}
				if (result != SAME) {
					allSame = false;
				}
			}
		}
		if (result == REJECT) {
			updateInfo.rollbackUpdate(ssaVar.getAssign());
			ssaVar.getUseList().forEach(updateInfo::rollbackUpdate);
			return REJECT;
		}
		return allSame ? SAME : CHANGED;
	}
	private TypeUpdateResult requestUpdate(TypeUpdateInfo updateInfo, InsnArg arg, ArgType candidateType) {
		if (updateInfo.isProcessed(arg)) {
			return CHANGED;
		}
		updateInfo.requestUpdate(arg, candidateType);
		try {
			TypeUpdateResult result = runListeners(updateInfo, arg, candidateType);
			if (result == REJECT) {
				updateInfo.rollbackUpdate(arg);
			}
			return result;
		} catch (StackOverflowError | BootstrapMethodError error) {
			throw new JadxOverflowException("Type update terminated with stack overflow, arg: " + arg
					+ ", method size: " + updateInfo.getMth().getInsnsCount());
		}
	}
	private TypeUpdateResult runListeners(TypeUpdateInfo updateInfo, InsnArg arg, ArgType candidateType) {
		InsnNode insn = arg.getParentInsn();
		if (insn == null) {
			return SAME;
		}
		ITypeListener listener = listenerRegistry.get(insn.getType());
		if (listener == null) {
			return CHANGED;
		}
		return listener.update(updateInfo, insn, arg, candidateType);
	}
	boolean inBounds(Set<ITypeBound> bounds, ArgType candidateType) {
		for (ITypeBound bound : bounds) {
			ArgType boundType = bound.getType();
			if (boundType != null && !checkBound(candidateType, bound, boundType)) {
				return false;
			}
		}
		return true;
	}
	private boolean inBounds(TypeUpdateInfo updateInfo, SSAVar ssaVar, Set<ITypeBound> bounds, ArgType candidateType) {
		for (ITypeBound bound : bounds) {
			ArgType boundType;
			if (updateInfo != null && bound instanceof ITypeBoundDynamic) {
				boundType = ((ITypeBoundDynamic) bound).getType(updateInfo);
			} else {
				boundType = bound.getType();
			}
			if (boundType != null && !checkBound(candidateType, bound, boundType)) {
				if (Consts.DEBUG_TYPE_INFERENCE) {
					LOG.debug("Reject type '{}' for {} by bound: {} from {}", candidateType, ssaVar, boundType, bound);
				}
				return false;
			}
		}
		return true;
	}
	private boolean checkBound(ArgType candidateType, ITypeBound bound, ArgType boundType) {
		TypeCompareEnum compareResult = comparator.compareTypes(candidateType, boundType);
		switch (compareResult) {
			case EQUAL:
				return true;
			case WIDER:
				return bound.getBound() != BoundEnum.USE;
			case NARROW:
				if (bound.getBound() == BoundEnum.ASSIGN) {
					return !boundType.isTypeKnown() && checkAssignForUnknown(boundType, candidateType);
				}
				return true;
			case WIDER_BY_GENERIC:
			case NARROW_BY_GENERIC:
				return true;
			case CONFLICT:
			case CONFLICT_BY_GENERIC:
				return false;
			case UNKNOWN:
				LOG.warn("Can't compare types, unknown hierarchy: {} and {}", candidateType, boundType);
				comparator.compareTypes(candidateType, boundType);
				return true;
			default:
				throw new JadxRuntimeException("Not processed type compare enum: " + compareResult);
		}
	}
	private boolean checkAssignForUnknown(ArgType boundType, ArgType candidateType) {
		if (boundType == ArgType.UNKNOWN) {
			return true;
		}
		boolean candidateArray = candidateType.isArray();
		if (boundType.isArray() && candidateArray) {
			return checkAssignForUnknown(boundType.getArrayElement(), candidateType.getArrayElement());
		}
		if (candidateArray && boundType.contains(PrimitiveType.ARRAY)) {
			return true;
		}
		if (candidateType.isObject() && boundType.contains(PrimitiveType.OBJECT)) {
			return true;
		}
		if (candidateType.isPrimitive() && boundType.contains(candidateType.getPrimitiveType())) {
			return true;
		}
		return false;
	}
	private Map<InsnType, ITypeListener> initListenerRegistry() {
		Map<InsnType, ITypeListener> registry = new EnumMap<>(InsnType.class);
		registry.put(InsnType.CONST, this::sameFirstArgListener);
		registry.put(InsnType.MOVE, this::moveListener);
		registry.put(InsnType.PHI, this::allSameListener);
		registry.put(InsnType.AGET, this::arrayGetListener);
		registry.put(InsnType.APUT, this::arrayPutListener);
		registry.put(InsnType.IF, this::ifListener);
		registry.put(InsnType.ARITH, this::arithListener);
		registry.put(InsnType.NEG, this::suggestAllSameListener);
		registry.put(InsnType.NOT, this::suggestAllSameListener);
		registry.put(InsnType.CHECK_CAST, this::checkCastListener);
		registry.put(InsnType.INVOKE, this::invokeListener);
		registry.put(InsnType.CONSTRUCTOR, this::invokeListener);
		return registry;
	}
	private TypeUpdateResult invokeListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
		BaseInvokeNode invoke = (BaseInvokeNode) insn;
		if (isAssign(invoke, arg)) {
			return SAME;
		}
		if (invoke.getInstanceArg() == arg) {
			IMethodDetails methodDetails = root.getMethodUtils().getMethodDetails(invoke);
			if (methodDetails == null) {
				return SAME;
			}
			TypeUtils typeUtils = root.getTypeUtils();
			Set<ArgType> knownTypeVars = typeUtils.getKnownTypeVarsAtMethod(updateInfo.getMth());
			Map<ArgType, ArgType> typeVarsMap = typeUtils.getTypeVariablesMapping(candidateType);
			ArgType returnType = methodDetails.getReturnType();
			List<ArgType> argTypes = methodDetails.getArgTypes();
			int argsCount = argTypes.size();
			if (typeVarsMap.isEmpty()) {
				return applyInvokeTypes(updateInfo, invoke, argsCount, knownTypeVars, () -> returnType, argTypes::get);
			}
			return applyInvokeTypes(updateInfo, invoke, argsCount, knownTypeVars,
					() -> typeUtils.replaceTypeVariablesUsingMap(returnType, typeVarsMap),
					argNum -> typeUtils.replaceClassGenerics(candidateType, argTypes.get(argNum)));
		}
		return SAME;
	}
	private TypeUpdateResult applyInvokeTypes(TypeUpdateInfo updateInfo, BaseInvokeNode invoke, int argsCount,
			Set<ArgType> knownTypeVars, Supplier<ArgType> getReturnType, Function<Integer, ArgType> getArgType) {
		boolean allSame = true;
		RegisterArg resultArg = invoke.getResult();
		if (resultArg != null && !resultArg.isTypeImmutable()) {
			ArgType returnType = checkType(knownTypeVars, getReturnType.get());
			if (returnType != null) {
				TypeUpdateResult result = updateTypeChecked(updateInfo, resultArg, returnType);
				if (result == REJECT) {
					TypeCompareEnum compare = comparator.compareTypes(returnType, resultArg.getType());
					if (compare.isWider()) {
						return REJECT;
					}
				}
				if (result == CHANGED) {
					allSame = false;
				}
			}
		}
		int argOffset = invoke.getFirstArgOffset();
		for (int i = 0; i < argsCount; i++) {
			InsnArg invokeArg = invoke.getArg(argOffset + i);
			if (!invokeArg.isTypeImmutable()) {
				ArgType argType = checkType(knownTypeVars, getArgType.apply(i));
				if (argType != null) {
					TypeUpdateResult result = updateTypeChecked(updateInfo, invokeArg, argType);
					if (result == REJECT) {
						TypeCompareEnum compare = comparator.compareTypes(argType, invokeArg.getType());
						if (compare.isNarrow()) {
							return REJECT;
						}
					}
					if (result == CHANGED) {
						allSame = false;
					}
				}
			}
		}
		return allSame ? SAME : CHANGED;
	}
	@Nullable
	private ArgType checkType(Set<ArgType> knownTypeVars, @Nullable ArgType type) {
		if (type == null) {
			return null;
		}
		if (type.isWildcard()) {
			return null;
		}
		if (type.containsTypeVariable()) {
			if (knownTypeVars.isEmpty()) {
				return null;
			}
			Boolean hasUnknown = type.visitTypes(t -> t.isGenericType() && !knownTypeVars.contains(t) ? Boolean.TRUE : null);
			if (hasUnknown != null) {
				return null;
			}
		}
		return type;
	}
	private TypeUpdateResult sameFirstArgListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
		InsnArg changeArg = isAssign(insn, arg) ? insn.getArg(0) : insn.getResult();
		if (updateInfo.hasUpdateWithType(changeArg, candidateType)) {
			return CHANGED;
		}
		return updateTypeChecked(updateInfo, changeArg, candidateType);
	}
	private TypeUpdateResult moveListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
		boolean assignChanged = isAssign(insn, arg);
		InsnArg changeArg = assignChanged ? insn.getArg(0) : insn.getResult();
		boolean correctType;
		if (changeArg.getType().isTypeKnown()) {
			TypeCompareEnum cmp = comparator.compareTypes(candidateType, changeArg.getType());
			correctType = cmp.isEqual() || (assignChanged ? cmp.isWider() : cmp.isNarrow());
		} else {
			correctType = true;
		}
		TypeUpdateResult result = updateTypeChecked(updateInfo, changeArg, candidateType);
		if (result == SAME && !correctType) {
			if (Consts.DEBUG_TYPE_INFERENCE) {
				LOG.debug("Move insn types mismatch: {} -> {}, change arg: {}, insn: {}",
						candidateType, changeArg.getType(), changeArg, insn);
			}
			return REJECT;
		}
		if (result == REJECT && correctType) {
			return CHANGED;
		}
		return result;
	}
	private TypeUpdateResult allSameListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
		if (!isAssign(insn, arg)) {
			return updateTypeChecked(updateInfo, insn.getResult(), candidateType);
		}
		boolean allSame = true;
		for (InsnArg insnArg : insn.getArguments()) {
			if (insnArg == arg) {
				continue;
			}
			TypeUpdateResult result = updateTypeChecked(updateInfo, insnArg, candidateType);
			if (result == REJECT) {
				return result;
			}
			if (result != SAME) {
				allSame = false;
			}
		}
		return allSame ? SAME : CHANGED;
	}
	private TypeUpdateResult arithListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
		ArithNode arithInsn = (ArithNode) insn;
		if (candidateType == ArgType.BOOLEAN && arithInsn.getOp().isBitOp()) {
			return allSameListener(updateInfo, insn, arg, candidateType);
		}
		return suggestAllSameListener(updateInfo, insn, arg, candidateType);
	}
	private TypeUpdateResult suggestAllSameListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
		if (!isAssign(insn, arg)) {
			RegisterArg resultArg = insn.getResult();
			if (resultArg != null) {
				updateTypeChecked(updateInfo, resultArg, candidateType);
			}
		}
		boolean allSame = true;
		for (InsnArg insnArg : insn.getArguments()) {
			if (insnArg != arg) {
				TypeUpdateResult result = updateTypeChecked(updateInfo, insnArg, candidateType);
				if (result == REJECT) {
				} else if (result != SAME) {
					allSame = false;
				}
			}
		}
		return allSame ? SAME : CHANGED;
	}
	private TypeUpdateResult checkCastListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
		IndexInsnNode checkCast = (IndexInsnNode) insn;
		if (isAssign(insn, arg)) {
			InsnArg insnArg = insn.getArg(0);
			TypeUpdateResult result = updateTypeChecked(updateInfo, insnArg, candidateType);
			return result == REJECT ? SAME : result;
		}
		ArgType castType = (ArgType) checkCast.getIndex();
		TypeCompareEnum res = comparator.compareTypes(candidateType, castType);
		if (res == TypeCompareEnum.CONFLICT) {
			if (!isInterfaces(candidateType, castType)) {
				return REJECT;
			}
		}
		if (res == TypeCompareEnum.CONFLICT_BY_GENERIC) {
			if (!insn.contains(AFlag.SOFT_CAST)) {
				return REJECT;
			}
		}
		if (res == TypeCompareEnum.NARROW_BY_GENERIC && candidateType.containsGeneric()) {
			return updateTypeChecked(updateInfo, checkCast.getResult(), candidateType);
		}
		ArgType currentType = checkCast.getArg(0).getType();
		return candidateType.equals(currentType) ? SAME : CHANGED;
	}
	private boolean isInterfaces(ArgType firstType, ArgType secondType) {
		if (!firstType.isObject() || !secondType.isObject()) {
			return false;
		}
		ClspClass firstCls = root.getClsp().getClsDetails(firstType);
		ClspClass secondCls = root.getClsp().getClsDetails(secondType);
		if (firstCls != null && !firstCls.isInterface()) {
			return false;
		}
		if (secondCls != null && !secondCls.isInterface()) {
			return false;
		}
		if (firstCls == null || secondCls == null) {
			return true;
		}
		return secondCls.isInterface() && firstCls.isInterface();
	}
	private TypeUpdateResult arrayGetListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
		if (isAssign(insn, arg)) {
			TypeUpdateResult result = updateTypeChecked(updateInfo, insn.getArg(0), ArgType.array(candidateType));
			if (result == REJECT) {
				ArgType arrType = insn.getArg(0).getType();
				if (arrType.isTypeKnown() && arrType.isArray() && arrType.getArrayElement().isPrimitive()) {
					TypeCompareEnum compResult = comparator.compareTypes(candidateType, arrType.getArrayElement());
					if (compResult == TypeCompareEnum.WIDER) {
						return CHANGED;
					}
				}
			}
			return result;
		}
		InsnArg arrArg = insn.getArg(0);
		if (arrArg == arg) {
			ArgType arrayElement = candidateType.getArrayElement();
			if (arrayElement == null) {
				return REJECT;
			}
			TypeUpdateResult result = updateTypeChecked(updateInfo, insn.getResult(), arrayElement);
			if (result == REJECT) {
				ArgType resType = insn.getResult().getType();
				if (resType.isTypeKnown() && resType.isPrimitive()) {
					TypeCompareEnum compResult = comparator.compareTypes(resType, arrayElement);
					if (compResult == TypeCompareEnum.WIDER) {
						return CHANGED;
					}
				}
			}
			return result;
		}
		return SAME;
	}
	private TypeUpdateResult arrayPutListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
		InsnArg arrArg = insn.getArg(0);
		InsnArg putArg = insn.getArg(2);
		if (arrArg == arg) {
			ArgType arrayElement = candidateType.getArrayElement();
			if (arrayElement == null) {
				return REJECT;
			}
			TypeUpdateResult result = updateTypeChecked(updateInfo, putArg, arrayElement);
			if (result == REJECT) {
				ArgType putType = putArg.getType();
				if (putType.isTypeKnown()) {
					TypeCompareEnum compResult = comparator.compareTypes(arrayElement, putType);
					if (compResult == TypeCompareEnum.WIDER || compResult == TypeCompareEnum.WIDER_BY_GENERIC) {
						return CHANGED;
					}
				}
			}
			return result;
		}
		if (arrArg == putArg) {
			return updateTypeChecked(updateInfo, arrArg, ArgType.array(candidateType));
		}
		return SAME;
	}
	private TypeUpdateResult ifListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
		InsnArg firstArg = insn.getArg(0);
		InsnArg secondArg = insn.getArg(1);
		InsnArg updateArg = firstArg == arg ? secondArg : firstArg;
		TypeUpdateResult result = updateTypeChecked(updateInfo, updateArg, candidateType);
		if (result == REJECT) {
			ArgType updateArgType = updateArg.getType();
			if (candidateType.isObject() && updateArgType.canBeObject()) {
				return SAME;
			}
			if (candidateType.isArray() && updateArgType.canBeArray()) {
				return SAME;
			}
			if (candidateType.isPrimitive()) {
				if (updateArgType.canBePrimitive(candidateType.getPrimitiveType())) {
					return SAME;
				}
				if (updateArgType.isTypeKnown() && candidateType.getRegCount() == updateArgType.getRegCount()) {
					return SAME;
				}
			}
		}
		return result;
	}
	private static boolean isAssign(InsnNode insn, InsnArg arg) {
		return insn.getResult() == arg;
	}
	public TypeCompare getTypeCompare() {
		return comparator;
	}
}
_______
package jadx.api.impl.passes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.api.plugins.pass.JadxPass;
import jadx.api.plugins.pass.types.JadxDecompilePass;
import jadx.core.dex.nodes.ClassNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.nodes.RootNode;
import jadx.core.dex.visitors.AbstractVisitor;
import jadx.core.utils.exceptions.JadxException;
public class DecompilePassWrapper extends AbstractVisitor implements IPassWrapperVisitor {
	private static final Logger LOG = LoggerFactory.getLogger(DecompilePassWrapper.class);
	private final JadxDecompilePass decompilePass;
	public DecompilePassWrapper(JadxDecompilePass decompilePass) {
		this.decompilePass = decompilePass;
	}
	@Override
	public JadxPass getPass() {
		return decompilePass;
	}
	@Override
	public void init(RootNode root) throws JadxException {
		try {
			decompilePass.init(root);
		} catch (Throwable e) {
			LOG.error("Error in decompile pass init: {}", this, e);
		}
	}
	@Override
	public boolean visit(ClassNode cls) throws JadxException {
		try {
			return decompilePass.visit(cls);
		} catch (Throwable e) {
			LOG.error("Error in decompile pass: {}, class: {}", this, cls, e);
			return false;
		}
	}
	@Override
	public void visit(MethodNode mth) throws JadxException {
		try {
			decompilePass.visit(mth);
		} catch (Throwable e) {
			LOG.error("Error in decompile pass: {}, method: {}", this, mth, e);
		}
	}
	@Override
	public String getName() {
		return decompilePass.getInfo().getName();
	}
}
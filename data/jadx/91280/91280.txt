SEVERITY = 5

package jadx.core;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.Manifest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.api.CommentsLevel;
import jadx.api.JadxArgs;
import jadx.core.deobf.DeobfuscatorVisitor;
import jadx.core.deobf.SaveDeobfMapping;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.visitors.AnonymousClassVisitor;
import jadx.core.dex.visitors.AttachCommentsVisitor;
import jadx.core.dex.visitors.AttachMethodDetails;
import jadx.core.dex.visitors.AttachTryCatchVisitor;
import jadx.core.dex.visitors.CheckCode;
import jadx.core.dex.visitors.ClassModifier;
import jadx.core.dex.visitors.ConstInlineVisitor;
import jadx.core.dex.visitors.ConstructorVisitor;
import jadx.core.dex.visitors.DeboxingVisitor;
import jadx.core.dex.visitors.DotGraphVisitor;
import jadx.core.dex.visitors.EnumVisitor;
import jadx.core.dex.visitors.ExtractFieldInit;
import jadx.core.dex.visitors.FallbackModeVisitor;
import jadx.core.dex.visitors.FixSwitchOverEnum;
import jadx.core.dex.visitors.GenericTypesVisitor;
import jadx.core.dex.visitors.IDexTreeVisitor;
import jadx.core.dex.visitors.InitCodeVariables;
import jadx.core.dex.visitors.InlineMethods;
import jadx.core.dex.visitors.MarkMethodsForInline;
import jadx.core.dex.visitors.MethodInvokeVisitor;
import jadx.core.dex.visitors.MethodVisitor;
import jadx.core.dex.visitors.ModVisitor;
import jadx.core.dex.visitors.MoveInlineVisitor;
import jadx.core.dex.visitors.OverrideMethodVisitor;
import jadx.core.dex.visitors.PrepareForCodeGen;
import jadx.core.dex.visitors.ProcessAnonymous;
import jadx.core.dex.visitors.ProcessInstructionsVisitor;
import jadx.core.dex.visitors.ProcessMethodsForInline;
import jadx.core.dex.visitors.ReplaceNewArray;
import jadx.core.dex.visitors.ShadowFieldVisitor;
import jadx.core.dex.visitors.SignatureProcessor;
import jadx.core.dex.visitors.SimplifyVisitor;
import jadx.core.dex.visitors.blocks.BlockFinisher;
import jadx.core.dex.visitors.blocks.BlockProcessor;
import jadx.core.dex.visitors.blocks.BlockSplitter;
import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;
import jadx.core.dex.visitors.debuginfo.DebugInfoAttachVisitor;
import jadx.core.dex.visitors.finaly.MarkFinallyVisitor;
import jadx.core.dex.visitors.fixaccessmodifiers.FixAccessModifiers;
import jadx.core.dex.visitors.gradle.NonFinalResIdsVisitor;
import jadx.core.dex.visitors.kotlin.ProcessKotlinInternals;
import jadx.core.dex.visitors.prepare.AddAndroidConstants;
import jadx.core.dex.visitors.prepare.CollectConstValues;
import jadx.core.dex.visitors.regions.CheckRegions;
import jadx.core.dex.visitors.regions.CleanRegions;
import jadx.core.dex.visitors.regions.IfRegionVisitor;
import jadx.core.dex.visitors.regions.LoopRegionVisitor;
import jadx.core.dex.visitors.regions.RegionMakerVisitor;
import jadx.core.dex.visitors.regions.ReturnVisitor;
import jadx.core.dex.visitors.regions.SwitchOverStringVisitor;
import jadx.core.dex.visitors.regions.variables.ProcessVariables;
import jadx.core.dex.visitors.rename.CodeRenameVisitor;
import jadx.core.dex.visitors.rename.RenameVisitor;
import jadx.core.dex.visitors.rename.SourceFileRename;
import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;
import jadx.core.dex.visitors.ssa.SSATransform;
import jadx.core.dex.visitors.typeinference.FinishTypeInference;
import jadx.core.dex.visitors.typeinference.FixTypesVisitor;
import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;
import jadx.core.dex.visitors.usage.UsageInfoVisitor;
import jadx.core.utils.exceptions.JadxRuntimeException;
public class Jadx {
	private static final Logger LOG = LoggerFactory.getLogger(Jadx.class);
	private Jadx() {
	}
	public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
		switch (args.getDecompilationMode()) {
			case AUTO:
			case RESTRUCTURE:
				return getRegionsModePasses(args);
			case SIMPLE:
				return getSimpleModePasses(args);
			case FALLBACK:
				return getFallbackPassesList();
			default:
				throw new JadxRuntimeException("Unknown decompilation mode: " + args.getDecompilationMode());
		}
	}
	public static List<IDexTreeVisitor> getPreDecompilePassesList() {
		List<IDexTreeVisitor> passes = new ArrayList<>();
		passes.add(new SignatureProcessor());
		passes.add(new OverrideMethodVisitor());
		passes.add(new AddAndroidConstants());
		passes.add(new CollectConstValues());
		passes.add(new DeobfuscatorVisitor());
		passes.add(new SourceFileRename());
		passes.add(new RenameVisitor());
		passes.add(new SaveDeobfMapping());
		passes.add(new UsageInfoVisitor());
		passes.add(new ProcessAnonymous());
		passes.add(new ProcessMethodsForInline());
		return passes;
	}
	public static List<IDexTreeVisitor> getRegionsModePasses(JadxArgs args) {
		List<IDexTreeVisitor> passes = new ArrayList<>();
		passes.add(new CheckCode());
		if (args.isDebugInfo()) {
			passes.add(new DebugInfoAttachVisitor());
		}
		passes.add(new AttachTryCatchVisitor());
		if (args.getCommentsLevel() != CommentsLevel.NONE) {
			passes.add(new AttachCommentsVisitor());
		}
		passes.add(new AttachMethodDetails());
		passes.add(new ProcessInstructionsVisitor());
		passes.add(new BlockSplitter());
		passes.add(new BlockProcessor());
		passes.add(new BlockFinisher());
		if (args.isRawCFGOutput()) {
			passes.add(DotGraphVisitor.dumpRaw());
		}
		passes.add(new SSATransform());
		passes.add(new MoveInlineVisitor());
		passes.add(new ConstructorVisitor());
		passes.add(new InitCodeVariables());
		if (args.isExtractFinally()) {
			passes.add(new MarkFinallyVisitor());
		}
		passes.add(new ConstInlineVisitor());
		passes.add(new TypeInferenceVisitor());
		if (args.isDebugInfo()) {
			passes.add(new DebugInfoApplyVisitor());
		}
		passes.add(new FixTypesVisitor());
		passes.add(new FinishTypeInference());
		if (args.getUseKotlinMethodsForVarNames() != JadxArgs.UseKotlinMethodsForVarNames.DISABLE) {
			passes.add(new ProcessKotlinInternals());
		}
		passes.add(new CodeRenameVisitor());
		if (args.isInlineMethods()) {
			passes.add(new InlineMethods());
		}
		passes.add(new GenericTypesVisitor());
		passes.add(new ShadowFieldVisitor());
		passes.add(new DeboxingVisitor());
		passes.add(new AnonymousClassVisitor());
		passes.add(new ModVisitor());
		passes.add(new CodeShrinkVisitor());
		passes.add(new ReplaceNewArray());
		if (args.isCfgOutput()) {
			passes.add(DotGraphVisitor.dump());
		}
		passes.add(new RegionMakerVisitor());
		passes.add(new IfRegionVisitor());
		if (args.isRestoreSwitchOverString()) {
			passes.add(new SwitchOverStringVisitor());
		}
		passes.add(new ReturnVisitor());
		passes.add(new CleanRegions());
		passes.add(new CodeShrinkVisitor());
		passes.add(new MethodInvokeVisitor());
		passes.add(new SimplifyVisitor());
		passes.add(new CheckRegions());
		passes.add(new EnumVisitor());
		passes.add(new FixSwitchOverEnum());
		passes.add(new NonFinalResIdsVisitor());
		passes.add(new ExtractFieldInit());
		passes.add(new FixAccessModifiers());
		passes.add(new ClassModifier());
		passes.add(new LoopRegionVisitor());
		if (args.isInlineMethods()) {
			passes.add(new MarkMethodsForInline());
		}
		passes.add(new ProcessVariables());
		passes.add(new PrepareForCodeGen());
		if (args.isCfgOutput()) {
			passes.add(DotGraphVisitor.dumpRegions());
		}
		return passes;
	}
	public static List<IDexTreeVisitor> getSimpleModePasses(JadxArgs args) {
		List<IDexTreeVisitor> passes = new ArrayList<>();
		if (args.isDebugInfo()) {
			passes.add(new DebugInfoAttachVisitor());
		}
		passes.add(new AttachTryCatchVisitor());
		if (args.getCommentsLevel() != CommentsLevel.NONE) {
			passes.add(new AttachCommentsVisitor());
		}
		passes.add(new AttachMethodDetails());
		passes.add(new ProcessInstructionsVisitor());
		passes.add(new BlockSplitter());
		if (args.isRawCFGOutput()) {
			passes.add(DotGraphVisitor.dumpRaw());
		}
		passes.add(new MethodVisitor("DisableBlockLock", mth -> mth.add(AFlag.DISABLE_BLOCKS_LOCK)));
		passes.add(new BlockProcessor());
		passes.add(new SSATransform());
		passes.add(new MoveInlineVisitor());
		passes.add(new ConstructorVisitor());
		passes.add(new InitCodeVariables());
		passes.add(new ConstInlineVisitor());
		passes.add(new TypeInferenceVisitor());
		if (args.isDebugInfo()) {
			passes.add(new DebugInfoApplyVisitor());
		}
		passes.add(new FixTypesVisitor());
		passes.add(new FinishTypeInference());
		passes.add(new CodeRenameVisitor());
		passes.add(new DeboxingVisitor());
		passes.add(new ModVisitor());
		passes.add(new CodeShrinkVisitor());
		passes.add(new ReplaceNewArray());
		passes.add(new SimplifyVisitor());
		passes.add(new MethodVisitor("ForceGenerateAll", mth -> mth.remove(AFlag.DONT_GENERATE)));
		if (args.isCfgOutput()) {
			passes.add(DotGraphVisitor.dump());
		}
		return passes;
	}
	public static List<IDexTreeVisitor> getFallbackPassesList() {
		List<IDexTreeVisitor> passes = new ArrayList<>();
		passes.add(new AttachTryCatchVisitor());
		passes.add(new AttachCommentsVisitor());
		passes.add(new ProcessInstructionsVisitor());
		passes.add(new FallbackModeVisitor());
		return passes;
	}
	public static final String VERSION_DEV = "dev";
	private static String version;
	public static String getVersion() {
		if (version == null) {
			version = searchJadxVersion();
		}
		return version;
	}
	public static boolean isDevVersion() {
		return getVersion().equals(VERSION_DEV);
	}
	private static String searchJadxVersion() {
		try {
			ClassLoader classLoader = Jadx.class.getClassLoader();
			if (classLoader != null) {
				Enumeration<URL> resources = classLoader.getResources("META-INF/MANIFEST.MF");
				while (resources.hasMoreElements()) {
					try (InputStream is = resources.nextElement().openStream()) {
						Manifest manifest = new Manifest(is);
						String ver = manifest.getMainAttributes().getValue("jadx-version");
						if (ver != null) {
							return ver;
						}
					}
				}
			}
		} catch (Exception e) {
			LOG.error("Can't get manifest file", e);
		}
		return VERSION_DEV;
	}
}
______
package jadx.core.dex.visitors;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Collectors;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import jadx.core.clsp.ClspClass;
import jadx.core.clsp.ClspMethod;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.attributes.AType;
import jadx.core.dex.attributes.nodes.MethodBridgeAttr;
import jadx.core.dex.attributes.nodes.MethodOverrideAttr;
import jadx.core.dex.attributes.nodes.RenameReasonAttr;
import jadx.core.dex.info.AccessInfo;
import jadx.core.dex.info.MethodInfo;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.nodes.ClassNode;
import jadx.core.dex.nodes.IMethodDetails;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.nodes.RootNode;
import jadx.core.dex.visitors.rename.RenameVisitor;
import jadx.core.dex.visitors.typeinference.TypeCompare;
import jadx.core.dex.visitors.typeinference.TypeCompareEnum;
import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;
import jadx.core.utils.Utils;
import jadx.core.utils.exceptions.JadxException;
import jadx.core.utils.exceptions.JadxRuntimeException;
@JadxVisitor(
		name = "OverrideMethodVisitor",
		desc = "Mark override methods and revert type erasure",
		runBefore = {
				TypeInferenceVisitor.class,
				RenameVisitor.class
		}
)
public class OverrideMethodVisitor extends AbstractVisitor {
	@Override
	public boolean visit(ClassNode cls) throws JadxException {
		SuperTypesData superData = collectSuperTypes(cls);
		if (superData != null) {
			for (MethodNode mth : cls.getMethods()) {
				processMth(mth, superData);
			}
		}
		return true;
	}
	private void processMth(MethodNode mth, SuperTypesData superData) {
		if (mth.isConstructor() || mth.getAccessFlags().isStatic() || mth.getAccessFlags().isPrivate()) {
			return;
		}
		MethodOverrideAttr attr = processOverrideMethods(mth, superData);
		if (attr != null) {
			if (attr.getBaseMethods().isEmpty()) {
				throw new JadxRuntimeException("No base methods for override attribute: " + attr.getOverrideList());
			}
			mth.addAttr(attr);
			IMethodDetails baseMth = Utils.getOne(attr.getBaseMethods());
			if (baseMth != null) {
				boolean updated = fixMethodReturnType(mth, baseMth, superData);
				updated |= fixMethodArgTypes(mth, baseMth, superData);
				if (updated) {
					checkMethodSignatureCollisions(mth, mth.root().getArgs().isRenameValid());
				}
			}
		}
	}
	private MethodOverrideAttr processOverrideMethods(MethodNode mth, SuperTypesData superData) {
		MethodOverrideAttr result = mth.get(AType.METHOD_OVERRIDE);
		if (result != null) {
			return result;
		}
		ClassNode cls = mth.getParentClass();
		String signature = mth.getMethodInfo().makeSignature(false);
		List<IMethodDetails> overrideList = new ArrayList<>();
		Set<IMethodDetails> baseMethods = new HashSet<>();
		for (ArgType superType : superData.getSuperTypes()) {
			ClassNode classNode = mth.root().resolveClass(superType);
			if (classNode != null) {
				MethodNode ovrdMth = searchOverriddenMethod(classNode, mth, signature);
				if (ovrdMth != null) {
					if (isMethodVisibleInCls(ovrdMth, cls)) {
						overrideList.add(ovrdMth);
						MethodOverrideAttr attr = ovrdMth.get(AType.METHOD_OVERRIDE);
						if (attr != null) {
							addBaseMethod(superData, overrideList, baseMethods, superType);
							return buildOverrideAttr(mth, overrideList, baseMethods, attr);
						}
					}
				}
			} else {
				ClspClass clsDetails = mth.root().getClsp().getClsDetails(superType);
				if (clsDetails != null) {
					Map<String, ClspMethod> methodsMap = clsDetails.getMethodsMap();
					for (Map.Entry<String, ClspMethod> entry : methodsMap.entrySet()) {
						String mthShortId = entry.getKey();
						if (mthShortId.startsWith(signature)) {
							overrideList.add(entry.getValue());
							break;
						}
					}
				}
			}
			addBaseMethod(superData, overrideList, baseMethods, superType);
		}
		return buildOverrideAttr(mth, overrideList, baseMethods, null);
	}
	private void addBaseMethod(SuperTypesData superData, List<IMethodDetails> overrideList, Set<IMethodDetails> baseMethods,
			ArgType superType) {
		if (superData.getEndTypes().contains(superType.getObject())) {
			IMethodDetails last = Utils.last(overrideList);
			if (last != null) {
				baseMethods.add(last);
			}
		}
	}
	@Nullable
	private MethodNode searchOverriddenMethod(ClassNode cls, MethodNode mth, String signature) {
		String shortId = mth.getMethodInfo().getShortId();
		for (MethodNode supMth : cls.getMethods()) {
			if (supMth.getMethodInfo().getShortId().equals(shortId) && !supMth.getAccessFlags().isStatic()) {
				return supMth;
			}
		}
		for (MethodNode supMth : cls.getMethods()) {
			if (supMth.getMethodInfo().getShortId().startsWith(signature) && !supMth.getAccessFlags().isStatic()) {
				TypeCompare typeCompare = cls.root().getTypeCompare();
				ArgType supRetType = supMth.getMethodInfo().getReturnType();
				ArgType mthRetType = mth.getMethodInfo().getReturnType();
				TypeCompareEnum res = typeCompare.compareTypes(supRetType, mthRetType);
				if (res.isWider()) {
					return supMth;
				}
				if (res == TypeCompareEnum.UNKNOWN || res == TypeCompareEnum.CONFLICT) {
					mth.addDebugComment("Possible override for method " + supMth.getMethodInfo().getFullId());
				}
			}
		}
		return null;
	}
	@Nullable
	private MethodOverrideAttr buildOverrideAttr(MethodNode mth, List<IMethodDetails> overrideList,
			Set<IMethodDetails> baseMethods, @Nullable MethodOverrideAttr attr) {
		if (overrideList.isEmpty() && attr == null) {
			return null;
		}
		if (attr == null) {
			List<IMethodDetails> cleanOverrideList = overrideList.stream().distinct().collect(Collectors.toList());
			return applyOverrideAttr(mth, cleanOverrideList, baseMethods, false);
		}
		List<IMethodDetails> mergedOverrideList = Utils.mergeLists(overrideList, attr.getOverrideList());
		List<IMethodDetails> cleanOverrideList = mergedOverrideList.stream().distinct().collect(Collectors.toList());
		Set<IMethodDetails> mergedBaseMethods = Utils.mergeSets(baseMethods, attr.getBaseMethods());
		return applyOverrideAttr(mth, cleanOverrideList, mergedBaseMethods, true);
	}
	private MethodOverrideAttr applyOverrideAttr(MethodNode mth, List<IMethodDetails> overrideList,
			Set<IMethodDetails> baseMethods, boolean update) {
		boolean dontRename = overrideList.stream().anyMatch(m -> !(m instanceof MethodNode));
		SortedSet<MethodNode> relatedMethods = null;
		List<MethodNode> mthNodes = getMethodNodes(mth, overrideList);
		if (update) {
			for (MethodNode mthNode : mthNodes) {
				MethodOverrideAttr ovrdAttr = mthNode.get(AType.METHOD_OVERRIDE);
				if (ovrdAttr != null) {
					relatedMethods = ovrdAttr.getRelatedMthNodes();
					break;
				}
			}
			if (relatedMethods != null) {
				relatedMethods.addAll(mthNodes);
			} else {
				relatedMethods = new TreeSet<>(mthNodes);
			}
			for (MethodNode mthNode : mthNodes) {
				MethodOverrideAttr ovrdAttr = mthNode.get(AType.METHOD_OVERRIDE);
				if (ovrdAttr != null) {
					SortedSet<MethodNode> set = ovrdAttr.getRelatedMthNodes();
					if (relatedMethods != set) {
						relatedMethods.addAll(set);
					}
				}
			}
		} else {
			relatedMethods = new TreeSet<>(mthNodes);
		}
		int depth = 0;
		for (MethodNode mthNode : mthNodes) {
			if (dontRename) {
				mthNode.add(AFlag.DONT_RENAME);
			}
			if (depth == 0) {
				depth = 1;
				continue;
			}
			if (update) {
				MethodOverrideAttr ovrdAttr = mthNode.get(AType.METHOD_OVERRIDE);
				if (ovrdAttr != null) {
					ovrdAttr.setRelatedMthNodes(relatedMethods);
					continue;
				}
			}
			mthNode.addAttr(new MethodOverrideAttr(Utils.listTail(overrideList, depth), relatedMethods, baseMethods));
			depth++;
		}
		return new MethodOverrideAttr(overrideList, relatedMethods, baseMethods);
	}
	@NotNull
	private List<MethodNode> getMethodNodes(MethodNode mth, List<IMethodDetails> overrideList) {
		List<MethodNode> list = new ArrayList<>(1 + overrideList.size());
		list.add(mth);
		for (IMethodDetails md : overrideList) {
			if (md instanceof MethodNode) {
				list.add((MethodNode) md);
			}
		}
		return list;
	}
	private boolean isMethodVisibleInCls(MethodNode superMth, ClassNode cls) {
		AccessInfo accessFlags = superMth.getAccessFlags();
		if (accessFlags.isPrivate()) {
			return false;
		}
		if (accessFlags.isPublic() || accessFlags.isProtected()) {
			return true;
		}
		return Objects.equals(superMth.getParentClass().getPackage(), cls.getPackage());
	}
	private static final class SuperTypesData {
		private final List<ArgType> superTypes;
		private final Set<String> endTypes;
		private SuperTypesData(List<ArgType> superTypes, Set<String> endTypes) {
			this.superTypes = superTypes;
			this.endTypes = endTypes;
		}
		public List<ArgType> getSuperTypes() {
			return superTypes;
		}
		public Set<String> getEndTypes() {
			return endTypes;
		}
	}
	@Nullable
	private SuperTypesData collectSuperTypes(ClassNode cls) {
		Set<ArgType> superTypes = new LinkedHashSet<>();
		Set<String> endTypes = new HashSet<>();
		collectSuperTypes(cls, superTypes, endTypes);
		if (superTypes.isEmpty()) {
			return null;
		}
		if (endTypes.isEmpty()) {
			throw new JadxRuntimeException("No end types in class hierarchy: " + cls);
		}
		return new SuperTypesData(new ArrayList<>(superTypes), endTypes);
	}
	private void collectSuperTypes(ClassNode cls, Set<ArgType> superTypes, Set<String> endTypes) {
		RootNode root = cls.root();
		int k = 0;
		ArgType superClass = cls.getSuperClass();
		if (superClass != null) {
			k += addSuperType(root, superTypes, endTypes, superClass);
		}
		for (ArgType iface : cls.getInterfaces()) {
			k += addSuperType(root, superTypes, endTypes, iface);
		}
		if (k == 0) {
			endTypes.add(cls.getType().getObject());
		}
	}
	private int addSuperType(RootNode root, Set<ArgType> superTypes, Set<String> endTypes, ArgType superType) {
		if (Objects.equals(superType, ArgType.OBJECT)) {
			return 0;
		}
		if (!superTypes.add(superType)) {
			return 0;
		}
		ClassNode classNode = root.resolveClass(superType);
		if (classNode != null) {
			collectSuperTypes(classNode, superTypes, endTypes);
			return 1;
		}
		ClspClass clsDetails = root.getClsp().getClsDetails(superType);
		if (clsDetails != null) {
			int k = 0;
			for (ArgType parentType : clsDetails.getParents()) {
				k += addSuperType(root, superTypes, endTypes, parentType);
			}
			if (k == 0) {
				endTypes.add(superType.getObject());
			}
			return 1;
		}
		endTypes.add(superType.getObject());
		return 1;
	}
	private boolean fixMethodReturnType(MethodNode mth, IMethodDetails baseMth, SuperTypesData superData) {
		ArgType returnType = mth.getReturnType();
		if (returnType == ArgType.VOID) {
			return false;
		}
		boolean updated = updateReturnType(mth, baseMth, superData);
		if (updated) {
			mth.addDebugComment("Return type fixed from '" + returnType + "' to match base method");
		}
		return updated;
	}
	private boolean updateReturnType(MethodNode mth, IMethodDetails baseMth, SuperTypesData superData) {
		ArgType baseReturnType = baseMth.getReturnType();
		if (mth.getReturnType().equals(baseReturnType)) {
			return false;
		}
		if (!baseReturnType.containsTypeVariable()) {
			return false;
		}
		TypeCompare typeCompare = mth.root().getTypeUpdate().getTypeCompare();
		ArgType baseCls = baseMth.getMethodInfo().getDeclClass().getType();
		for (ArgType superType : superData.getSuperTypes()) {
			TypeCompareEnum compareResult = typeCompare.compareTypes(superType, baseCls);
			if (compareResult == TypeCompareEnum.NARROW_BY_GENERIC) {
				ArgType targetRetType = mth.root().getTypeUtils().replaceClassGenerics(superType, baseReturnType);
				if (targetRetType != null
						&& !targetRetType.containsTypeVariable()
						&& !targetRetType.equals(mth.getReturnType())) {
					mth.updateReturnType(targetRetType);
					return true;
				}
			}
		}
		return false;
	}
	private boolean fixMethodArgTypes(MethodNode mth, IMethodDetails baseMth, SuperTypesData superData) {
		List<ArgType> mthArgTypes = mth.getArgTypes();
		List<ArgType> baseArgTypes = baseMth.getArgTypes();
		if (mthArgTypes.equals(baseArgTypes)) {
			return false;
		}
		int argCount = mthArgTypes.size();
		if (argCount != baseArgTypes.size()) {
			return false;
		}
		boolean changed = false;
		List<ArgType> newArgTypes = new ArrayList<>(argCount);
		for (int argNum = 0; argNum < argCount; argNum++) {
			ArgType newType = updateArgType(mth, baseMth, superData, argNum);
			if (newType != null) {
				changed = true;
				newArgTypes.add(newType);
			} else {
				newArgTypes.add(mthArgTypes.get(argNum));
			}
		}
		if (changed) {
			mth.updateArgTypes(newArgTypes, "Method arguments types fixed to match base method");
		}
		return changed;
	}
	private ArgType updateArgType(MethodNode mth, IMethodDetails baseMth, SuperTypesData superData, int argNum) {
		ArgType arg = mth.getArgTypes().get(argNum);
		ArgType baseArg = baseMth.getArgTypes().get(argNum);
		if (arg.equals(baseArg)) {
			return null;
		}
		if (!baseArg.containsTypeVariable()) {
			return null;
		}
		TypeCompare typeCompare = mth.root().getTypeUpdate().getTypeCompare();
		ArgType baseCls = baseMth.getMethodInfo().getDeclClass().getType();
		for (ArgType superType : superData.getSuperTypes()) {
			TypeCompareEnum compareResult = typeCompare.compareTypes(superType, baseCls);
			if (compareResult == TypeCompareEnum.NARROW_BY_GENERIC) {
				ArgType targetArgType = mth.root().getTypeUtils().replaceClassGenerics(superType, baseArg);
				if (targetArgType != null
						&& !targetArgType.containsTypeVariable()
						&& !targetArgType.equals(arg)) {
					return targetArgType;
				}
			}
		}
		return null;
	}
	private void checkMethodSignatureCollisions(MethodNode mth, boolean rename) {
		String mthName = mth.getMethodInfo().getAlias();
		String newSignature = MethodInfo.makeShortId(mthName, mth.getArgTypes(), null);
		for (MethodNode otherMth : mth.getParentClass().getMethods()) {
			String otherMthName = otherMth.getAlias();
			if (otherMthName.equals(mthName) && otherMth != mth) {
				String otherSignature = otherMth.getMethodInfo().makeSignature(true, false);
				if (otherSignature.equals(newSignature)) {
					if (rename) {
						if (otherMth.contains(AFlag.DONT_RENAME) || otherMth.contains(AType.METHOD_OVERRIDE)) {
							otherMth.addWarnComment("Can't rename method to resolve collision");
						} else {
							otherMth.getMethodInfo().setAlias(makeNewAlias(otherMth));
							otherMth.addAttr(new RenameReasonAttr("avoid collision after fix types in other method"));
						}
					}
					otherMth.addAttr(new MethodBridgeAttr(mth));
					return;
				}
			}
		}
	}
	private static String makeNewAlias(MethodNode mth) {
		ClassNode cls = mth.getParentClass();
		String baseName = mth.getAlias();
		int k = 2;
		while (true) {
			String alias = baseName + k;
			MethodNode methodNode = cls.searchMethodByShortName(alias);
			if (methodNode == null) {
				return alias;
			}
			k++;
		}
	}
	@Override
	public String getName() {
		return "OverrideMethodVisitor";
	}
}
______
package jadx.core.dex.visitors.typeinference;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.core.Consts;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.attributes.AType;
import jadx.core.dex.attributes.nodes.AnonymousClassAttr;
import jadx.core.dex.info.ClassInfo;
import jadx.core.dex.instructions.BaseInvokeNode;
import jadx.core.dex.instructions.IndexInsnNode;
import jadx.core.dex.instructions.InsnType;
import jadx.core.dex.instructions.InvokeNode;
import jadx.core.dex.instructions.InvokeType;
import jadx.core.dex.instructions.PhiInsn;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.instructions.args.InsnArg;
import jadx.core.dex.instructions.args.LiteralArg;
import jadx.core.dex.instructions.args.RegisterArg;
import jadx.core.dex.instructions.args.SSAVar;
import jadx.core.dex.instructions.mods.ConstructorInsn;
import jadx.core.dex.nodes.ClassNode;
import jadx.core.dex.nodes.IMethodDetails;
import jadx.core.dex.nodes.InsnNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.nodes.RootNode;
import jadx.core.dex.nodes.utils.MethodUtils;
import jadx.core.dex.trycatch.ExcHandlerAttr;
import jadx.core.dex.visitors.AbstractVisitor;
import jadx.core.dex.visitors.AttachMethodDetails;
import jadx.core.dex.visitors.ConstInlineVisitor;
import jadx.core.dex.visitors.JadxVisitor;
import jadx.core.dex.visitors.ssa.SSATransform;
import jadx.core.utils.exceptions.JadxOverflowException;
@JadxVisitor(
		name = "Type Inference",
		desc = "Calculate best types for SSA variables",
		runAfter = {
				SSATransform.class,
				ConstInlineVisitor.class,
				AttachMethodDetails.class
		}
)
public final class TypeInferenceVisitor extends AbstractVisitor {
	private static final Logger LOG = LoggerFactory.getLogger(TypeInferenceVisitor.class);
	private RootNode root;
	private TypeUpdate typeUpdate;
	@Override
	public void init(RootNode root) {
		this.root = root;
		this.typeUpdate = root.getTypeUpdate();
	}
	@Override
	public void visit(MethodNode mth) {
		if (mth.isNoCode()) {
			return;
		}
		if (Consts.DEBUG_TYPE_INFERENCE) {
			LOG.info("Start type inference in method: {}", mth);
		}
		try {
			assignImmutableTypes(mth);
			initTypeBounds(mth);
			runTypePropagation(mth);
		} catch (Exception e) {
			mth.addError("Type inference failed", e);
		}
	}
	void initTypeBounds(MethodNode mth) {
		List<SSAVar> ssaVars = mth.getSVars();
		ssaVars.forEach(this::attachBounds);
		ssaVars.forEach(this::mergePhiBounds);
		if (Consts.DEBUG_TYPE_INFERENCE) {
			ssaVars.stream().sorted()
					.forEach(ssaVar -> LOG.debug("Type bounds for {}: {}", ssaVar.toShortString(), ssaVar.getTypeInfo().getBounds()));
		}
	}
	boolean runTypePropagation(MethodNode mth) {
		List<SSAVar> ssaVars = mth.getSVars();
		ssaVars.forEach(var -> setImmutableType(mth, var));
		ssaVars.forEach(var -> setBestType(mth, var));
		return true;
	}
	private void setImmutableType(MethodNode mth, SSAVar ssaVar) {
		try {
			ArgType immutableType = ssaVar.getImmutableType();
			if (immutableType != null) {
				TypeUpdateResult result = typeUpdate.applyWithWiderIgnSame(mth, ssaVar, immutableType);
				if (Consts.DEBUG_TYPE_INFERENCE && result == TypeUpdateResult.REJECT) {
					LOG.info("Reject initial immutable type {} for {}", immutableType, ssaVar);
				}
			}
		} catch (JadxOverflowException e) {
			throw e;
		} catch (Exception e) {
			mth.addWarnComment("Failed to set immutable type for var: " + ssaVar, e);
		}
	}
	private void setBestType(MethodNode mth, SSAVar ssaVar) {
		try {
			calculateFromBounds(mth, ssaVar);
		} catch (JadxOverflowException e) {
			throw e;
		} catch (Exception e) {
			mth.addWarnComment("Failed to calculate best type for var: " + ssaVar, e);
		}
	}
	private void calculateFromBounds(MethodNode mth, SSAVar ssaVar) {
		TypeInfo typeInfo = ssaVar.getTypeInfo();
		Set<ITypeBound> bounds = typeInfo.getBounds();
		Optional<ArgType> bestTypeOpt = selectBestTypeFromBounds(bounds);
		if (bestTypeOpt.isEmpty()) {
			if (Consts.DEBUG_TYPE_INFERENCE) {
				LOG.warn("Failed to select best type from bounds, count={} : ", bounds.size());
				for (ITypeBound bound : bounds) {
					LOG.warn("  {}", bound);
				}
			}
			return;
		}
		ArgType candidateType = bestTypeOpt.get();
		TypeUpdateResult result = typeUpdate.apply(mth, ssaVar, candidateType);
		if (Consts.DEBUG_TYPE_INFERENCE && result == TypeUpdateResult.REJECT) {
			if (ssaVar.getTypeInfo().getType().equals(candidateType)) {
				LOG.info("Same type rejected: {} -> {}, bounds: {}", ssaVar, candidateType, bounds);
			} else if (candidateType.isTypeKnown()) {
				LOG.debug("Type rejected: {} -> {}, bounds: {}", ssaVar, candidateType, bounds);
			}
		}
	}
	private Optional<ArgType> selectBestTypeFromBounds(Set<ITypeBound> bounds) {
		return bounds.stream()
				.map(ITypeBound::getType)
				.filter(Objects::nonNull)
				.max(typeUpdate.getTypeCompare().getComparator());
	}
	private void attachBounds(SSAVar var) {
		TypeInfo typeInfo = var.getTypeInfo();
		typeInfo.getBounds().clear();
		RegisterArg assign = var.getAssign();
		addAssignBound(typeInfo, assign);
		for (RegisterArg regArg : var.getUseList()) {
			addBound(typeInfo, makeUseBound(regArg));
		}
	}
	private void mergePhiBounds(SSAVar ssaVar) {
		for (PhiInsn usedInPhi : ssaVar.getUsedInPhi()) {
			Set<ITypeBound> bounds = ssaVar.getTypeInfo().getBounds();
			bounds.addAll(usedInPhi.getResult().getSVar().getTypeInfo().getBounds());
			for (InsnArg arg : usedInPhi.getArguments()) {
				bounds.addAll(((RegisterArg) arg).getSVar().getTypeInfo().getBounds());
			}
		}
	}
	private void addBound(TypeInfo typeInfo, ITypeBound bound) {
		if (bound == null) {
			return;
		}
		if (bound instanceof ITypeBoundDynamic
				|| bound.getType() != ArgType.UNKNOWN) {
			typeInfo.getBounds().add(bound);
		}
	}
	private void addAssignBound(TypeInfo typeInfo, RegisterArg assign) {
		ArgType immutableType = assign.getImmutableType();
		if (immutableType != null) {
			addBound(typeInfo, new TypeBoundConst(BoundEnum.ASSIGN, immutableType));
			return;
		}
		InsnNode insn = assign.getParentInsn();
		if (insn == null || insn.getResult() == null) {
			addBound(typeInfo, new TypeBoundConst(BoundEnum.ASSIGN, assign.getInitType()));
			return;
		}
		switch (insn.getType()) {
			case NEW_INSTANCE:
				ArgType clsType = (ArgType) ((IndexInsnNode) insn).getIndex();
				addBound(typeInfo, new TypeBoundConst(BoundEnum.ASSIGN, clsType));
				break;
			case CONSTRUCTOR:
				ArgType ctrClsType = replaceAnonymousType((ConstructorInsn) insn);
				addBound(typeInfo, new TypeBoundConst(BoundEnum.ASSIGN, ctrClsType));
				break;
			case CONST:
				LiteralArg constLit = (LiteralArg) insn.getArg(0);
				addBound(typeInfo, new TypeBoundConst(BoundEnum.ASSIGN, constLit.getType()));
				break;
			case MOVE_EXCEPTION:
				ExcHandlerAttr excHandlerAttr = insn.get(AType.EXC_HANDLER);
				if (excHandlerAttr != null) {
					for (ClassInfo catchType : excHandlerAttr.getHandler().getCatchTypes()) {
						addBound(typeInfo, new TypeBoundConst(BoundEnum.ASSIGN, catchType.getType()));
					}
				} else {
					addBound(typeInfo, new TypeBoundConst(BoundEnum.ASSIGN, insn.getResult().getInitType()));
				}
				break;
			case INVOKE:
				addBound(typeInfo, makeAssignInvokeBound((InvokeNode) insn));
				break;
			case IGET:
				addBound(typeInfo, makeAssignFieldGetBound((IndexInsnNode) insn));
				break;
			case CHECK_CAST:
				if (insn.contains(AFlag.SOFT_CAST)) {
				} else {
					addBound(typeInfo, new TypeBoundCheckCastAssign(root, (IndexInsnNode) insn));
				}
				break;
			default:
				ArgType type = insn.getResult().getInitType();
				addBound(typeInfo, new TypeBoundConst(BoundEnum.ASSIGN, type));
				break;
		}
	}
	private ArgType replaceAnonymousType(ConstructorInsn ctr) {
		if (ctr.isNewInstance()) {
			ClassNode ctrCls = root.resolveClass(ctr.getClassType());
			if (ctrCls != null && ctrCls.contains(AFlag.DONT_GENERATE)) {
				AnonymousClassAttr baseTypeAttr = ctrCls.get(AType.ANONYMOUS_CLASS);
				if (baseTypeAttr != null && baseTypeAttr.getInlineType() == AnonymousClassAttr.InlineType.CONSTRUCTOR) {
					return baseTypeAttr.getBaseType();
				}
			}
		}
		return ctr.getClassType().getType();
	}
	private ITypeBound makeAssignFieldGetBound(IndexInsnNode insn) {
		ArgType initType = insn.getResult().getInitType();
		if (initType.containsTypeVariable()) {
			return new TypeBoundFieldGetAssign(root, insn, initType);
		}
		return new TypeBoundConst(BoundEnum.ASSIGN, initType);
	}
	private ITypeBound makeAssignInvokeBound(InvokeNode invokeNode) {
		ArgType boundType = invokeNode.getCallMth().getReturnType();
		ArgType genericReturnType = root.getMethodUtils().getMethodGenericReturnType(invokeNode);
		if (genericReturnType != null) {
			if (genericReturnType.containsTypeVariable()) {
				InvokeType invokeType = invokeNode.getInvokeType();
				if (invokeNode.getArgsCount() != 0
						&& invokeType != InvokeType.STATIC && invokeType != InvokeType.SUPER) {
					return new TypeBoundInvokeAssign(root, invokeNode, genericReturnType);
				}
			} else {
				boundType = genericReturnType;
			}
		}
		return new TypeBoundConst(BoundEnum.ASSIGN, boundType);
	}
	@Nullable
	private ITypeBound makeUseBound(RegisterArg regArg) {
		InsnNode insn = regArg.getParentInsn();
		if (insn == null) {
			return null;
		}
		if (insn instanceof BaseInvokeNode) {
			ITypeBound invokeUseBound = makeInvokeUseBound(regArg, (BaseInvokeNode) insn);
			if (invokeUseBound != null) {
				return invokeUseBound;
			}
		}
		if (insn.getType() == InsnType.CHECK_CAST && insn.contains(AFlag.SOFT_CAST)) {
			return null;
		}
		return new TypeBoundConst(BoundEnum.USE, regArg.getInitType(), regArg);
	}
	private ITypeBound makeInvokeUseBound(RegisterArg regArg, BaseInvokeNode invoke) {
		InsnArg instanceArg = invoke.getInstanceArg();
		if (instanceArg == null) {
			return null;
		}
		MethodUtils methodUtils = root.getMethodUtils();
		IMethodDetails methodDetails = methodUtils.getMethodDetails(invoke);
		if (methodDetails == null) {
			return null;
		}
		if (instanceArg != regArg) {
			int argIndex = invoke.getArgIndex(regArg) - invoke.getFirstArgOffset();
			ArgType argType = methodDetails.getArgTypes().get(argIndex);
			if (!argType.containsTypeVariable()) {
				return null;
			}
			return new TypeBoundInvokeUse(root, invoke, regArg, argType);
		}
		if (methodDetails instanceof MethodNode) {
			MethodNode callMth = (MethodNode) methodDetails;
			ClassInfo declCls = methodUtils.getMethodOriginDeclClass(callMth);
			return new TypeBoundConst(BoundEnum.USE, declCls.getType(), regArg);
		}
		return null;
	}
	private void assignImmutableTypes(MethodNode mth) {
		for (SSAVar ssaVar : mth.getSVars()) {
			ArgType immutableType = getSsaImmutableType(ssaVar);
			if (immutableType != null) {
				ssaVar.markAsImmutable(immutableType);
			}
		}
	}
	@Nullable
	private static ArgType getSsaImmutableType(SSAVar ssaVar) {
		if (ssaVar.getAssign().contains(AFlag.IMMUTABLE_TYPE)) {
			return ssaVar.getAssign().getInitType();
		}
		for (RegisterArg reg : ssaVar.getUseList()) {
			if (reg.contains(AFlag.IMMUTABLE_TYPE)) {
				return reg.getInitType();
			}
		}
		return null;
	}
	@Override
	public String getName() {
		return "TypeInferenceVisitor";
	}
}
_______
package jadx.core.dex.visitors.finaly;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.core.Consts;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.attributes.AType;
import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;
import jadx.core.dex.instructions.InsnType;
import jadx.core.dex.instructions.args.InsnArg;
import jadx.core.dex.instructions.args.RegisterArg;
import jadx.core.dex.instructions.args.SSAVar;
import jadx.core.dex.nodes.BlockNode;
import jadx.core.dex.nodes.InsnNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.trycatch.ExceptionHandler;
import jadx.core.dex.trycatch.TryCatchBlockAttr;
import jadx.core.dex.visitors.AbstractVisitor;
import jadx.core.dex.visitors.ConstInlineVisitor;
import jadx.core.dex.visitors.DepthTraversal;
import jadx.core.dex.visitors.IDexTreeVisitor;
import jadx.core.dex.visitors.JadxVisitor;
import jadx.core.dex.visitors.ssa.SSATransform;
import jadx.core.utils.BlockUtils;
import jadx.core.utils.InsnList;
import jadx.core.utils.ListUtils;
import jadx.core.utils.Utils;
import jadx.core.utils.blocks.BlockPair;
@JadxVisitor(
		name = "MarkFinallyVisitor",
		desc = "Search and mark duplicate code generated for finally block",
		runAfter = SSATransform.class,
		runBefore = ConstInlineVisitor.class
)
public class MarkFinallyVisitor extends AbstractVisitor {
	private static final Logger LOG = LoggerFactory.getLogger(MarkFinallyVisitor.class);
	@Override
	public void visit(MethodNode mth) {
		if (mth.isNoCode() || mth.isNoExceptionHandlers()) {
			return;
		}
		try {
			boolean applied = false;
			List<TryCatchBlockAttr> tryBlocks = mth.getAll(AType.TRY_BLOCKS_LIST);
			for (TryCatchBlockAttr tryBlock : tryBlocks) {
				applied |= processTryBlock(mth, tryBlock);
			}
			if (applied) {
				mth.clearExceptionHandlers();
				List<TryCatchBlockAttr> clearedTryBlocks = new ArrayList<>(tryBlocks);
				if (clearedTryBlocks.removeIf(tb -> tb.isMerged() || tb.getHandlers().isEmpty())) {
					mth.remove(AType.TRY_BLOCKS_LIST);
					mth.addAttr(AType.TRY_BLOCKS_LIST, clearedTryBlocks);
				}
			}
		} catch (Exception e) {
			mth.addWarnComment("Undo finally extract visitor", e);
			undoFinallyVisitor(mth);
		}
	}
	private static boolean processTryBlock(MethodNode mth, TryCatchBlockAttr tryBlock) {
		if (tryBlock.isMerged()) {
			return false;
		}
		ExceptionHandler allHandler = null;
		InsnNode reThrowInsn = null;
		for (ExceptionHandler excHandler : tryBlock.getHandlers()) {
			if (excHandler.isCatchAll()) {
				allHandler = excHandler;
				for (BlockNode excBlock : excHandler.getBlocks()) {
					InsnNode lastInsn = BlockUtils.getLastInsn(excBlock);
					if (lastInsn != null && lastInsn.getType() == InsnType.THROW) {
						reThrowInsn = BlockUtils.getLastInsn(excBlock);
					}
				}
				break;
			}
		}
		if (allHandler != null && reThrowInsn != null) {
			if (extractFinally(mth, tryBlock, allHandler)) {
				reThrowInsn.add(AFlag.DONT_GENERATE);
				return true;
			}
		}
		return false;
	}
	private static boolean extractFinally(MethodNode mth, TryCatchBlockAttr tryBlock, ExceptionHandler allHandler) {
		BlockNode handlerBlock = allHandler.getHandlerBlock();
		List<BlockNode> handlerBlocks =
				new ArrayList<>(BlockUtils.collectBlocksDominatedByWithExcHandlers(mth, handlerBlock, handlerBlock));
		handlerBlocks.remove(handlerBlock); 
		cutPathEnds(mth, handlerBlocks);
		if (handlerBlocks.isEmpty() || BlockUtils.isAllBlocksEmpty(handlerBlocks)) {
			allHandler.getTryBlock().removeHandler(allHandler);
			return true;
		}
		BlockNode startBlock = Utils.getOne(handlerBlock.getCleanSuccessors());
		FinallyExtractInfo extractInfo = new FinallyExtractInfo(mth, allHandler, startBlock, handlerBlocks);
		if (Consts.DEBUG_FINALLY) {
			LOG.debug("Finally info: handler=({}), start={}, blocks={}", allHandler, startBlock, handlerBlocks);
		}
		boolean hasInnerBlocks = !tryBlock.getInnerTryBlocks().isEmpty();
		List<ExceptionHandler> handlers;
		if (hasInnerBlocks) {
			handlers = new ArrayList<>(tryBlock.getHandlers());
			for (TryCatchBlockAttr innerTryBlock : tryBlock.getInnerTryBlocks()) {
				handlers.addAll(innerTryBlock.getHandlers());
			}
		} else {
			handlers = tryBlock.getHandlers();
		}
		if (handlers.isEmpty()) {
			return false;
		}
		for (ExceptionHandler otherHandler : handlers) {
			if (otherHandler == allHandler) {
				continue;
			}
			for (BlockNode checkBlock : otherHandler.getBlocks()) {
				if (searchDuplicateInsns(checkBlock, extractInfo)) {
					break;
				} else {
					extractInfo.getFinallyInsnsSlice().resetIncomplete();
				}
			}
		}
		if (Consts.DEBUG_FINALLY) {
			LOG.debug("Handlers slices:\n{}", extractInfo);
		}
		boolean mergeInnerTryBlocks;
		int duplicatesCount = extractInfo.getDuplicateSlices().size();
		if (duplicatesCount == (handlers.size() - 1)) {
			mergeInnerTryBlocks = hasInnerBlocks;
		} else {
			if (!hasInnerBlocks || duplicatesCount != (tryBlock.getHandlers().size() - 1)) {
				return false;
			}
			mergeInnerTryBlocks = false;
		}
		List<BlockNode> tryBlocks = allHandler.getTryBlock().getBlocks();
		BlockNode bottomBlock = BlockUtils.getBottomBlock(allHandler.getBlocks());
		if (bottomBlock == null) {
			if (Consts.DEBUG_FINALLY) {
				LOG.warn("No bottom block for handler: {} and blocks: {}", allHandler, allHandler.getBlocks());
			}
			return false;
		}
		BlockNode bottomFinallyBlock = BlockUtils.followEmptyPath(bottomBlock);
		BlockNode bottom = BlockUtils.getNextBlock(bottomFinallyBlock);
		if (bottom == null) {
			if (Consts.DEBUG_FINALLY) {
				LOG.warn("Finally bottom block not found for: {} and: {}", bottomBlock, bottomFinallyBlock);
			}
			return false;
		}
		boolean found = false;
		List<BlockNode> pathBlocks = getPathStarts(mth, bottom, bottomFinallyBlock);
		for (BlockNode pred : pathBlocks) {
			List<BlockNode> upPath = BlockUtils.collectPredecessors(mth, pred, tryBlocks);
			if (upPath.size() < handlerBlocks.size()) {
				continue;
			}
			if (Consts.DEBUG_FINALLY) {
				LOG.debug("Checking dup path starts: {} from {}", upPath, pred);
			}
			for (BlockNode block : upPath) {
				if (searchDuplicateInsns(block, extractInfo)) {
					found = true;
					if (Consts.DEBUG_FINALLY) {
						LOG.debug("Found dup in: {} from {}", block, pred);
					}
					break;
				} else {
					extractInfo.getFinallyInsnsSlice().resetIncomplete();
				}
			}
		}
		if (!found) {
			if (Consts.DEBUG_FINALLY) {
				LOG.info("Dup not found for all handler: {}", allHandler);
			}
			return false;
		}
		if (Consts.DEBUG_FINALLY) {
			LOG.debug("Result slices:\n{}", extractInfo);
		}
		if (!checkSlices(extractInfo)) {
			mth.addWarnComment("Finally extract failed");
			return false;
		}
		apply(extractInfo);
		allHandler.setFinally(true);
		if (mergeInnerTryBlocks) {
			List<TryCatchBlockAttr> innerTryBlocks = tryBlock.getInnerTryBlocks();
			for (TryCatchBlockAttr innerTryBlock : innerTryBlocks) {
				tryBlock.getHandlers().addAll(innerTryBlock.getHandlers());
				tryBlock.getBlocks().addAll(innerTryBlock.getBlocks());
				innerTryBlock.setMerged(true);
			}
			tryBlock.setBlocks(ListUtils.distinctList(tryBlock.getBlocks()));
			innerTryBlocks.clear();
		}
		return true;
	}
	private static void cutPathEnds(MethodNode mth, List<BlockNode> handlerBlocks) {
		List<BlockNode> throwBlocks = ListUtils.filter(handlerBlocks,
				b -> BlockUtils.checkLastInsnType(b, InsnType.THROW));
		if (throwBlocks.size() != 1) {
			mth.addDebugComment("Finally have unexpected throw blocks count: " + throwBlocks.size() + ", expect 1");
			return;
		}
		BlockNode throwBlock = throwBlocks.get(0);
		handlerBlocks.remove(throwBlock);
		removeEmptyUpPath(handlerBlocks, throwBlock);
	}
	private static void removeEmptyUpPath(List<BlockNode> handlerBlocks, BlockNode startBlock) {
		for (BlockNode pred : startBlock.getPredecessors()) {
			if (pred.isEmpty()) {
				if (handlerBlocks.remove(pred) && !BlockUtils.isBackEdge(pred, startBlock)) {
					removeEmptyUpPath(handlerBlocks, pred);
				}
			}
		}
	}
	private static List<BlockNode> getPathStarts(MethodNode mth, BlockNode bottom, BlockNode bottomFinallyBlock) {
		Stream<BlockNode> preds = bottom.getPredecessors().stream().filter(b -> b != bottomFinallyBlock);
		if (bottom == mth.getExitBlock()) {
			preds = preds.flatMap(r -> r.getPredecessors().stream());
		}
		return preds.collect(Collectors.toList());
	}
	private static boolean checkSlices(FinallyExtractInfo extractInfo) {
		InsnsSlice finallySlice = extractInfo.getFinallyInsnsSlice();
		List<InsnNode> finallyInsnsList = finallySlice.getInsnsList();
		for (InsnsSlice dupSlice : extractInfo.getDuplicateSlices()) {
			List<InsnNode> dupInsnsList = dupSlice.getInsnsList();
			if (dupInsnsList.size() != finallyInsnsList.size()) {
				extractInfo.getMth().addDebugComment(
						"Incorrect finally slice size: " + dupSlice + ", expected: " + finallySlice);
				return false;
			}
		}
		for (int i = 0; i < finallyInsnsList.size(); i++) {
			InsnNode finallyInsn = finallyInsnsList.get(i);
			for (InsnsSlice dupSlice : extractInfo.getDuplicateSlices()) {
				List<InsnNode> insnsList = dupSlice.getInsnsList();
				InsnNode dupInsn = insnsList.get(i);
				if (finallyInsn.getType() != dupInsn.getType()) {
					extractInfo.getMth().addDebugComment(
							"Incorrect finally slice insn: " + dupInsn + ", expected: " + finallyInsn);
					return false;
				}
			}
		}
		return true;
	}
	private static void apply(FinallyExtractInfo extractInfo) {
		markSlice(extractInfo.getFinallyInsnsSlice(), AFlag.FINALLY_INSNS);
		for (InsnsSlice dupSlice : extractInfo.getDuplicateSlices()) {
			markSlice(dupSlice, AFlag.DONT_GENERATE);
		}
		InsnsSlice finallySlice = extractInfo.getFinallyInsnsSlice();
		List<InsnNode> finallyInsnsList = finallySlice.getInsnsList();
		for (int i = 0; i < finallyInsnsList.size(); i++) {
			InsnNode finallyInsn = finallyInsnsList.get(i);
			for (InsnsSlice dupSlice : extractInfo.getDuplicateSlices()) {
				InsnNode dupInsn = dupSlice.getInsnsList().get(i);
				copyCodeVars(finallyInsn, dupInsn);
			}
		}
	}
	private static void markSlice(InsnsSlice slice, AFlag flag) {
		List<InsnNode> insnsList = slice.getInsnsList();
		for (InsnNode insn : insnsList) {
			insn.add(flag);
		}
		for (BlockNode block : slice.getBlocks()) {
			boolean allInsnMarked = true;
			for (InsnNode insn : block.getInstructions()) {
				if (!insn.contains(flag)) {
					allInsnMarked = false;
					break;
				}
			}
			if (allInsnMarked) {
				block.add(flag);
			}
		}
	}
	private static void copyCodeVars(InsnNode fromInsn, InsnNode toInsn) {
		copyCodeVars(fromInsn.getResult(), toInsn.getResult());
		int argsCount = fromInsn.getArgsCount();
		for (int i = 0; i < argsCount; i++) {
			copyCodeVars(fromInsn.getArg(i), toInsn.getArg(i));
		}
	}
	private static void copyCodeVars(InsnArg fromArg, InsnArg toArg) {
		if (fromArg == null || toArg == null
				|| !fromArg.isRegister() || !toArg.isRegister()) {
			return;
		}
		SSAVar fromSsaVar = ((RegisterArg) fromArg).getSVar();
		SSAVar toSsaVar = ((RegisterArg) toArg).getSVar();
		toSsaVar.setCodeVar(fromSsaVar.getCodeVar());
	}
	private static boolean searchDuplicateInsns(BlockNode checkBlock, FinallyExtractInfo extractInfo) {
		boolean isNew = extractInfo.getCheckedBlocks().add(checkBlock);
		if (!isNew) {
			return false;
		}
		BlockNode startBlock = extractInfo.getStartBlock();
		InsnsSlice dupSlice = searchFromFirstBlock(checkBlock, startBlock, extractInfo);
		if (dupSlice == null) {
			return false;
		}
		extractInfo.getDuplicateSlices().add(dupSlice);
		return true;
	}
	private static InsnsSlice searchFromFirstBlock(BlockNode dupBlock, BlockNode startBlock, FinallyExtractInfo extractInfo) {
		InsnsSlice dupSlice = isStartBlock(dupBlock, startBlock, extractInfo);
		if (dupSlice == null) {
			return null;
		}
		if (!dupSlice.isComplete()) {
			Map<BlockPair, Boolean> checkCache = new HashMap<>();
			if (checkBlocksTree(dupBlock, startBlock, dupSlice, extractInfo, checkCache)) {
				dupSlice.setComplete(true);
				extractInfo.getFinallyInsnsSlice().setComplete(true);
			} else {
				return null;
			}
		}
		return checkTempSlice(dupSlice);
	}
	@Nullable
	private static InsnsSlice checkTempSlice(InsnsSlice slice) {
		List<InsnNode> insnsList = slice.getInsnsList();
		if (insnsList.isEmpty()) {
			return null;
		}
		if (insnsList.size() == 1) {
			InsnNode insnNode = insnsList.get(0);
			if (insnNode.getType() == InsnType.IF) {
				return null;
			}
		}
		return slice;
	}
	private static InsnsSlice isStartBlock(BlockNode dupBlock, BlockNode finallyBlock, FinallyExtractInfo extractInfo) {
		extractInfo.setCurDupSlice(null);
		List<InsnNode> dupInsns = dupBlock.getInstructions();
		List<InsnNode> finallyInsns = finallyBlock.getInstructions();
		int dupSize = dupInsns.size();
		int finSize = finallyInsns.size();
		if (dupSize < finSize) {
			return null;
		}
		int startPos;
		int endPos = 0;
		if (dupSize == finSize) {
			if (!checkInsns(extractInfo, dupInsns, finallyInsns, 0)) {
				return null;
			}
			startPos = 0;
		} else {
			startPos = dupSize - finSize;
			if (!checkInsns(extractInfo, dupInsns, finallyInsns, startPos)) {
				boolean found = false;
				for (int i = 1; i < startPos; i++) {
					if (checkInsns(extractInfo, dupInsns, finallyInsns, i)) {
						startPos = i;
						endPos = finSize + i;
						found = true;
						break;
					}
				}
				if (!found) {
					return null;
				}
			}
		}
		boolean complete;
		InsnsSlice slice = new InsnsSlice();
		extractInfo.setCurDupSlice(slice);
		int endIndex;
		if (endPos != 0) {
			endIndex = endPos + 1;
			complete = true;
		} else {
			endIndex = dupSize;
			complete = false;
		}
		for (int i = startPos; i < endIndex; i++) {
			slice.addInsn(dupInsns.get(i), dupBlock);
		}
		InsnsSlice finallySlice = extractInfo.getFinallyInsnsSlice();
		if (finallySlice.isComplete()) {
			if (finallySlice.getInsnsList().size() != slice.getInsnsList().size()) {
				extractInfo.getMth().addDebugComment(
						"Another duplicated slice has different insns count: " + slice + ", finally: " + finallySlice);
				return null;
			}
		} else {
			for (InsnNode finallyInsn : finallyInsns) {
				finallySlice.addInsn(finallyInsn, finallyBlock);
			}
		}
		if (complete) {
			slice.setComplete(true);
			finallySlice.setComplete(true);
		}
		return slice;
	}
	private static boolean checkInsns(FinallyExtractInfo extractInfo, List<InsnNode> dupInsns, List<InsnNode> finallyInsns, int delta) {
		extractInfo.setCurDupInsns(dupInsns, delta);
		for (int i = finallyInsns.size() - 1; i >= 0; i--) {
			InsnNode startInsn = finallyInsns.get(i);
			InsnNode dupInsn = dupInsns.get(delta + i);
			if (!sameInsns(extractInfo, dupInsn, startInsn)) {
				return false;
			}
		}
		return true;
	}
	private static boolean checkBlocksTree(BlockNode dupBlock, BlockNode finallyBlock,
			InsnsSlice dupSlice, FinallyExtractInfo extractInfo,
			Map<BlockPair, Boolean> checksCache) {
		BlockPair checkBlocks = new BlockPair(dupBlock, finallyBlock);
		Boolean checked = checksCache.get(checkBlocks);
		if (checked != null) {
			return checked;
		}
		boolean same;
		InsnsSlice finallySlice = extractInfo.getFinallyInsnsSlice();
		List<BlockNode> finallyCS = getSuccessorsWithoutLoop(finallyBlock);
		List<BlockNode> dupCS = getSuccessorsWithoutLoop(dupBlock);
		if (finallyCS.size() == dupCS.size()) {
			same = true;
			for (int i = 0; i < finallyCS.size(); i++) {
				BlockNode finSBlock = finallyCS.get(i);
				BlockNode dupSBlock = dupCS.get(i);
				if (extractInfo.getAllHandlerBlocks().contains(finSBlock)) {
					if (!compareBlocks(dupSBlock, finSBlock, dupSlice, extractInfo)) {
						same = false;
						break;
					}
					if (!checkBlocksTree(dupSBlock, finSBlock, dupSlice, extractInfo, checksCache)) {
						same = false;
						break;
					}
					dupSlice.addBlock(dupSBlock);
					finallySlice.addBlock(finSBlock);
				}
			}
		} else {
			same = true;
		}
		checksCache.put(checkBlocks, same);
		return same;
	}
	private static List<BlockNode> getSuccessorsWithoutLoop(BlockNode block) {
		if (block.contains(AFlag.LOOP_END)) {
			return block.getCleanSuccessors();
		}
		return block.getSuccessors();
	}
	private static boolean compareBlocks(BlockNode dupBlock, BlockNode finallyBlock, InsnsSlice dupSlice, FinallyExtractInfo extractInfo) {
		List<InsnNode> dupInsns = dupBlock.getInstructions();
		List<InsnNode> finallyInsns = finallyBlock.getInstructions();
		int dupInsnCount = dupInsns.size();
		int finallyInsnCount = finallyInsns.size();
		if (finallyInsnCount == 0) {
			return dupInsnCount == 0;
		}
		if (dupInsnCount < finallyInsnCount) {
			return false;
		}
		extractInfo.setCurDupInsns(dupInsns, 0);
		for (int i = 0; i < finallyInsnCount; i++) {
			if (!sameInsns(extractInfo, dupInsns.get(i), finallyInsns.get(i))) {
				return false;
			}
		}
		if (dupInsnCount > finallyInsnCount) {
			dupSlice.addInsns(dupBlock, 0, finallyInsnCount);
			dupSlice.setComplete(true);
			InsnsSlice finallyInsnsSlice = extractInfo.getFinallyInsnsSlice();
			finallyInsnsSlice.addBlock(finallyBlock);
			finallyInsnsSlice.setComplete(true);
		}
		return true;
	}
	private static boolean sameInsns(FinallyExtractInfo extractInfo, InsnNode dupInsn, InsnNode fInsn) {
		if (!dupInsn.isSame(fInsn)) {
			return false;
		}
		for (int i = 0; i < dupInsn.getArgsCount(); i++) {
			InsnArg dupArg = dupInsn.getArg(i);
			InsnArg fArg = fInsn.getArg(i);
			if (!isSameArgs(extractInfo, dupArg, fArg)) {
				return false;
			}
		}
		return true;
	}
	@SuppressWarnings("RedundantIfStatement")
	private static boolean isSameArgs(FinallyExtractInfo extractInfo, InsnArg dupArg, InsnArg fArg) {
		boolean isReg = dupArg.isRegister();
		if (isReg != fArg.isRegister()) {
			return false;
		}
		if (isReg) {
			RegisterArg dupReg = (RegisterArg) dupArg;
			RegisterArg fReg = (RegisterArg) fArg;
			if (!dupReg.sameCodeVar(fReg)
					&& !sameDebugInfo(dupReg, fReg)
					&& assignedOutsideHandler(extractInfo, dupReg, fReg)
					&& assignInsnDifferent(dupReg, fReg)) {
				return false;
			}
		}
		boolean remConst = dupArg.isConst();
		if (remConst != fArg.isConst()) {
			return false;
		}
		if (remConst && !dupArg.isSameConst(fArg)) {
			return false;
		}
		return true;
	}
	private static boolean sameDebugInfo(RegisterArg dupReg, RegisterArg fReg) {
		RegDebugInfoAttr fDbgInfo = fReg.get(AType.REG_DEBUG_INFO);
		RegDebugInfoAttr dupDbgInfo = dupReg.get(AType.REG_DEBUG_INFO);
		if (fDbgInfo == null || dupDbgInfo == null) {
			return false;
		}
		return dupDbgInfo.equals(fDbgInfo);
	}
	private static boolean assignInsnDifferent(RegisterArg dupReg, RegisterArg fReg) {
		InsnNode assignInsn = fReg.getAssignInsn();
		InsnNode dupAssign = dupReg.getAssignInsn();
		if (assignInsn == null || dupAssign == null) {
			return true;
		}
		if (!assignInsn.isSame(dupAssign)) {
			return true;
		}
		if (assignInsn.isConstInsn() && dupAssign.isConstInsn()) {
			return !assignInsn.isDeepEquals(dupAssign);
		}
		return false;
	}
	@SuppressWarnings("RedundantIfStatement")
	private static boolean assignedOutsideHandler(FinallyExtractInfo extractInfo, RegisterArg dupReg, RegisterArg fReg) {
		if (InsnList.contains(extractInfo.getFinallyInsnsSlice().getInsnsList(), fReg.getAssignInsn())) {
			return false;
		}
		InsnNode dupAssign = dupReg.getAssignInsn();
		InsnsSlice curDupSlice = extractInfo.getCurDupSlice();
		if (curDupSlice != null && InsnList.contains(curDupSlice.getInsnsList(), dupAssign)) {
			return false;
		}
		List<InsnNode> curDupInsns = extractInfo.getCurDupInsns();
		if (Utils.notEmpty(curDupInsns) && InsnList.contains(curDupInsns, dupAssign, extractInfo.getCurDupInsnsOffset())) {
			return false;
		}
		return true;
	}
	private static void undoFinallyVisitor(MethodNode mth) {
		try {
			mth.unload();
			mth.load();
			for (IDexTreeVisitor visitor : mth.root().getPasses()) {
				if (visitor instanceof MarkFinallyVisitor) {
					break;
				}
				DepthTraversal.visit(visitor, mth);
			}
		} catch (Exception e) {
			mth.addError("Undo finally extract failed", e);
		}
	}
}
_______
package jadx.core.dex.visitors.usage;
import java.util.Collections;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jadx.api.plugins.input.data.ICallSite;
import jadx.api.plugins.input.data.ICodeReader;
import jadx.api.plugins.input.data.IMethodHandle;
import jadx.api.plugins.input.data.IMethodRef;
import jadx.api.plugins.input.insns.InsnData;
import jadx.api.plugins.input.insns.Opcode;
import jadx.api.plugins.input.insns.custom.ICustomPayload;
import jadx.api.usage.IUsageInfoCache;
import jadx.api.usage.IUsageInfoData;
import jadx.core.dex.info.FieldInfo;
import jadx.core.dex.info.MethodInfo;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.nodes.ClassNode;
import jadx.core.dex.nodes.FieldNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.nodes.RootNode;
import jadx.core.dex.visitors.AbstractVisitor;
import jadx.core.dex.visitors.JadxVisitor;
import jadx.core.dex.visitors.OverrideMethodVisitor;
import jadx.core.dex.visitors.rename.RenameVisitor;
import jadx.core.utils.ListUtils;
import jadx.core.utils.input.InsnDataUtils;
@JadxVisitor(
		name = "UsageInfoVisitor",
		desc = "Scan class and methods to collect usage info and class dependencies",
		runAfter = {
				OverrideMethodVisitor.class, 
				RenameVisitor.class 
		}
)
public class UsageInfoVisitor extends AbstractVisitor {
	private static final Logger LOG = LoggerFactory.getLogger(UsageInfoVisitor.class);
	@Override
	public void init(RootNode root) {
		IUsageInfoCache usageCache = root.getArgs().getUsageInfoCache();
		IUsageInfoData usageInfoData = usageCache.get(root);
		if (usageInfoData != null) {
			try {
				apply(usageInfoData);
				return;
			} catch (Exception e) {
				LOG.error("Failed to apply cached usage data", e);
			}
		}
		IUsageInfoData collectedInfoData = buildUsageData(root);
		usageCache.set(root, collectedInfoData);
		apply(collectedInfoData);
	}
	private static void apply(IUsageInfoData usageInfoData) {
		long start = System.currentTimeMillis();
		usageInfoData.apply();
		if (LOG.isDebugEnabled()) {
			LOG.debug("Apply usage data in {}ms", System.currentTimeMillis() - start);
		}
	}
	private static IUsageInfoData buildUsageData(RootNode root) {
		UsageInfo usageInfo = new UsageInfo(root);
		for (ClassNode cls : root.getClasses()) {
			processClass(cls, usageInfo);
		}
		return usageInfo;
	}
	private static void processClass(ClassNode cls, UsageInfo usageInfo) {
		usageInfo.clsUse(cls, cls.getSuperClass());
		for (ArgType interfaceType : cls.getInterfaces()) {
			usageInfo.clsUse(cls, interfaceType);
		}
		for (FieldNode fieldNode : cls.getFields()) {
			usageInfo.clsUse(cls, fieldNode.getType());
		}
		for (MethodNode methodNode : cls.getMethods()) {
			processMethod(methodNode, usageInfo);
		}
	}
	private static void processMethod(MethodNode mth, UsageInfo usageInfo) {
		ClassNode cls = mth.getParentClass();
		usageInfo.clsUse(cls, mth.getReturnType());
		for (ArgType argType : mth.getMethodInfo().getArgumentsTypes()) {
			usageInfo.clsUse(cls, argType);
		}
		try {
			processInstructions(mth, usageInfo);
		} catch (Exception e) {
			mth.addError("Dependency scan failed", e);
		}
	}
	private static void processInstructions(MethodNode mth, UsageInfo usageInfo) {
		if (mth.isNoCode()) {
			return;
		}
		ICodeReader codeReader = mth.getCodeReader();
		if (codeReader == null) {
			return;
		}
		RootNode root = mth.root();
		codeReader.visitInstructions(insnData -> {
			try {
				processInsn(root, mth, insnData, usageInfo);
			} catch (Exception e) {
				mth.addError("Dependency scan failed at insn: " + insnData, e);
			}
		});
	}
	private static void processInsn(RootNode root, MethodNode mth, InsnData insnData, UsageInfo usageInfo) {
		if (insnData.getOpcode() == Opcode.UNKNOWN) {
			return;
		}
		switch (insnData.getIndexType()) {
			case TYPE_REF:
				insnData.decode();
				ArgType usedType = ArgType.parse(insnData.getIndexAsType());
				usageInfo.clsUse(mth, usedType);
				break;
			case FIELD_REF:
				insnData.decode();
				FieldNode fieldNode = root.resolveField(FieldInfo.fromRef(root, insnData.getIndexAsField()));
				if (fieldNode != null) {
					usageInfo.fieldUse(mth, fieldNode);
				}
				break;
			case METHOD_REF: {
				insnData.decode();
				IMethodRef mthRef;
				ICustomPayload payload = insnData.getPayload();
				if (payload != null) {
					mthRef = (IMethodRef) payload;
				} else {
					mthRef = insnData.getIndexAsMethod();
				}
				MethodNode methodNode = root.resolveMethod(MethodInfo.fromRef(root, mthRef));
				if (methodNode != null) {
					usageInfo.methodUse(mth, methodNode);
				}
				break;
			}
			case CALL_SITE: {
				insnData.decode();
				ICallSite callSite = InsnDataUtils.getCallSite(insnData);
				IMethodHandle methodHandle = InsnDataUtils.getMethodHandleAt(callSite, 4);
				if (methodHandle != null) {
					IMethodRef mthRef = methodHandle.getMethodRef();
					MethodNode mthNode = root.resolveMethod(MethodInfo.fromRef(root, mthRef));
					if (mthNode != null) {
						usageInfo.methodUse(mth, mthNode);
					}
				}
				break;
			}
		}
	}
	public static void replaceMethodUsage(MethodNode mergeIntoMth, MethodNode sourceMth) {
		List<MethodNode> mergedUsage = ListUtils.distinctMergeSortedLists(mergeIntoMth.getUseIn(), sourceMth.getUseIn());
		mergedUsage.remove(sourceMth);
		mergeIntoMth.setUseIn(mergedUsage);
		sourceMth.setUseIn(Collections.emptyList());
	}
	@Override
	public String getName() {
		return "UsageInfoVisitor";
	}
}
_______
package jadx.core.dex.visitors;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.jetbrains.annotations.Nullable;
import jadx.api.plugins.input.data.AccessFlags;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.attributes.AType;
import jadx.core.dex.attributes.nodes.AnonymousClassAttr;
import jadx.core.dex.attributes.nodes.AnonymousClassAttr.InlineType;
import jadx.core.dex.info.AccessInfo;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.nodes.ClassNode;
import jadx.core.dex.nodes.FieldNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.nodes.RootNode;
import jadx.core.dex.visitors.usage.UsageInfoVisitor;
import jadx.core.utils.ListUtils;
import jadx.core.utils.exceptions.JadxException;
@JadxVisitor(
		name = "ProcessAnonymous",
		desc = "Mark anonymous and lambda classes (for future inline)",
		runAfter = {
				UsageInfoVisitor.class
		}
)
@SuppressWarnings("BooleanMethodIsAlwaysInverted")
public class ProcessAnonymous extends AbstractVisitor {
	private boolean inlineAnonymousClasses;
	@Override
	public void init(RootNode root) {
		inlineAnonymousClasses = root.getArgs().isInlineAnonymousClasses();
		if (!inlineAnonymousClasses) {
			return;
		}
		root.getClasses().forEach(ProcessAnonymous::processClass);
		mergeAnonymousDeps(root);
	}
	@Override
	public boolean visit(ClassNode cls) throws JadxException {
		if (inlineAnonymousClasses && cls.contains(AFlag.CLASS_UNLOADED)) {
			visitClassAndInners(cls);
		}
		return false;
	}
	private void visitClassAndInners(ClassNode cls) {
		processClass(cls);
		cls.getInnerClasses().forEach(this::visitClassAndInners);
	}
	private static void processClass(ClassNode cls) {
		try {
			markAnonymousClass(cls);
		} catch (Throwable e) {
			cls.addError("Anonymous visitor error", e);
		}
	}
	private static void markAnonymousClass(ClassNode cls) {
		if (!canBeAnonymous(cls)) {
			return;
		}
		MethodNode anonymousConstructor = ListUtils.filterOnlyOne(cls.getMethods(), MethodNode::isConstructor);
		if (anonymousConstructor == null) {
			return;
		}
		InlineType inlineType = checkUsage(cls, anonymousConstructor);
		if (inlineType == null) {
			return;
		}
		ArgType baseType = getBaseType(cls);
		if (baseType == null) {
			return;
		}
		ClassNode outerCls;
		if (inlineType == InlineType.INSTANCE_FIELD) {
			outerCls = cls.getUseInMth().get(0).getParentClass();
		} else {
			outerCls = anonymousConstructor.getUseIn().get(0).getParentClass();
		}
		outerCls.addInlinedClass(cls);
		cls.addAttr(new AnonymousClassAttr(outerCls, baseType, inlineType));
		cls.add(AFlag.DONT_GENERATE);
		anonymousConstructor.add(AFlag.ANONYMOUS_CONSTRUCTOR);
		ClassNode topOuterCls = outerCls.getTopParentClass();
		cls.removeDependency(topOuterCls);
		ListUtils.safeRemove(outerCls.getUseIn(), cls);
		if (cls.isTopClass()) {
			topOuterCls.removeDependency(cls);
			topOuterCls.addCodegenDep(cls);
		}
	}
	private static void undoAnonymousMark(ClassNode cls) {
		AnonymousClassAttr attr = cls.get(AType.ANONYMOUS_CLASS);
		ClassNode outerCls = attr.getOuterCls();
		cls.setDependencies(ListUtils.safeAdd(cls.getDependencies(), outerCls.getTopParentClass()));
		outerCls.setUseIn(ListUtils.safeAdd(outerCls.getUseIn(), cls));
		cls.remove(AType.ANONYMOUS_CLASS);
		cls.remove(AFlag.DONT_GENERATE);
		for (MethodNode mth : cls.getMethods()) {
			if (mth.isConstructor()) {
				mth.remove(AFlag.ANONYMOUS_CONSTRUCTOR);
			}
		}
		cls.addDebugComment("Anonymous mark cleared");
	}
	private void mergeAnonymousDeps(RootNode root) {
		Map<ClassNode, ClassNode> inlineMap = new HashMap<>();
		Map<ClassNode, List<ClassNode>> useMap = new HashMap<>();
		for (ClassNode anonymousCls : root.getClasses()) {
			AnonymousClassAttr attr = anonymousCls.get(AType.ANONYMOUS_CLASS);
			if (attr != null) {
				ClassNode outerCls = attr.getOuterCls();
				List<ClassNode> list = useMap.get(outerCls);
				if (list == null || list.isEmpty()) {
					list = new ArrayList<>(2);
					useMap.put(outerCls, list);
				}
				list.add(anonymousCls);
				useMap.putIfAbsent(anonymousCls, Collections.emptyList()); 
				inlineMap.put(anonymousCls, outerCls);
			}
		}
		if (inlineMap.isEmpty()) {
			return;
		}
		Set<ClassNode> added = new HashSet<>();
		useMap.forEach((key, list) -> {
			if (list.isEmpty()) {
				added.clear();
				updateDeps(key, inlineMap, added);
			}
		});
		for (ClassNode cls : root.getClasses()) {
			List<ClassNode> deps = cls.getCodegenDeps();
			if (deps.size() > 1) {
				added.clear();
				added.addAll(deps);
				deps.clear();
				deps.addAll(added);
				Collections.sort(deps);
			}
		}
	}
	private void updateDeps(ClassNode leafCls, Map<ClassNode, ClassNode> inlineMap, Set<ClassNode> added) {
		ClassNode topNode;
		ClassNode current = leafCls;
		while (true) {
			if (!added.add(current)) {
				current.addWarnComment("Loop in anonymous inline: " + current + ", path: " + added);
				added.forEach(ProcessAnonymous::undoAnonymousMark);
				return;
			}
			ClassNode next = inlineMap.get(current);
			if (next == null) {
				topNode = current.getTopParentClass();
				break;
			}
			current = next;
		}
		if (added.size() <= 2) {
			return;
		}
		List<ClassNode> deps = topNode.getCodegenDeps();
		if (deps.isEmpty()) {
			deps = new ArrayList<>(added.size());
			topNode.setCodegenDeps(deps);
		}
		for (ClassNode add : added) {
			deps.add(add.getTopParentClass());
		}
	}
	private static boolean canBeAnonymous(ClassNode cls) {
		if (cls.getAccessFlags().isSynthetic()) {
			return true;
		}
		String shortName = cls.getClassInfo().getShortName();
		if (shortName.contains("$") || Character.isDigit(shortName.charAt(0))) {
			return true;
		}
		if (cls.getUseIn().size() == 1 && cls.getUseInMth().size() == 1) {
			MethodNode useMth = cls.getUseInMth().get(0);
			return useMth.getMethodInfo().isClassInit() && useMth.getParentClass().isEnum();
		}
		return false;
	}
	private static InlineType checkUsage(ClassNode cls, MethodNode ctr) {
		if (ctr.getUseIn().size() != 1) {
			if (!checkForCommonFieldInit(ctr)) {
				return null;
			}
		}
		MethodNode ctrUseMth = ctr.getUseIn().get(0);
		ClassNode ctrUseCls = ctrUseMth.getParentClass();
		if (ctrUseCls.equals(cls)) {
			if (checkForInstanceFieldUsage(cls, ctr)) {
				return InlineType.INSTANCE_FIELD;
			}
			return null;
		}
		if (ctrUseCls.getTopParentClass().equals(cls)) {
			return null;
		}
		if (!checkMethodsUsage(cls, ctr, ctrUseMth)) {
			return null;
		}
		for (FieldNode field : cls.getFields()) {
			for (MethodNode useMth : field.getUseIn()) {
				if (badMethodUsage(cls, useMth, field.getAccessFlags())) {
					return null;
				}
			}
		}
		return InlineType.CONSTRUCTOR;
	}
	private static boolean checkMethodsUsage(ClassNode cls, MethodNode ctr, MethodNode ctrUseMth) {
		for (MethodNode mth : cls.getMethods()) {
			if (mth == ctr) {
				continue;
			}
			for (MethodNode useMth : mth.getUseIn()) {
				if (useMth.equals(ctrUseMth)) {
					continue;
				}
				if (badMethodUsage(cls, useMth, mth.getAccessFlags())) {
					return false;
				}
			}
		}
		return true;
	}
	private static boolean checkForInstanceFieldUsage(ClassNode cls, MethodNode ctr) {
		MethodNode ctrUseMth = ctr.getUseIn().get(0);
		if (!ctrUseMth.getMethodInfo().isClassInit()) {
			return false;
		}
		if (cls.getUseInMth().isEmpty()) {
			return false;
		}
		FieldNode instFld = ListUtils.filterOnlyOne(cls.getFields(),
				f -> f.getAccessFlags().containsFlags(AccessFlags.PUBLIC, AccessFlags.STATIC, AccessFlags.FINAL)
						&& f.getFieldInfo().getType().equals(cls.getClassInfo().getType()));
		if (instFld == null) {
			return false;
		}
		List<MethodNode> instFldUseIn = instFld.getUseIn();
		if (instFldUseIn.size() != 2
				|| !instFldUseIn.contains(ctrUseMth) 
				|| !instFldUseIn.containsAll(cls.getUseInMth()) 
		) {
			return false;
		}
		if (!checkMethodsUsage(cls, ctr, ctrUseMth)) {
			return false;
		}
		for (FieldNode field : cls.getFields()) {
			if (field == instFld) {
				continue;
			}
			for (MethodNode useMth : field.getUseIn()) {
				if (badMethodUsage(cls, useMth, field.getAccessFlags())) {
					return false;
				}
			}
		}
		instFld.add(AFlag.INLINE_INSTANCE_FIELD);
		return true;
	}
	private static boolean badMethodUsage(ClassNode cls, MethodNode useMth, AccessInfo accessFlags) {
		ClassNode useCls = useMth.getParentClass();
		if (useCls.equals(cls)) {
			return false;
		}
		if (accessFlags.isSynthetic()) {
			return !useCls.getParentClass().equals(cls);
		}
		return true;
	}
	private static boolean checkForCommonFieldInit(MethodNode ctrMth) {
		List<MethodNode> ctrUse = ctrMth.getUseIn();
		if (ctrUse.isEmpty()) {
			return false;
		}
		ClassNode firstUseCls = ctrUse.get(0).getParentClass();
		return ListUtils.allMatch(ctrUse, m -> m.isConstructor() && m.getParentClass().equals(firstUseCls));
	}
	@Nullable
	private static ArgType getBaseType(ClassNode cls) {
		int interfacesCount = cls.getInterfaces().size();
		if (interfacesCount > 1) {
			return null;
		}
		ArgType superCls = cls.getSuperClass();
		if (superCls == null || superCls.equals(ArgType.OBJECT)) {
			if (interfacesCount == 1) {
				return cls.getInterfaces().get(0);
			}
			return ArgType.OBJECT;
		}
		if (interfacesCount == 0) {
			return superCls;
		}
		ArgType interfaceType = cls.getInterfaces().get(0);
		if (cls.root().getClsp().isImplements(superCls.getObject(), interfaceType.getObject())) {
			return superCls;
		}
		if (cls.root().getArgs().isAllowInlineKotlinLambda()) {
			if (superCls.getObject().equals("kotlin.jvm.internal.Lambda")) {
				return interfaceType;
			}
		}
		return null;
	}
	@Override
	public String getName() {
		return "ProcessAnonymous";
	}
}
_______
package jadx.core.dex.visitors;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import jadx.api.plugins.input.data.AccessFlags;
import jadx.api.plugins.input.data.attributes.JadxAttrType;
import jadx.core.Consts;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.attributes.AType;
import jadx.core.dex.attributes.nodes.FieldReplaceAttr;
import jadx.core.dex.attributes.nodes.MethodReplaceAttr;
import jadx.core.dex.attributes.nodes.RenameReasonAttr;
import jadx.core.dex.attributes.nodes.SkipMethodArgsAttr;
import jadx.core.dex.info.AccessInfo;
import jadx.core.dex.info.ClassInfo;
import jadx.core.dex.info.FieldInfo;
import jadx.core.dex.info.MethodInfo;
import jadx.core.dex.instructions.IndexInsnNode;
import jadx.core.dex.instructions.InsnType;
import jadx.core.dex.instructions.InvokeNode;
import jadx.core.dex.instructions.InvokeType;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.instructions.args.InsnArg;
import jadx.core.dex.instructions.args.InsnWrapArg;
import jadx.core.dex.instructions.args.RegisterArg;
import jadx.core.dex.instructions.args.SSAVar;
import jadx.core.dex.instructions.mods.ConstructorInsn;
import jadx.core.dex.nodes.BlockNode;
import jadx.core.dex.nodes.ClassNode;
import jadx.core.dex.nodes.FieldNode;
import jadx.core.dex.nodes.InsnNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.visitors.fixaccessmodifiers.FixAccessModifiers;
import jadx.core.dex.visitors.usage.UsageInfoVisitor;
import jadx.core.utils.BlockUtils;
import jadx.core.utils.InsnRemover;
import jadx.core.utils.exceptions.JadxException;
@JadxVisitor(
		name = "ClassModifier",
		desc = "Remove synthetic classes, methods and fields",
		runAfter = {
				ModVisitor.class,
				FixAccessModifiers.class,
				ProcessAnonymous.class
		}
)
public class ClassModifier extends AbstractVisitor {
	@Override
	public boolean visit(ClassNode cls) throws JadxException {
		if (cls.contains(AFlag.PACKAGE_INFO)) {
			return false;
		}
		for (ClassNode inner : cls.getInnerClasses()) {
			visit(inner);
		}
		if (isEmptySyntheticClass(cls)) {
			cls.add(AFlag.DONT_GENERATE);
			return false;
		}
		removeSyntheticFields(cls);
		cls.getMethods().forEach(ClassModifier::removeSyntheticMethods);
		cls.getMethods().forEach(ClassModifier::removeEmptyMethods);
		return false;
	}
	private static boolean isEmptySyntheticClass(ClassNode cls) {
		return cls.getAccessFlags().isSynthetic()
				&& cls.getFields().isEmpty()
				&& cls.getMethods().isEmpty()
				&& cls.getInnerClasses().isEmpty();
	}
	private static void removeSyntheticFields(ClassNode cls) {
		boolean inline = cls.isAnonymous();
		if (inline || cls.getClassInfo().isInner()) {
			for (FieldNode field : cls.getFields()) {
				ArgType fldType = field.getType();
				if (field.getAccessFlags().isSynthetic() && fldType.isObject() && !fldType.isGenericType()) {
					ClassInfo clsInfo = ClassInfo.fromType(cls.root(), fldType);
					ClassNode fieldsCls = cls.root().resolveClass(clsInfo);
					ClassInfo parentClass = cls.getClassInfo().getParentClass();
					if (fieldsCls == null) {
						continue;
					}
					boolean isParentInst = Objects.equals(parentClass, fieldsCls.getClassInfo());
					if (inline || isParentInst) {
						int found = 0;
						for (MethodNode mth : cls.getMethods()) {
							if (removeFieldUsageFromConstructor(mth, field, fieldsCls)) {
								found++;
							}
						}
						if (found != 0) {
							if (isParentInst) {
								field.addAttr(new FieldReplaceAttr(fieldsCls.getClassInfo()));
							}
							field.add(AFlag.DONT_GENERATE);
						}
					}
				}
			}
		}
	}
	private static boolean removeFieldUsageFromConstructor(MethodNode mth, FieldNode field, ClassNode fieldsCls) {
		if (mth.isNoCode() || !mth.getAccessFlags().isConstructor()) {
			return false;
		}
		List<RegisterArg> args = mth.getArgRegs();
		if (args.isEmpty() || mth.contains(AFlag.SKIP_FIRST_ARG)) {
			return false;
		}
		RegisterArg arg = args.get(0);
		if (!arg.getType().equals(fieldsCls.getClassInfo().getType())) {
			return false;
		}
		BlockNode block = mth.getEnterBlock().getCleanSuccessors().get(0);
		List<InsnNode> instructions = block.getInstructions();
		if (instructions.isEmpty()) {
			return false;
		}
		InsnNode insn = instructions.get(0);
		if (insn.getType() != InsnType.IPUT) {
			return false;
		}
		IndexInsnNode putInsn = (IndexInsnNode) insn;
		FieldInfo fieldInfo = (FieldInfo) putInsn.getIndex();
		if (!fieldInfo.equals(field.getFieldInfo()) || !putInsn.getArg(0).equals(arg)) {
			return false;
		}
		mth.skipFirstArgument();
		InsnRemover.remove(mth, block, insn);
		if (arg.getSVar().getUseCount() != 0) {
			InsnNode iget = new IndexInsnNode(InsnType.IGET, fieldInfo, 1);
			iget.addArg(insn.getArg(1));
			for (InsnArg insnArg : new ArrayList<>(arg.getSVar().getUseList())) {
				insnArg.wrapInstruction(mth, iget);
			}
		}
		return true;
	}
	private static void removeSyntheticMethods(MethodNode mth) {
		if (mth.isNoCode() || mth.contains(AFlag.DONT_GENERATE)) {
			return;
		}
		AccessInfo af = mth.getAccessFlags();
		if (!af.isSynthetic()) {
			return;
		}
		ClassNode cls = mth.getParentClass();
		if (removeBridgeMethod(cls, mth)) {
			if (Consts.DEBUG) {
				mth.addDebugComment("Removed as synthetic bridge method");
			} else {
				mth.add(AFlag.DONT_GENERATE);
			}
			return;
		}
		if (mth.isConstructor()
				&& (mth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE) || mth.contains(AFlag.ANONYMOUS_CONSTRUCTOR))) {
			InsnNode insn = BlockUtils.getOnlyOneInsnFromMth(mth);
			if (insn != null) {
				List<RegisterArg> args = mth.getArgRegs();
				if (isRemovedClassInArgs(cls, args)) {
					modifySyntheticMethod(cls, mth, insn, args);
				}
			}
		}
	}
	private static boolean isRemovedClassInArgs(ClassNode cls, List<RegisterArg> mthArgs) {
		boolean removedFound = false;
		for (RegisterArg arg : mthArgs) {
			ArgType argType = arg.getType();
			if (!argType.isObject()) {
				continue;
			}
			boolean remove = false;
			ClassNode argCls = cls.root().resolveClass(argType);
			if (argCls == null) {
				ClassInfo argClsInfo = ClassInfo.fromType(cls.root(), argType);
				if (argClsInfo.getParentClass() != null
						&& cls.getFullName().startsWith(argClsInfo.getParentClass().getFullName())) {
					remove = true;
				}
			} else {
				if (argCls.contains(AFlag.DONT_GENERATE) || isEmptySyntheticClass(argCls)) {
					remove = true;
				}
			}
			if (remove) {
				arg.add(AFlag.REMOVE);
				removedFound = true;
			}
		}
		return removedFound;
	}
	private static void modifySyntheticMethod(ClassNode cls, MethodNode mth, InsnNode insn, List<RegisterArg> args) {
		if (insn.getType() == InsnType.CONSTRUCTOR) {
			ConstructorInsn constr = (ConstructorInsn) insn;
			if (constr.isThis() && !args.isEmpty()) {
				RegisterArg firstArg = args.get(0);
				if (firstArg.getType().equals(cls.getParentClass().getClassInfo().getType())) {
					SkipMethodArgsAttr.skipArg(mth, 0);
				}
				int argsCount = args.size();
				for (int i = 0; i < argsCount; i++) {
					RegisterArg arg = args.get(i);
					SSAVar sVar = arg.getSVar();
					if (sVar != null && sVar.getUseCount() == 0) {
						SkipMethodArgsAttr.skipArg(mth, i);
					}
				}
				MethodInfo callMth = constr.getCallMth();
				MethodNode callMthNode = cls.root().resolveMethod(callMth);
				if (callMthNode != null) {
					mth.addAttr(new MethodReplaceAttr(callMthNode));
					mth.add(AFlag.DONT_GENERATE);
					UsageInfoVisitor.replaceMethodUsage(callMthNode, mth);
				}
			}
		}
	}
	private static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {
		if (cls.root().getArgs().isInlineMethods()) { 
			List<InsnNode> allInsns = BlockUtils.collectAllInsns(mth.getBasicBlocks());
			if (allInsns.size() == 1) {
				InsnNode wrappedInsn = allInsns.get(0);
				if (wrappedInsn.getType() == InsnType.RETURN) {
					InsnArg arg = wrappedInsn.getArg(0);
					if (arg.isInsnWrap()) {
						wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();
					}
				}
				return checkSyntheticWrapper(mth, wrappedInsn);
			}
		}
		return false;
	}
	private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {
		InsnType insnType = insn.getType();
		if (insnType != InsnType.INVOKE) {
			return false;
		}
		InvokeNode invokeInsn = (InvokeNode) insn;
		if (invokeInsn.getInvokeType() == InvokeType.SUPER) {
			return false;
		}
		MethodInfo callMth = invokeInsn.getCallMth();
		MethodNode wrappedMth = mth.root().resolveMethod(callMth);
		if (wrappedMth == null) {
			return false;
		}
		AccessInfo wrappedAccFlags = wrappedMth.getAccessFlags();
		if (wrappedAccFlags.isStatic()) {
			return false;
		}
		if (callMth.getArgsCount() != mth.getMethodInfo().getArgsCount()) {
			return false;
		}
		if (!mth.getParentClass().equals(wrappedMth.getParentClass())) {
			return false;
		}
		for (InsnArg arg : insn.getArguments()) {
			if (!registersAndCastsOnly(arg)) {
				return false;
			}
		}
		if (!wrappedAccFlags.isPublic() && !mth.root().getArgs().isRespectBytecodeAccModifiers()) {
			FixAccessModifiers.changeVisibility(wrappedMth, AccessFlags.PUBLIC);
		}
		String alias = mth.getAlias();
		if (!Objects.equals(wrappedMth.getAlias(), alias)) {
			wrappedMth.rename(alias);
			RenameReasonAttr.forNode(wrappedMth).append("merged with bridge method [inline-methods]");
		}
		wrappedMth.addAttr(new MethodReplaceAttr(mth));
		wrappedMth.copyAttributeFrom(mth, AType.METHOD_OVERRIDE);
		wrappedMth.addDebugComment("Method merged with bridge method: " + mth.getMethodInfo().getShortId());
		return true;
	}
	private static boolean registersAndCastsOnly(InsnArg arg) {
		if (arg.isRegister()) {
			return true;
		}
		if (arg.isInsnWrap()) {
			InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();
			if (wrapInsn.getType() == InsnType.CHECK_CAST) {
				return registersAndCastsOnly(wrapInsn.getArg(0));
			}
		}
		return false;
	}
	private static void removeEmptyMethods(MethodNode mth) {
		if (!mth.getArgRegs().isEmpty()) {
			return;
		}
		AccessInfo af = mth.getAccessFlags();
		boolean publicConstructor = mth.isConstructor() && af.isPublic();
		boolean clsInit = mth.getMethodInfo().isClassInit() && af.isStatic();
		if (publicConstructor || clsInit) {
			if (!BlockUtils.isAllBlocksEmpty(mth.getBasicBlocks())) {
				return;
			}
			if (clsInit) {
				mth.add(AFlag.DONT_GENERATE);
			} else {
				if (mth.isDefaultConstructor()
						&& !isNonDefaultConstructorExists(mth)
						&& !mth.contains(JadxAttrType.ANNOTATION_LIST)) {
					mth.add(AFlag.DONT_GENERATE);
				}
			}
		}
	}
	private static boolean isNonDefaultConstructorExists(MethodNode defCtor) {
		ClassNode parentClass = defCtor.getParentClass();
		for (MethodNode mth : parentClass.getMethods()) {
			if (mth != defCtor
					&& mth.isConstructor()
					&& !mth.isDefaultConstructor()) {
				return true;
			}
		}
		return false;
	}
}
_______
package jadx.core;
public class Consts {
	public static final boolean DEBUG = false;
	public static final boolean DEBUG_WITH_ERRORS = false; 
	public static final boolean DEBUG_USAGE = false;
	public static final boolean DEBUG_TYPE_INFERENCE = false;
	public static final boolean DEBUG_OVERLOADED_CASTS = false;
	public static final boolean DEBUG_EXC_HANDLERS = false;
	public static final boolean DEBUG_FINALLY = false;
	public static final boolean DEBUG_ATTRIBUTES = false;
	public static final boolean DEBUG_RESTRUCTURE = false;
	public static final boolean DEBUG_EVENTS = Jadx.isDevVersion();
	public static final String CLASS_OBJECT = "java.lang.Object";
	public static final String CLASS_STRING = "java.lang.String";
	public static final String CLASS_CLASS = "java.lang.Class";
	public static final String CLASS_THROWABLE = "java.lang.Throwable";
	public static final String CLASS_EXCEPTION = "java.lang.Exception";
	public static final String CLASS_ENUM = "java.lang.Enum";
	public static final String CLASS_STRING_BUILDER = "java.lang.StringBuilder";
	public static final String OVERRIDE_ANNOTATION = "Ljava/lang/Override;";
	public static final String DEFAULT_PACKAGE_NAME = "defpackage";
	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";
	public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";
	private Consts() {
	}
}
_______
package jadx.core.dex.visitors;
import java.util.ArrayList;
import java.util.List;
import jadx.core.dex.attributes.AFlag;
import jadx.core.dex.info.MethodInfo;
import jadx.core.dex.instructions.BaseInvokeNode;
import jadx.core.dex.instructions.ConstStringNode;
import jadx.core.dex.instructions.IndexInsnNode;
import jadx.core.dex.instructions.InsnType;
import jadx.core.dex.instructions.InvokeNode;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.instructions.args.InsnArg;
import jadx.core.dex.instructions.args.LiteralArg;
import jadx.core.dex.instructions.args.PrimitiveType;
import jadx.core.dex.instructions.args.RegisterArg;
import jadx.core.dex.instructions.args.SSAVar;
import jadx.core.dex.instructions.mods.ConstructorInsn;
import jadx.core.dex.nodes.BlockNode;
import jadx.core.dex.nodes.IFieldInfoRef;
import jadx.core.dex.nodes.InsnNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.visitors.finaly.MarkFinallyVisitor;
import jadx.core.dex.visitors.ssa.SSATransform;
import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;
import jadx.core.utils.InsnRemover;
import jadx.core.utils.exceptions.JadxException;
import jadx.core.utils.exceptions.JadxRuntimeException;
@JadxVisitor(
		name = "Constants Inline",
		desc = "Inline constant registers into instructions",
		runAfter = {
				SSATransform.class,
				MarkFinallyVisitor.class
		},
		runBefore = TypeInferenceVisitor.class
)
public class ConstInlineVisitor extends AbstractVisitor {
	@Override
	public void visit(MethodNode mth) throws JadxException {
		if (mth.isNoCode()) {
			return;
		}
		process(mth);
	}
	public static void process(MethodNode mth) {
		List<InsnNode> toRemove = new ArrayList<>();
		for (BlockNode block : mth.getBasicBlocks()) {
			toRemove.clear();
			for (InsnNode insn : block.getInstructions()) {
				checkInsn(mth, insn, toRemove);
			}
			InsnRemover.removeAllAndUnbind(mth, block, toRemove);
		}
	}
	private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRemove) {
		if (insn.contains(AFlag.DONT_INLINE)
				|| insn.contains(AFlag.DONT_GENERATE)
				|| insn.getResult() == null) {
			return;
		}
		SSAVar sVar = insn.getResult().getSVar();
		InsnArg constArg;
		Runnable onSuccess = null;
		switch (insn.getType()) {
			case CONST:
			case MOVE: {
				constArg = insn.getArg(0);
				if (!constArg.isLiteral()) {
					return;
				}
				if (constArg.isZeroLiteral() && forbidNullInlines(sVar)) {
					return;
				}
				break;
			}
			case CONST_STR: {
				String s = ((ConstStringNode) insn).getString();
				IFieldInfoRef f = mth.getParentClass().getConstField(s);
				if (f == null) {
					InsnNode copy = insn.copyWithoutResult();
					constArg = InsnArg.wrapArg(copy);
				} else {
					InsnNode constGet = new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0);
					constArg = InsnArg.wrapArg(constGet);
					constArg.setType(ArgType.STRING);
					onSuccess = () -> ModVisitor.addFieldUsage(f, mth);
				}
				break;
			}
			case CONST_CLASS: {
				if (sVar.isUsedInPhi()) {
					return;
				}
				constArg = InsnArg.wrapArg(insn.copyWithoutResult());
				constArg.setType(ArgType.CLASS);
				break;
			}
			default:
				return;
		}
		if (replaceConst(mth, insn, constArg)) {
			toRemove.add(insn);
			if (onSuccess != null) {
				onSuccess.run();
			}
		}
	}
	private static boolean forbidNullInlines(SSAVar sVar) {
		List<RegisterArg> useList = sVar.getUseList();
		if (useList.isEmpty()) {
			return false;
		}
		int k = 0;
		for (RegisterArg useArg : useList) {
			InsnNode insn = useArg.getParentInsn();
			if (insn != null && forbidNullArgInline(insn, useArg)) {
				k++;
			}
		}
		return k == useList.size();
	}
	private static boolean forbidNullArgInline(InsnNode insn, RegisterArg useArg) {
		if (insn.getType() == InsnType.MOVE) {
			return forbidNullInlines(insn.getResult().getSVar());
		}
		if (!canUseNull(insn, useArg)) {
			useArg.add(AFlag.DONT_INLINE_CONST);
			return true;
		}
		return false;
	}
	private static boolean canUseNull(InsnNode insn, RegisterArg useArg) {
		switch (insn.getType()) {
			case INVOKE:
				return ((InvokeNode) insn).getInstanceArg() != useArg;
			case ARRAY_LENGTH:
			case AGET:
			case APUT:
			case IGET:
			case SWITCH:
			case MONITOR_ENTER:
			case MONITOR_EXIT:
			case INSTANCE_OF:
				return insn.getArg(0) != useArg;
			case IPUT:
				return insn.getArg(1) != useArg;
		}
		return true;
	}
	private static boolean replaceConst(MethodNode mth, InsnNode constInsn, InsnArg constArg) {
		SSAVar ssaVar = constInsn.getResult().getSVar();
		if (ssaVar.getUseCount() == 0) {
			return true;
		}
		List<RegisterArg> useList = new ArrayList<>(ssaVar.getUseList());
		int replaceCount = 0;
		for (RegisterArg arg : useList) {
			if (canInline(mth, arg) && replaceArg(mth, arg, constArg, constInsn)) {
				replaceCount++;
			}
		}
		if (replaceCount == useList.size()) {
			return true;
		}
		if (ssaVar.getUseList().stream().allMatch(ConstInlineVisitor::canIgnoreInsn)) {
			constInsn.add(AFlag.DONT_GENERATE);
		}
		return false;
	}
	private static boolean canIgnoreInsn(RegisterArg reg) {
		InsnNode parentInsn = reg.getParentInsn();
		if (parentInsn == null || parentInsn.getType() == InsnType.PHI) {
			return false;
		}
		if (reg.isLinkedToOtherSsaVars()) {
			return false;
		}
		return parentInsn.contains(AFlag.DONT_GENERATE);
	}
	@SuppressWarnings("RedundantIfStatement")
	private static boolean canInline(MethodNode mth, RegisterArg arg) {
		if (arg.contains(AFlag.DONT_INLINE_CONST) || arg.contains(AFlag.DONT_INLINE)) {
			return false;
		}
		InsnNode parentInsn = arg.getParentInsn();
		if (parentInsn == null) {
			return false;
		}
		if (parentInsn.contains(AFlag.DONT_GENERATE)) {
			return false;
		}
		if (arg.isLinkedToOtherSsaVars() && !arg.getSVar().isUsedInPhi()) {
			return false;
		}
		if (parentInsn.getType() == InsnType.CONSTRUCTOR) {
			MethodNode ctrMth = mth.root().getMethodUtils().resolveMethod((ConstructorInsn) parentInsn);
			if (ctrMth != null
					&& (ctrMth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE) || ctrMth.contains(AFlag.ANONYMOUS_CONSTRUCTOR))) {
				return false;
			}
		}
		return true;
	}
	private static boolean replaceArg(MethodNode mth, RegisterArg arg, InsnArg constArg, InsnNode constInsn) {
		InsnNode useInsn = arg.getParentInsn();
		if (useInsn == null) {
			return false;
		}
		InsnType insnType = useInsn.getType();
		if (insnType == InsnType.PHI) {
			return false;
		}
		if (constArg.isLiteral()) {
			long literal = ((LiteralArg) constArg).getLiteral();
			ArgType argType = arg.getType();
			if (argType == ArgType.UNKNOWN) {
				argType = arg.getInitType();
			}
			if (argType.isObject() && literal != 0) {
				argType = ArgType.NARROW_NUMBERS;
			}
			LiteralArg litArg = InsnArg.lit(literal, argType);
			litArg.copyAttributesFrom(constArg);
			if (!useInsn.replaceArg(arg, litArg)) {
				return false;
			}
			IFieldInfoRef fieldNode = null;
			ArgType litArgType = litArg.getType();
			if (litArgType.isTypeKnown()) {
				fieldNode = mth.getParentClass().getConstFieldByLiteralArg(litArg);
			} else if (litArgType.contains(PrimitiveType.INT)) {
				fieldNode = mth.getParentClass().getConstField((int) literal, false);
			}
			if (fieldNode != null) {
				IndexInsnNode sgetInsn = new IndexInsnNode(InsnType.SGET, fieldNode.getFieldInfo(), 0);
				if (litArg.wrapInstruction(mth, sgetInsn) != null) {
					ModVisitor.addFieldUsage(fieldNode, mth);
				}
			} else {
				addExplicitCast(useInsn, litArg);
			}
		} else {
			if (!useInsn.replaceArg(arg, constArg.duplicate())) {
				return false;
			}
		}
		useInsn.inheritMetadata(constInsn);
		return true;
	}
	private static void addExplicitCast(InsnNode insn, LiteralArg arg) {
		if (insn instanceof BaseInvokeNode) {
			BaseInvokeNode callInsn = (BaseInvokeNode) insn;
			MethodInfo callMth = callInsn.getCallMth();
			if (callInsn.getInstanceArg() == arg) {
				if (!arg.isZeroLiteral()) {
					throw new JadxRuntimeException("Unexpected instance arg in invoke");
				}
				ArgType castType = callMth.getDeclClass().getType();
				InsnNode castInsn = new IndexInsnNode(InsnType.CAST, castType, 1);
				castInsn.addArg(arg);
				castInsn.add(AFlag.EXPLICIT_CAST);
				InsnArg wrapCast = InsnArg.wrapArg(castInsn);
				wrapCast.setType(castType);
				insn.replaceArg(arg, wrapCast);
			} else {
				int offset = callInsn.getFirstArgOffset();
				int argIndex = insn.getArgIndex(arg);
				ArgType argType = callMth.getArgumentsTypes().get(argIndex - offset);
				if (argType.isPrimitive()) {
					arg.setType(argType);
					if (argType.equals(ArgType.BYTE)) {
						arg.add(AFlag.EXPLICIT_PRIMITIVE_TYPE);
					}
				}
			}
		}
	}
}
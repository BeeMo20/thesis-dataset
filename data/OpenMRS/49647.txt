SEVERITY = 5

package org.openmrs.module;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.SortedMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import org.aopalliance.aop.Advice;
import org.openmrs.GlobalProperty;
import org.openmrs.Privilege;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.context.Context;
import org.openmrs.api.context.Daemon;
import org.openmrs.module.Extension.MEDIA_TYPE;
import org.openmrs.util.CycleException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.Graph;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Advisor;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
import org.springframework.util.StringUtils;
import liquibase.Contexts;
public class ModuleFactory {
	private ModuleFactory() {
	}
	private static final Logger log = LoggerFactory.getLogger(ModuleFactory.class);
	protected static final Cache<String, Module> loadedModules = CacheBuilder.newBuilder()
		.softValues().build();
	protected static final Cache<String, Module> startedModules = CacheBuilder.newBuilder()
		.softValues().build();
	protected static final Map<String, List<Extension>> extensionMap = new HashMap<>();
	protected static final Cache<Module, ModuleClassLoader> moduleClassLoaders = CacheBuilder.newBuilder().weakKeys()
		.softValues().build();
	private static final Map<String, Set<ModuleClassLoader>> providedPackages = new ConcurrentHashMap<>();
	private static final String MODULE_CHANGELOG_FILENAME = "liquibase.xml";
	private static final Cache<String, DaemonToken> daemonTokens = CacheBuilder.newBuilder().softValues().build();
	private static final Set<String> actualStartupOrder = new LinkedHashSet<>();
	public static Module loadModule(File moduleFile) throws ModuleException {
		return loadModule(moduleFile, true);
	}
	public static Module loadModule(File moduleFile, Boolean replaceIfExists) throws ModuleException {
		Module module = new ModuleFileParser(Context.getMessageSourceService()).parse(moduleFile);
		if (module != null) {
			loadModule(module, replaceIfExists);
		}
		return module;
	}
	public static Module loadModule(Module module, Boolean replaceIfExists) throws ModuleException {
		log.debug("Adding module {} to the module queue", module.getName());
		Module oldModule = getLoadedModulesMap().get(module.getModuleId());
		if (oldModule != null) {
			int versionComparison = ModuleUtil.compareVersion(oldModule.getVersion(), module.getVersion());
			if (versionComparison < 0) {
				unloadModule(oldModule);
			} else if (versionComparison == 0) {
				if (replaceIfExists) {
					unloadModule(oldModule);
				} else {
					throw new ModuleException("A module with the same id and version already exists", module.getModuleId());
				}
			} else {
				return oldModule;
			}
		}
		getLoadedModulesMap().put(module.getModuleId(), module);
		return module;
	}
	public static void loadModules() {
		File modulesFolder = ModuleUtil.getModuleRepository();
		log.debug("Loading modules from: {}", modulesFolder.getAbsolutePath());
		File[] files = modulesFolder.listFiles();
		if (modulesFolder.isDirectory() && files != null) {
			loadModules(Arrays.asList(files));
		} else {
			log.error("modules folder: '" + modulesFolder.getAbsolutePath() + "' is not a directory or IO error occurred");
		}
	}
	public static void loadModules(List<File> modulesToLoad) {
		for (File f : modulesToLoad) {
			if (f.exists()) {
				if (!f.getName().startsWith(".")) {
					try {
						Module mod = loadModule(f, true);
						log.debug("Loaded module: " + mod + " successfully");
					}
					catch (Exception e) {
						log.error("Unable to load file in module directory: " + f + ". Skipping file.", e);
					}
				}
			} else {
				log.error("Could not find file in module directory: " + f);
			}
		}
		Map<String, Module> loadedModulesMap = getLoadedModulesMapPackage();
		for (Module m : loadedModulesMap.values()) {
			Map<String, String> startBeforeModules = m.getStartBeforeModulesMap();
			if (startBeforeModules.size() > 0) {
				for (String s : startBeforeModules.keySet()) {
					Module mod = loadedModulesMap.get(s);
					if (mod != null) {
						mod.addRequiredModule(m.getPackageName(), m.getVersion());
					}
				}
			}
		}
	}
	public static void startModules() {
		if (!getLoadedModules().isEmpty()) {
			List<Module> modules = getModulesThatShouldStart();
			try {
				modules = getModulesInStartupOrder(modules);
			}
			catch (CycleException ex) {
				String message = getCyclicDependenciesMessage(ex.getMessage());
				log.error(message, ex);
				notifySuperUsersAboutCyclicDependencies(ex);
				modules = (List<Module>) ex.getExtraData();
			}
			for (Module mod : modules) {
				if (mod.isStarted()) {
					continue;
				}
				if (!requiredModulesStarted(mod)) {
					String message = getFailedToStartModuleMessage(mod);
					log.error(message);
					mod.setStartupErrorMessage(message);
					notifySuperUsersAboutModuleFailure(mod);
					continue;
				}
				try {
					log.debug("starting module: {}", mod.getModuleId());
					startModule(mod);
				}
				catch (Exception e) {
					log.error("Error while starting module: " + mod.getName(), e);
					mod.setStartupErrorMessage("Error while starting module", e);
					notifySuperUsersAboutModuleFailure(mod);
				}
			}
		}
	}
	private static List<Module> getModulesThatShouldStart() {
		List<Module> modules = new ArrayList<>();
		AdministrationService adminService = Context.getAdministrationService();
		for (Module mod : getLoadedModulesCoreFirst()) {
			String key = mod.getModuleId() + ".started";
			String startedProp = adminService.getGlobalProperty(key, null);
			String mandatoryProp = adminService.getGlobalProperty(mod.getModuleId() + ".mandatory", null);
			boolean isCoreToOpenmrs = mod.isCore() && !ModuleUtil.ignoreCoreModules();
			if (startedProp == null || "true".equals(startedProp) || "true".equalsIgnoreCase(mandatoryProp)
				|| mod.isMandatory() || isCoreToOpenmrs) {
				modules.add(mod);
			}
		}
		return modules;
	}
	public static List<Module> getModulesInStartupOrder(Collection<Module> modules) throws CycleException {
		Graph<Module> graph = new Graph<>();
		for (Module mod : modules) {
			graph.addNode(mod);
			for (String key : mod.getRequiredModules()) {
				Module module = getModuleByPackage(key);
				Module fromNode = graph.getNode(module);
				if (fromNode == null) {
					fromNode = module;
				}
				if (fromNode != null) {
					graph.addEdge(graph.new Edge(
						fromNode,
						mod));
				}
			}
			for (String key : mod.getAwareOfModules()) {
				Module module = getModuleByPackage(key);
				Module fromNode = graph.getNode(module);
				if (fromNode == null) {
					fromNode = module;
				}
				if (fromNode != null) {
					graph.addEdge(graph.new Edge(
						fromNode,
						mod));
				}
			}
		}
		return graph.topologicalSort();
	}
	private static void notifySuperUsersAboutModuleFailure(Module mod) {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
			Context.getAlertService().notifySuperUsers("Module.startupError.notification.message", null, mod.getName());
		}
		catch (Exception e) {
			log.error("Unable to send an alert to the super users", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
		}
	}
	private static void notifySuperUsersAboutCyclicDependencies(Exception ex) {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
			Context.getAlertService().notifySuperUsers("Module.error.cyclicDependencies", ex, ex.getMessage());
		}
		catch (Exception e) {
			log.error("Unable to send an alert to the super users", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
		}
	}
	public static List<Module> getLoadedModulesCoreFirst() {
		List<Module> list = new ArrayList<>(getLoadedModules());
		final Collection<String> coreModuleIds = ModuleConstants.CORE_MODULES.keySet();
		list.sort((left, right) -> {
			Integer leftVal = coreModuleIds.contains(left.getModuleId()) ? 0 : 1;
			Integer rightVal = coreModuleIds.contains(right.getModuleId()) ? 0 : 1;
			return leftVal.compareTo(rightVal);
		});
		return list;
	}
	private static List<String> getMissingRequiredModules(Module module) {
		List<String> ret = new ArrayList<>();
		for (String moduleName : module.getRequiredModules()) {
			boolean started = false;
			for (Module mod : getStartedModules()) {
				if (mod.getPackageName().equals(moduleName)) {
					String reqVersion = module.getRequiredModuleVersion(moduleName);
					if (reqVersion == null || ModuleUtil.compareVersion(mod.getVersion(), reqVersion) >= 0) {
						started = true;
					}
					break;
				}
			}
			if (!started) {
				String moduleVersion = module.getRequiredModuleVersion(moduleName);
				moduleName = moduleName.replace("org.openmrs.module.", "").replace("org.openmrs.", "");
				ret.add(moduleName + (moduleVersion != null ? " " + moduleVersion : ""));
			}
		}
		return ret;
	}
	public static Collection<Module> getLoadedModules() {
		if (getLoadedModulesMap().size() > 0) {
			return getLoadedModulesMap().values();
		}
		return Collections.emptyList();
	}
	public static Map<String, Module> getLoadedModulesMap() {
		return loadedModules.asMap();
	}
	public static Map<String, Module> getLoadedModulesMapPackage() {
		Map<String, Module> map = new HashMap<>();
		for (Module loadedModule : getLoadedModulesMap().values()) {
			map.put(loadedModule.getPackageName(), loadedModule);
		}
		return map;
	}
	public static Collection<Module> getStartedModules() {
		if (getStartedModulesMap().size() > 0) {
			return getStartedModulesMap().values();
		}
		return Collections.emptyList();
	}
	public static List<Module> getStartedModulesInOrder() {
		List<Module> modules = new ArrayList<>();
		if (actualStartupOrder != null) {
			for (String moduleId : actualStartupOrder) {
				modules.add(getStartedModulesMap().get(moduleId));
			}
		} else {
			modules.addAll(getStartedModules());
		}
		return modules;
	}
	public static Map<String, Module> getStartedModulesMap() {
		return startedModules.asMap();
	}
	public static Module getModuleById(String moduleId) {
		return getLoadedModulesMap().get(moduleId);
	}
	public static Module getStartedModuleById(String moduleId) {
		return getStartedModulesMap().get(moduleId);
	}
	public static Module getModuleByPackage(String modulePackage) {
		for (Module mod : getLoadedModulesMap().values()) {
			if (mod.getPackageName().equals(modulePackage)) {
				return mod;
			}
		}
		return null;
	}
	public static Module startModule(Module module) throws ModuleException {
		return startModule(module, false, null);
	}
	public static Module startModule(Module module, boolean isOpenmrsStartup,
		AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		if (!requiredModulesStarted(module)) {
			int missingModules = 0;
			for (String packageName : module.getRequiredModulesMap().keySet()) {
				Module mod = getModuleByPackage(packageName);
				if (mod == null) {
					missingModules++;
					continue;
				}
				if (!mod.isStarted()) {
					startModule(mod);
				}
			}
			if (missingModules > 0) {
				String message = getFailedToStartModuleMessage(module);
				log.error(message);
				module.setStartupErrorMessage(message);
				notifySuperUsersAboutModuleFailure(module);
				return module;
			}
		}
		return Daemon.startModule(module, isOpenmrsStartup, applicationContext);
	}
	public static Module startModuleInternal(Module module) throws ModuleException {
		return startModuleInternal(module, false, null);
	}
	public static Module startModuleInternal(Module module, boolean isOpenmrsStartup,
		AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		if (module != null) {
			String moduleId = module.getModuleId();
			try {
				String requireVersion = module.getRequireOpenmrsVersion();
				ModuleUtil.checkRequiredVersion(OpenmrsConstants.OPENMRS_VERSION_SHORT, requireVersion);
				if (!requiredModulesStarted(module)) {
					throw new ModuleException(getFailedToStartModuleMessage(module));
				}
				ModuleClassLoader moduleClassLoader = new ModuleClassLoader(module, ModuleFactory.class.getClassLoader());
				getModuleClassLoaderMap().put(module, moduleClassLoader);
				registerProvidedPackages(moduleClassLoader);
				Map<String, List<Extension>> moduleExtensionMap = new HashMap<>();
				for (Extension ext : module.getExtensions()) {
					String extId = ext.getExtensionId();
					List<Extension> tmpExtensions = moduleExtensionMap.computeIfAbsent(extId, k -> new ArrayList<>());
					tmpExtensions.add(ext);
				}
				Comparator<Extension> sortOrder = (e1, e2) -> Integer.valueOf(e1.getOrder()).compareTo(e2.getOrder());
				for (Map.Entry<String, List<Extension>> moduleExtensionEntry : moduleExtensionMap.entrySet()) {
					List<Extension> sortedModuleExtensions = moduleExtensionEntry.getValue();
					sortedModuleExtensions.sort(sortOrder);
					List<Extension> extensions = getExtensionMap().computeIfAbsent(moduleExtensionEntry.getKey(),
						k -> new ArrayList<>());
					for (Extension ext : sortedModuleExtensions) {
						log.debug("Adding to mapping ext: " + ext.getExtensionId() + " ext.class: " + ext.getClass());
						extensions.add(ext);
					}
				}
				SortedMap<String, String> diffs = SqlDiffFileParser.getSqlDiffs(module);
				try {
					Context.addProxyPrivilege("");
					for (Map.Entry<String, String> entry : diffs.entrySet()) {
						String version = entry.getKey();
						String sql = entry.getValue();
						if (StringUtils.hasText(sql)) {
							runDiff(module, version, sql);
						}
					}
				}
				finally {
					Context.removeProxyPrivilege("");
				}
				runLiquibase(module);
				getStartedModulesMap().put(moduleId, module);
				actualStartupOrder.add(moduleId);
				try {
					saveGlobalProperty(moduleId + ".started", "true", getGlobalPropertyStartedDescription(moduleId));
					saveGlobalProperty(moduleId + ".mandatory", String.valueOf(module.isMandatory()),
						getGlobalPropertyMandatoryModuleDescription(moduleId));
				}
				catch (Exception e) {
					log.debug("Got an error when trying to set the global property on module startup", e);
				}
				if (!module.getPrivileges().isEmpty() || !module.getGlobalProperties().isEmpty()) {
					log.debug("Updating core dataset");
					Context.checkCoreDataset();
				}
				try {
					if (module.getModuleActivator() != null) {
						module.getModuleActivator().willStart();
					}
				}
				catch (ModuleException e) {
					throw e;
				}
				catch (Exception e) {
					throw new ModuleException("Error while calling module's Activator.startup()/willStart() method", e);
				}
				module.clearStartupError();
			}
			catch (Exception e) {
				log.warn("Error while trying to start module: " + moduleId, e);
				module.setStartupErrorMessage("Error while trying to start module", e);
				notifySuperUsersAboutModuleFailure(module);
				try {
					boolean skipOverStartedProperty = false;
					if (e instanceof ModuleMustStartException) {
						skipOverStartedProperty = true;
					}
					stopModule(module, skipOverStartedProperty, true);
				}
				catch (Exception e2) {
					log.debug("Error while stopping module: " + moduleId, e2);
				}
			}
		}
		if (applicationContext != null) {
			ModuleUtil.refreshApplicationContext(applicationContext, isOpenmrsStartup, module);
		}
		return module;
	}
	private static void registerProvidedPackages(ModuleClassLoader moduleClassLoader) {
		for (String providedPackage : moduleClassLoader.getProvidedPackages()) {
			Set<ModuleClassLoader> newSet = new HashSet<>();
			Set<ModuleClassLoader> set = providedPackages.get(providedPackage);
			if (set != null) {
				newSet.addAll(set);
			}
			newSet.add(moduleClassLoader);
			providedPackages.put(providedPackage, newSet);
		}
	}
	private static void unregisterProvidedPackages(ModuleClassLoader moduleClassLoader) {
		for (String providedPackage : moduleClassLoader.getProvidedPackages()) {
			Set<ModuleClassLoader> newSet = new HashSet<>();
			Set<ModuleClassLoader> set = providedPackages.get(providedPackage);
			if (set != null) {
				newSet.addAll(set);
			}
			newSet.remove(moduleClassLoader);
			providedPackages.put(providedPackage, newSet);
		}
	}
	public static Set<ModuleClassLoader> getModuleClassLoadersForPackage(String packageName) {
		Set<ModuleClassLoader> set = providedPackages.get(packageName);
		if (set == null) {
			return Collections.emptySet();
		} else {
			return new HashSet<>(set);
		}
	}
	private static String getFailedToStartModuleMessage(Module module) {
		String[] params = { module.getName(), String.join(",", getMissingRequiredModules(module)) };
		return Context.getMessageSourceService().getMessage("Module.error.moduleCannotBeStarted", params,
			Context.getLocale());
	}
	private static String getCyclicDependenciesMessage(String message) {
		return Context.getMessageSourceService().getMessage("Module.error.cyclicDependencies", new Object[] { message },
			Context.getLocale());
	}
	public static void loadAdvice(Module module) {
		for (AdvicePoint advice : module.getAdvicePoints()) {
			Class<?> cls;
			try {
				cls = Context.loadClass(advice.getPoint());
				Object aopObject = advice.getClassInstance();
				if (aopObject instanceof Advisor) {
					log.debug("adding advisor [{}]", aopObject.getClass());
					Context.addAdvisor(cls, (Advisor) aopObject);
				} else if (aopObject != null) {
					log.debug("adding advice [{}]", aopObject.getClass());
					Context.addAdvice(cls, (Advice) aopObject);
				} else {
					log.debug("Could not load advice class for {} [{}]", advice.getPoint(), advice.getClassName());
				}
			}
			catch (ClassNotFoundException | NoClassDefFoundError e) {
				log.warn("Could not load advice point [{}]", advice.getPoint(), e);
			}
		}
	}
	private static void runDiff(Module module, String version, String sql) {
		AdministrationService as = Context.getAdministrationService();
		String key = module.getModuleId() + ".database_version";
		GlobalProperty gp = as.getGlobalPropertyObject(key);
		boolean executeSQL = false;
		if (gp != null && StringUtils.hasLength(gp.getPropertyValue())) {
			String currentDbVersion = gp.getPropertyValue();
			if (log.isDebugEnabled()) {
				log.debug("version:column {}:{}", version, currentDbVersion);
				log.debug("compare: {}", ModuleUtil.compareVersion(version, currentDbVersion));
			}
			if (ModuleUtil.compareVersion(version, currentDbVersion) > 0) {
				executeSQL = true;
			}
		} else {
			executeSQL = true;
		}
		if (executeSQL) {
			try {
				Context.addProxyPrivilege(PrivilegeConstants.SQL_LEVEL_ACCESS);
				log.debug("Executing sql: " + sql);
				String[] sqlStatements = sql.split(";");
				for (String sqlStatement : sqlStatements) {
					if (sqlStatement.trim().length() > 0) {
						as.executeSQL(sqlStatement, false);
					}
				}
			}
			finally {
				Context.removeProxyPrivilege(PrivilegeConstants.SQL_LEVEL_ACCESS);
			}
			try {
				Context.addProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
				String description = "DO NOT MODIFY.  Current database version number for the " + module.getModuleId()
					+ " module.";
				if (gp == null) {
					log.info("Global property " + key + " was not found. Creating one now.");
					gp = new GlobalProperty(key, version, description);
					as.saveGlobalProperty(gp);
				} else if (!gp.getPropertyValue().equals(version)) {
					log.info("Updating global property " + key + " to version: " + version);
					gp.setDescription(description);
					gp.setPropertyValue(version);
					as.saveGlobalProperty(gp);
				} else {
					log.error("Should not be here. GP property value and sqldiff version should not be equal");
				}
			}
			finally {
				Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			}
		}
	}
	private static void runLiquibase(Module module) {
		ModuleClassLoader moduleClassLoader = getModuleClassLoader(module);
		boolean liquibaseFileExists = false;
		if (moduleClassLoader != null) {
			try (InputStream inStream = moduleClassLoader.getResourceAsStream(MODULE_CHANGELOG_FILENAME)) {
				liquibaseFileExists = (inStream != null);
			}
			catch (IOException ignored) {
			}
		}
		if (liquibaseFileExists) {
			try {
				DatabaseUpdater.executeChangelog(MODULE_CHANGELOG_FILENAME, new Contexts(), null, moduleClassLoader);
			}
			catch (InputRequiredException e) {
				throw new ModuleException("Input during database updates is not yet implemented.", module.getName(), e);
			}
			catch (Exception e) {
				throw new ModuleException("Unable to update data model using " + MODULE_CHANGELOG_FILENAME + ".",
					module.getName(), e);
			}
		}
	}
	public static void stopModule(Module mod) {
		stopModule(mod, false, false);
	}
	public static void stopModule(Module mod, boolean isShuttingDown) {
		stopModule(mod, isShuttingDown, false);
	}
	public static List<Module> stopModule(Module mod, boolean skipOverStartedProperty, boolean isFailedStartup)
		throws ModuleMustStartException {
		List<Module> dependentModulesStopped = new ArrayList<>();
		if (mod != null) {
			if (!ModuleFactory.isModuleStarted(mod)) {
				return dependentModulesStopped;
			}
			try {
				if (mod.getModuleActivator() != null) {
					mod.getModuleActivator().willStop();
				}
			}
			catch (Exception t) {
				log.warn("Unable to call module's Activator.willStop() method", t);
			}
			String moduleId = mod.getModuleId();
			if (!isFailedStartup && mod.isMandatory()) {
				throw new MandatoryModuleException(moduleId);
			}
			if (!isFailedStartup && ModuleConstants.CORE_MODULES.containsKey(moduleId)) {
				throw new OpenmrsCoreModuleException(moduleId);
			}
			String modulePackage = mod.getPackageName();
			List<Module> startedModulesCopy = new ArrayList<>(getStartedModules());
			for (Module dependentModule : startedModulesCopy) {
				if (dependentModule != null && !dependentModule.equals(mod)
					&& isModuleRequiredByAnother(dependentModule, modulePackage)) {
					dependentModulesStopped.add(dependentModule);
					dependentModulesStopped.addAll(stopModule(dependentModule, skipOverStartedProperty, isFailedStartup));
				}
			}
			getStartedModulesMap().remove(moduleId);
			if (actualStartupOrder != null) {
				actualStartupOrder.remove(moduleId);
				for (Module depModule : dependentModulesStopped) {
					actualStartupOrder.remove(depModule.getModuleId());
				}
			}
			if (!skipOverStartedProperty && !Context.isRefreshingContext()) {
				saveGlobalProperty(moduleId + ".started", "false", getGlobalPropertyStartedDescription(moduleId));
			}
			ModuleClassLoader moduleClassLoader = getModuleClassLoaderMap().get(mod);
			if (moduleClassLoader != null) {
				unregisterProvidedPackages(moduleClassLoader);
				log.debug("Mod was in classloader map.  Removing advice and extensions.");
				try {
					for (AdvicePoint advice : mod.getAdvicePoints()) {
						Class cls;
						try {
							cls = Context.loadClass(advice.getPoint());
							Object aopObject = advice.getClassInstance();
							if (aopObject instanceof Advisor) {
								log.debug("adding advisor: " + aopObject.getClass());
								Context.removeAdvisor(cls, (Advisor) aopObject);
							} else {
								log.debug("Adding advice: " + aopObject.getClass());
								Context.removeAdvice(cls, (Advice) aopObject);
							}
						}
						catch (Exception t) {
							log.warn("Could not remove advice point: " + advice.getPoint(), t);
						}
					}
				}
				catch (Exception t) {
					log.warn("Error while getting advicePoints from module: " + moduleId, t);
				}
				try {
					for (Extension ext : mod.getExtensions()) {
						String extId = ext.getExtensionId();
						try {
							List<Extension> tmpExtensions = getExtensions(extId);
							tmpExtensions.remove(ext);
							getExtensionMap().put(extId, tmpExtensions);
						}
						catch (Exception exterror) {
							log.warn("Error while getting extension: " + ext, exterror);
						}
					}
				}
				catch (Exception t) {
					log.warn("Error while getting extensions from module: " + moduleId, t);
				}
			}
			List<OpenmrsService> services = Context.getModuleOpenmrsServices(modulePackage);
			if (services != null) {
				for (OpenmrsService service : services) {
					service.onShutdown();
				}
			}
			try {
				if (mod.getModuleActivator() != null) {
					mod.getModuleActivator().stopped();
				}
			}
			catch (Exception t) {
				log.warn("Unable to call module's Activator.shutdown() method", t);
			}
			mod.getExtensions().clear();
			mod.setModuleActivator(null);
			mod.disposeAdvicePointsClassInstance();
			ModuleClassLoader cl = removeClassLoader(mod);
			if (cl != null) {
				cl.dispose();
				File folder = OpenmrsClassLoader.getLibCacheFolder();
				File tmpModuleDir = new File(folder, moduleId);
				try {
					OpenmrsUtil.deleteDirectory(tmpModuleDir);
				}
				catch (IOException e) {
					log.warn("Unable to delete libcachefolder for " + moduleId);
				}
			}
		}
		return dependentModulesStopped;
	}
	private static boolean isModuleRequiredByAnother(Module dependentModule, String modulePackage) {
		return dependentModule.getRequiredModules() != null && dependentModule.getRequiredModules().contains(modulePackage);
	}
	private static ModuleClassLoader removeClassLoader(Module mod) {
		ModuleClassLoader cl = moduleClassLoaders.getIfPresent(mod);
		if (cl == null) {
			log.warn("Module: " + mod.getModuleId() + " does not exist");
		}
		moduleClassLoaders.invalidate(mod);
		return cl;
	}
	public static void unloadModule(Module mod) {
		if (isModuleStarted(mod)) {
			stopModule(mod, true);
		}
		getLoadedModules().remove(mod);
		if (mod != null) {
			File file = mod.getFile();
			boolean deleted = file.delete();
			if (!deleted) {
				file.deleteOnExit();
				log.warn("Could not delete " + file.getAbsolutePath());
			}
		}
	}
	public static List<Extension> getExtensions(String pointId) {
		List<Extension> extensions;
		Map<String, List<Extension>> extensionMap = getExtensionMap();
		extensions = extensionMap.get(pointId);
		if (extensions == null) {
			extensions = new ArrayList<>();
		}
		if (!pointId.contains(Extension.EXTENSION_ID_SEPARATOR)) {
			for (MEDIA_TYPE mediaType : Extension.MEDIA_TYPE.values()) {
				List<Extension> tmpExtensions = extensionMap.get(Extension.toExtensionId(pointId, mediaType));
				if (tmpExtensions != null) {
					for (Extension ext : tmpExtensions) {
						if (!extensions.contains(ext)) {
							extensions.add(ext);
						}
					}
				}
			}
		}
		log.debug("Getting extensions defined by : " + pointId);
		return extensions;
	}
	public static List<Extension> getExtensions(String pointId, Extension.MEDIA_TYPE type) {
		String key = Extension.toExtensionId(pointId, type);
		List<Extension> extensions = getExtensionMap().get(key);
		if (extensions != null) {
			log.debug("Getting extensions defined by : " + key);
			return extensions;
		} else {
			return getExtensions(pointId);
		}
	}
	public static List<Privilege> getPrivileges() {
		List<Privilege> privileges = new ArrayList<>();
		for (Module mod : getStartedModules()) {
			privileges.addAll(mod.getPrivileges());
		}
		log.debug(privileges.size() + " new privileges");
		return privileges;
	}
	public static List<GlobalProperty> getGlobalProperties() {
		List<GlobalProperty> globalProperties = new ArrayList<>();
		for (Module mod : getStartedModules()) {
			globalProperties.addAll(mod.getGlobalProperties());
		}
		log.debug(globalProperties.size() + " new global properties");
		return globalProperties;
	}
	public static boolean isModuleStarted(Module mod) {
		return getStartedModulesMap().containsValue(mod);
	}
	public static boolean isModuleStarted(String moduleId) {
		return getStartedModulesMap().containsKey(moduleId);
	}
	public static ModuleClassLoader getModuleClassLoader(Module mod) throws ModuleException {
		ModuleClassLoader mcl = getModuleClassLoaderMap().get(mod);
		if (mcl == null) {
			log.debug("Module classloader not found for module with id: " + mod.getModuleId());
		}
		return mcl;
	}
	public static ModuleClassLoader getModuleClassLoader(String moduleId) throws ModuleException {
		Module mod = getStartedModulesMap().get(moduleId);
		if (mod == null) {
			log.debug("Module id not found in list of started modules: " + moduleId);
		}
		return getModuleClassLoader(mod);
	}
	public static Collection<ModuleClassLoader> getModuleClassLoaders() {
		Map<Module, ModuleClassLoader> classLoaders = getModuleClassLoaderMap();
		if (classLoaders.size() > 0) {
			return classLoaders.values();
		}
		return Collections.emptyList();
	}
	public static Map<Module, ModuleClassLoader> getModuleClassLoaderMap() {
		if (moduleClassLoaders == null) {
			return Collections.emptyMap();
		}
		return moduleClassLoaders.asMap();
	}
	public static Map<String, List<Extension>> getExtensionMap() {
		return extensionMap;
	}
	private static boolean requiredModulesStarted(Module module) {
		for (String reqModPackage : module.getRequiredModules()) {
			boolean started = false;
			for (Module mod : getStartedModules()) {
				if (mod.getPackageName().equals(reqModPackage)) {
					String reqVersion = module.getRequiredModuleVersion(reqModPackage);
					if (reqVersion == null || ModuleUtil.compareVersion(mod.getVersion(), reqVersion) >= 0) {
						started = true;
					}
					break;
				}
			}
			if (!started) {
				return false;
			}
		}
		return true;
	}
	public static Module updateModule(Module mod) throws ModuleException {
		if (mod.getDownloadURL() == null) {
			return mod;
		}
		URL url;
		try {
			url = new URL(mod.getDownloadURL());
		}
		catch (MalformedURLException e) {
			throw new ModuleException("Unable to download module update", e);
		}
		unloadModule(mod);
		InputStream inputStream = ModuleUtil.getURLStream(url);
		log.warn("url pathname: " + url.getPath());
		String filename = url.getPath().substring(url.getPath().lastIndexOf("/"));
		File moduleFile = ModuleUtil.insertModuleFile(inputStream, filename);
		try {
			Module newModule = loadModule(moduleFile);
			startModule(newModule);
			return newModule;
		}
		catch (Exception e) {
			log.warn("Error while unloading old module and loading in new module");
			moduleFile.delete();
			return mod;
		}
	}
	public static boolean isTokenValid(DaemonToken token) {
		if (token == null) {
			return false;
		} else {
			synchronized (daemonTokens) {
				DaemonToken validToken = daemonTokens.getIfPresent(token.getId());
				return validToken != null && validToken == token;
			}
		}
	}
	static void passDaemonToken(Module module) {
		ModuleActivator moduleActivator = module.getModuleActivator();
		if (moduleActivator instanceof DaemonTokenAware) {
			DaemonToken daemonToken = getDaemonToken(module);
			((DaemonTokenAware) module.getModuleActivator()).setDaemonToken(daemonToken);
		}
	}
	private static DaemonToken getDaemonToken(Module module) {
		DaemonToken token;
		try {
			token = daemonTokens.get(module.getModuleId(), () -> new DaemonToken(module.getModuleId()));
		}
		catch (ExecutionException e) {
			throw new APIException(e);
		}
		return token;
	}
	private static String getGlobalPropertyStartedDescription(String moduleId) {
		String ret = "DO NOT MODIFY. true/false whether or not the " + moduleId;
		ret += " module has been started.  This is used to make sure modules that were running ";
		ret += " prior to a restart are started again";
		return ret;
	}
	private static String getGlobalPropertyMandatoryModuleDescription(String moduleId) {
		String ret = "true/false whether or not the " + moduleId;
		ret += " module MUST start when openmrs starts.  This is used to make sure that mission critical";
		ret += " modules are always running if openmrs is running.";
		return ret;
	}
	private static void saveGlobalProperty(String key, String value, String desc) {
		try {
			AdministrationService as = Context.getAdministrationService();
			GlobalProperty gp = as.getGlobalPropertyObject(key);
			if (gp == null) {
				gp = new GlobalProperty(key, value, desc);
			} else {
				gp.setPropertyValue(value);
			}
			as.saveGlobalProperty(gp);
		}
		catch (Exception e) {
			log.warn("Unable to save the global property", e);
		}
	}
	public static List<String> getDependencies(String moduleId) {
		List<String> dependentModules = null;
		Module module = getModuleById(moduleId);
		Map<String, Module> startedModules = getStartedModulesMap();
		String modulePackage = module.getPackageName();
		for (Entry<String, Module> entry : startedModules.entrySet()) {
			if (!moduleId.equals(entry.getKey()) && entry.getValue().getRequiredModules().contains(modulePackage)) {
				if (dependentModules == null) {
					dependentModules = new ArrayList<>();
				}
				dependentModules.add(entry.getKey() + " " + entry.getValue().getVersion());
			}
		}
		return dependentModules;
	}
}
_____
package org.openmrs;
import java.util.Date;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.openmrs.customdatatype.CustomDatatype;
import org.openmrs.customdatatype.CustomDatatypeUtil;
import org.openmrs.customdatatype.CustomValueDescriptor;
import org.openmrs.customdatatype.SingleCustomValue;
@Audited
public class GlobalProperty extends BaseOpenmrsObject implements CustomValueDescriptor, SingleCustomValue<GlobalProperty> {
	private static final long serialVersionUID = 1L;
	private String property = "";
	private String propertyValue = "";
	private transient Object typedValue;
	private boolean dirty = false;
	private String description = "";
	private String datatypeClassname;
	private String datatypeConfig;
	private String preferredHandlerClassname;
	private String handlerConfig;
	private User changedBy;
	private Date dateChanged;
	private Privilege viewPrivilege;
	private Privilege editPrivilege;
	private Privilege deletePrivilege;
	public GlobalProperty() {
	}
	public GlobalProperty(String property) {
		this.property = property;
	}
	public GlobalProperty(String property, String value) {
		this(property);
		this.propertyValue = value;
	}
	public GlobalProperty(String property, String value, String description) {
		this(property, value);
		this.description = description;
	}
	public GlobalProperty(String property, String value, String description,
	    Class<? extends CustomDatatype<?>> datatypeClass, String datatypeConfig) {
		this(property, value, description);
		this.datatypeClassname = datatypeClass.getName();
		this.datatypeConfig = datatypeConfig;
	}
	public String getProperty() {
		return property;
	}
	public void setProperty(String property) {
		this.property = property;
	}
	public String getPropertyValue() {
		return propertyValue;
	}
	public void setPropertyValue(String propertyValue) {
		this.propertyValue = propertyValue;
	}
	public String getDescription() {
		return description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	@Override
	public Integer getId() {
		throw new UnsupportedOperationException();
	}
	@Override
	public void setId(Integer id) {
		throw new UnsupportedOperationException();
	}
	@Override
	public String getDatatypeClassname() {
		return datatypeClassname;
	}
	public void setDatatypeClassname(String datatypeClassname) {
		this.datatypeClassname = datatypeClassname;
	}
	@Override
	public String getDatatypeConfig() {
		return datatypeConfig;
	}
	public void setDatatypeConfig(String datatypeConfig) {
		this.datatypeConfig = datatypeConfig;
	}
	@Override
	public String getPreferredHandlerClassname() {
		return preferredHandlerClassname;
	}
	public void setPreferredHandlerClassname(String preferredHandlerClassname) {
		this.preferredHandlerClassname = preferredHandlerClassname;
	}
	@Override
	public String getHandlerConfig() {
		return handlerConfig;
	}
	public void setHandlerConfig(String handlerConfig) {
		this.handlerConfig = handlerConfig;
	}
	@Override
	public String toString() {
		return "property: " + getProperty() + " value: " + getPropertyValue();
	}
	@Override
	public GlobalProperty getDescriptor() {
		return this;
	}
	@Override
	public String getValueReference() {
		return getPropertyValue();
	}
	@Override
	public void setValueReferenceInternal(String valueToPersist) {
		setPropertyValue(valueToPersist);
	}
	@Override
	public Object getValue() {
		if (typedValue == null) {
			typedValue = CustomDatatypeUtil.getDatatypeOrDefault(this).fromReferenceString(getValueReference());
		}
		return typedValue;
	}
	@Override
	public <T> void setValue(T typedValue){
		this.typedValue = typedValue;
		dirty = true;
	}
	@Deprecated
	@JsonIgnore
	@Override
	public boolean isDirty() {
		return getDirty();
	}
	public boolean getDirty() {
		return dirty;
	}
	public User getChangedBy() {
		return changedBy;
	}
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	public Date getDateChanged() {
		return dateChanged;
	}
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	public Privilege getViewPrivilege() {
		return viewPrivilege;
	}
	public void setViewPrivilege(Privilege viewPrivilege) {
		this.viewPrivilege = viewPrivilege;
	}
	public Privilege getEditPrivilege() {
		return editPrivilege;
	}
	public void setEditPrivilege(Privilege editPrivilege) {
		this.editPrivilege = editPrivilege;
	}
	public Privilege getDeletePrivilege() {
		return deletePrivilege;
	}
	public void setDeletePrivilege(Privilege deletePrivilege) {
		this.deletePrivilege = deletePrivilege;
	}
}
_____
package org.openmrs.util;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import liquibase.GlobalConfiguration;
import org.apache.commons.io.IOUtils;
import org.openmrs.GlobalProperty;
import org.openmrs.api.handler.ExistingVisitAssignmentHandler;
import org.openmrs.customdatatype.datatype.BooleanDatatype;
import org.openmrs.customdatatype.datatype.FreeTextDatatype;
import org.openmrs.hl7.HL7Constants;
import org.openmrs.module.ModuleConstants;
import org.openmrs.module.ModuleFactory;
import org.openmrs.patient.impl.LuhnIdentifierValidator;
import org.openmrs.scheduler.SchedulerConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import static java.util.Arrays.asList;
public final class OpenmrsConstants {
	private static final Logger log = LoggerFactory.getLogger(OpenmrsConstants.class);
	public static String KEY_OPENMRS_APPLICATION_DATA_DIRECTORY = "OPENMRS_APPLICATION_DATA_DIRECTORY";
	public static final int CONCEPT_CLASS_DRUG = 3;
	private static final Package THIS_PACKAGE = OpenmrsConstants.class.getPackage();
	public static final String OPENMRS_VERSION = THIS_PACKAGE.getSpecificationVendor() != null ? THIS_PACKAGE
	        .getSpecificationVendor() : (getBuildVersion() != null ? getBuildVersion() : getVersion());
	public static final String OPENMRS_VERSION_SHORT = THIS_PACKAGE.getSpecificationVersion() != null ? THIS_PACKAGE
	        .getSpecificationVersion() : (getBuildVersionShort() != null ? getBuildVersionShort() : getVersion());
	private static String getBuildVersion() {
		return getOpenmrsProperty("openmrs.version.long");
	}
	private static String getBuildVersionShort() {
		return getOpenmrsProperty("openmrs.version.short");
	}
	private static String getVersion() {
		return getOpenmrsProperty("openmrs.version");
	}
	public static String getOpenmrsProperty(String property) {
		InputStream file = OpenmrsConstants.class.getClassLoader().getResourceAsStream("org/openmrs/api/openmrs.properties");
		if (file == null) {
			log.error("Unable to find the openmrs.properties file");
			return null;
		}
		try {
			Properties props = new Properties();
			props.load(file);
			file.close();
			return props.getProperty(property);
		}
		catch (IOException e) {
			log.error("Unable to parse the openmrs.properties file", e);
		}
		finally {
			IOUtils.closeQuietly(file);
		}
		return null;
	}
	public static String DATABASE_NAME = "openmrs";
	public static String DATABASE_BUSINESS_NAME = "openmrs";
	public static boolean OBSCURE_PATIENTS = false;
	public static String OBSCURE_PATIENTS_GIVEN_NAME = "Demo";
	public static String OBSCURE_PATIENTS_MIDDLE_NAME = null;
	public static String OBSCURE_PATIENTS_FAMILY_NAME = "Person";
	public static final String REGEX_LARGE = "[!\"#\\$%&'\\(\\)\\*,+-\\./:;<=>\\?@\\[\\\\\\\\\\]^_`{\\|}~]";
	public static final String REGEX_SMALL = "[!\"#\\$%&'\\(\\)\\*,\\./:;<=>\\?@\\[\\\\\\\\\\]^_`{\\|}~]";
	public static final Integer CIVIL_STATUS_CONCEPT_ID = 1054;
	public static final String APPLICATION_DATA_DIRECTORY_FALLBACK_UNIX = "/var/lib";
	public static final String APPLICATION_DATA_DIRECTORY_FALLBACK_WIN = System.getenv("appdata");
	public static final String APPLICATION_DATA_DIRECTORY_RUNTIME_PROPERTY = "application_data_directory";
	public static final String AUTO_UPDATE_DATABASE_RUNTIME_PROPERTY = "auto_update_database";
	public static final Collection<String> STOP_WORDS() {
		List<String> stopWords = new ArrayList<>();
		stopWords.add("A");
		stopWords.add("AND");
		stopWords.add("AT");
		stopWords.add("BUT");
		stopWords.add("BY");
		stopWords.add("FOR");
		stopWords.add("HAS");
		stopWords.add("OF");
		stopWords.add("THE");
		stopWords.add("TO");
		return stopWords;
	}
	@Deprecated
	@SuppressWarnings("squid:S00100")
	public static final Map<String, String> GENDER() {
		Map<String, String> genders = new LinkedHashMap<>();
		genders.put("M", "Male");
		genders.put("F", "Female");
		return genders;
	}
	public static final List<String> GENDERS = Collections.unmodifiableList(asList("M", "F"));
	public static final Collection<String> AUTO_ROLES() {
		List<String> roles = new ArrayList<>();
		roles.add(RoleConstants.ANONYMOUS);
		roles.add(RoleConstants.AUTHENTICATED);
		return roles;
	}
	public static final String GLOBAL_PROPERTY_DRUG_FREQUENCIES = "dashboard.regimen.displayFrequencies";
	public static final String GLOBAL_PROPERTY_CONCEPTS_LOCKED = "concepts.locked";
	public static final String GLOBAL_PROPERTY_PATIENT_LISTING_ATTRIBUTES = "patient.listingAttributeTypes";
	public static final String GLOBAL_PROPERTY_PATIENT_VIEWING_ATTRIBUTES = "patient.viewingAttributeTypes";
	public static final String GLOBAL_PROPERTY_PATIENT_HEADER_ATTRIBUTES = "patient.headerAttributeTypes";
	public static final String GLOBAL_PROPERTY_USER_LISTING_ATTRIBUTES = "user.listingAttributeTypes";
	public static final String GLOBAL_PROPERTY_USER_VIEWING_ATTRIBUTES = "user.viewingAttributeTypes";
	public static final String GLOBAL_PROPERTY_USER_HEADER_ATTRIBUTES = "user.headerAttributeTypes";
	public static final String GLOBAL_PROPERTY_USER_REQUIRE_EMAIL_AS_USERNAME = "user.requireEmailAsUsername";
	public static final String GLOBAL_PROPERTY_HL7_ARCHIVE_DIRECTORY = "hl7_archive.dir";
	public static final String GLOBAL_PROPERTY_DEFAULT_THEME = "default_theme";
	public static final String GLOBAL_PROPERTY_APPLICATION_NAME = "application.name";
	public static final String[] GLOBAL_PROPERTIES_OF_PERSON_ATTRIBUTES = { GLOBAL_PROPERTY_PATIENT_LISTING_ATTRIBUTES,
	        GLOBAL_PROPERTY_PATIENT_VIEWING_ATTRIBUTES, GLOBAL_PROPERTY_PATIENT_HEADER_ATTRIBUTES,
	        GLOBAL_PROPERTY_USER_LISTING_ATTRIBUTES, GLOBAL_PROPERTY_USER_VIEWING_ATTRIBUTES,
	        GLOBAL_PROPERTY_USER_HEADER_ATTRIBUTES, GLOBAL_PROPERTY_USER_REQUIRE_EMAIL_AS_USERNAME };
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_REGEX = "patient.identifierRegex";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_PREFIX = "patient.identifierPrefix";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SUFFIX = "patient.identifierSuffix";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SEARCH_PATTERN = "patient.identifierSearchPattern";
	public static final String GLOBAL_PROPERTY_PATIENT_NAME_REGEX = "patient.nameValidationRegex";
	public static final String GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS = "person.searchMaxResults";
	public static final int GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS_DEFAULT_VALUE = 1000;
	public static final String GLOBAL_PROPERTY_PERSON_ATTRIBUTE_SEARCH_MATCH_MODE = "person.attributeSearchMatchMode";
	public static final String GLOBAL_PROPERTY_PERSON_ATTRIBUTE_SEARCH_MATCH_EXACT = "EXACT";
	public static final String GLOBAL_PROPERTY_PERSON_ATTRIBUTE_SEARCH_MATCH_ANYWHERE = "ANYWHERE";
	public static final String GLOBAL_PROPERTY_GZIP_ENABLED = "gzip.enabled";
	public static final String GLOBAL_PROPERTY_GZIP_ACCEPT_COMPRESSED_REQUESTS_FOR_PATHS = "gzip.acceptCompressedRequestsForPaths";
	public static final String GLOBAL_PROPERTY_MEDICAL_RECORD_OBSERVATIONS = "concept.medicalRecordObservations";
	public static final String GLOBAL_PROPERTY_PROBLEM_LIST = "concept.problemList";
	public static final String GLOBAL_PROPERTY_SHOW_PATIENT_NAME = "dashboard.showPatientName";
	public static final String GLOBAL_PROPERTY_ENABLE_VISITS = "visits.enabled";
	public static final String GLOBAL_PROPERTY_ALLOW_OVERLAPPING_VISITS = "visits.allowOverlappingVisits";
	public static final String GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR = "patient.defaultPatientIdentifierValidator";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_IMPORTANT_TYPES = "patient_identifier.importantTypes";
	public static final String GLOBAL_PROPERTY_ENCOUNTER_FORM_OBS_SORT_ORDER = "encounterForm.obsSortOrder";
	public static final String GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST = "locale.allowed.list";
	public static final String GLOBAL_PROPERTY_IMPLEMENTATION_ID = "implementation_id";
	public static final String GLOBAL_PROPERTY_NEWPATIENTFORM_SHOW_RELATIONSHIPS = "new_patient_form.showRelationships";
	public static final String GLOBAL_PROPERTY_NEWPATIENTFORM_RELATIONSHIPS = "newPatientForm.relationships";
	public static final String GLOBAL_PROPERTY_COMPLEX_OBS_DIR = "obs.complex_obs_dir";
	public static final String GLOBAL_PROPERTY_MIN_SEARCH_CHARACTERS = "minSearchCharacters";
	public static final int GLOBAL_PROPERTY_DEFAULT_MIN_SEARCH_CHARACTERS = 2;
	public static final String GLOBAL_PROPERTY_DEFAULT_LOCALE = "default_locale";
	public static final String GLOBAL_PROPERTY_DEFAULT_LOCATION_NAME = "default_location";
	public static final String GLOBAL_PROPERTY_DEFAULT_LOCALE_DEFAULT_VALUE = "en_GB";
	public static final String GLOBAL_PROPERTY_DEFAULT_WEEK_START_DAY = "datePicker.weekStart";
	public static final String GLOBAL_PROPERTY_DEFAULT_WEEK_START_DAY_DEFAULT_VALUE = "0";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SEARCH_MATCH_MODE = "patientIdentifierSearch.matchMode";
	public static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE = "patientSearch.matchMode";
	public static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_EXACT = "EXACT";
	public static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_ANYWHERE = "ANYWHERE";
	public static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_START = "START";
	public static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX = "SOUNDEX";
	public static final String GLOBAL_PROPERTY_PROVIDER_SEARCH_MATCH_MODE = "providerSearch.matchMode";
	public static final String GLOBAL_PROPERTY_DEFAULT_SERIALIZER = "serialization.defaultSerializer";
	public static final String GLOBAL_PROPERTY_IGNORE_MISSING_NONLOCAL_PATIENTS = "hl7_processor.ignore_missing_patient_non_local";
	public static final String GLOBAL_PROPERTY_TRUE_CONCEPT = "concept.true";
	public static final String GLOBAL_PROPERTY_FALSE_CONCEPT = "concept.false";
	public static final String GLOBAL_PROPERTY_UNKNOWN_CONCEPT = "concept.unknown";
	public static final String GLOBAL_PROPERTY_LOCATION_WIDGET_TYPE = "location.field.style";
	public static final String GLOBAL_PROPERTY_REPORT_BUG_URL = "reportProblem.url";
	public static final String GLOBAL_PROPERTY_ADDRESS_TEMPLATE = "layout.address.format";
	public static final String GLOBAL_PROPERTY_LAYOUT_NAME_FORMAT = "layout.name.format";
	public static final String GLOBAL_PROPERTY_LAYOUT_NAME_TEMPLATE = "layout.name.template";
	public static final String GLOBAL_PROPERTY_ENCOUNTER_TYPES_LOCKED = "EncounterType.encounterTypes.locked";
	public static final String GLOBAL_PROPERTY_FORMS_LOCKED = "forms.locked";
	public static final String GLOBAL_PROPERTY_PERSON_ATRIBUTE_TYPES_LOCKED = "personAttributeTypes.locked";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_TYPES_LOCKED = "patientIdentifierTypes.locked";
	public static final String GLOBAL_PROPERTY_DRUG_ORDER_REQUIRE_DRUG = "drugOrder.requireDrug";
	public static final String GLOBAL_PROPERTY_DRUG_ORDER_REQUIRE_OUTPATIENT_QUANTITY = "drugOrder.requireOutpatientQuantity";
	public static final String DEFAULT_ADDRESS_TEMPLATE = "<org.openmrs.layout.address.AddressTemplate>\n"
	        + "    <nameMappings class=\"properties\">\n"
	        + "      <property name=\"postalCode\" value=\"Location.postalCode\"/>\n"
	        + "      <property name=\"address2\" value=\"Location.address2\"/>\n"
	        + "      <property name=\"address1\" value=\"Location.address1\"/>\n"
	        + "      <property name=\"country\" value=\"Location.country\"/>\n"
	        + "      <property name=\"stateProvince\" value=\"Location.stateProvince\"/>\n"
	        + "      <property name=\"cityVillage\" value=\"Location.cityVillage\"/>\n" + "    </nameMappings>\n"
	        + "    <sizeMappings class=\"properties\">\n" + "      <property name=\"postalCode\" value=\"10\"/>\n"
	        + "      <property name=\"address2\" value=\"40\"/>\n" + "      <property name=\"address1\" value=\"40\"/>\n"
	        + "      <property name=\"country\" value=\"10\"/>\n"
	        + "      <property name=\"stateProvince\" value=\"10\"/>\n"
	        + "      <property name=\"cityVillage\" value=\"10\"/>\n" + "    </sizeMappings>\n" + "    <lineByLineFormat>\n"
	        + "      <string>address1</string>\n" + "      <string>address2</string>\n"
	        + "      <string>cityVillage stateProvince country postalCode</string>\n" + "    </lineByLineFormat>\n"
	        + "   <requiredElements>\\n\" + \" </requiredElements>\\n\" + \" </org.openmrs.layout.address.AddressTemplate>";
	public static final String GP_PASSWORD_REQUIRES_UPPER_AND_LOWER_CASE = "security.passwordRequiresUpperAndLowerCase";
	public static final String GP_PASSWORD_REQUIRES_NON_DIGIT = "security.passwordRequiresNonDigit";
	public static final String GP_PASSWORD_REQUIRES_DIGIT = "security.passwordRequiresDigit";
	public static final String GP_PASSWORD_CANNOT_MATCH_USERNAME_OR_SYSTEMID = "security.passwordCannotMatchUsername";
	public static final String GP_PASSWORD_MINIMUM_LENGTH = "security.passwordMinimumLength";
	public static final String GP_PASSWORD_RESET_VALIDTIME = "security.validTime";
	public static final String GP_PASSWORD_CUSTOM_REGEX = "security.passwordCustomRegex";
	public static final String GP_GRAPH_COLOR_ABSOLUTE = "graph.color.absolute";
	public static final String GP_GRAPH_COLOR_NORMAL = "graph.color.normal";
	public static final String GP_GRAPH_COLOR_CRITICAL = "graph.color.critical";
	public static final String GP_SEARCH_WIDGET_BATCH_SIZE = "searchWidget.batchSize";
	public static final String GP_SEARCH_WIDGET_IN_SERIAL_MODE = "searchWidget.runInSerialMode";
	public static final String GP_SEARCH_WIDGET_DELAY_INTERVAL = "searchWidget.searchDelayInterval";
	public static final String GP_SEARCH_WIDGET_MAXIMUM_RESULTS = "searchWidget.maximumResults";
	public static final String GP_SEARCH_DATE_DISPLAY_FORMAT = "searchWidget.dateDisplayFormat";
	public static final String GP_ENABLE_CONCEPT_MAP_TYPE_MANAGEMENT = "concept_map_type_management.enable";
	public static final String GP_VISIT_ASSIGNMENT_HANDLER = "visits.assignmentHandler";
	public static final String GP_ENCOUNTER_TYPE_TO_VISIT_TYPE_MAPPING = "visits.encounterTypeToVisitTypeMapping";
	public static final String GP_DASHBOARD_PROVIDER_DISPLAY_ENCOUNTER_ROLES = "dashboard.encounters.providerDisplayRoles";
	public static final String GP_DASHBOARD_MAX_NUMBER_OF_ENCOUNTERS_TO_SHOW = "dashboard.encounters.maximumNumberToShow";
	public static final String GP_DASHBOARD_METADATA_CASE_CONVERSION = "dashboard.metadata.caseConversion";
	public static final String GP_DEFAULT_CONCEPT_MAP_TYPE = "concept.defaultConceptMapType";
	public static final String GP_CONCEPT_DRUG_DOSAGE_FORM_CONCEPT_CLASSES = "conceptDrug.dosageForm.conceptClasses";
	public static final String GP_CONCEPT_DRUG_ROUTE_CONCEPT_CLASSES = "conceptDrug.route.conceptClasses";
	public static final String GP_ALLERGY_ALLERGEN_CONCEPT_CLASSES = "allergy.allergen.ConceptClasses";
	public static final String GP_ALLERGY_REACTION_CONCEPT_CLASSES = "allergy.reaction.ConceptClasses";
	public static final String GP_ALLERGEN_OTHER_NON_CODED_UUID = "allergy.concept.otherNonCoded";
	public static final String ENCRYPTION_CIPHER_CONFIGURATION = "AES/CBC/PKCS5Padding";
	public static final String ENCRYPTION_KEY_SPEC = "AES";
	public static final String ENCRYPTION_VECTOR_RUNTIME_PROPERTY = "encryption.vector";
	public static final String ENCRYPTION_VECTOR_DEFAULT = "9wyBUNglFCRVSUhMfsTa3Q==";
	public static final String ENCRYPTION_KEY_RUNTIME_PROPERTY = "encryption.key";
	public static final String ENCRYPTION_KEY_DEFAULT = "dTfyELRrAICGDwzjHDjuhw==";
	public static final String GP_VISIT_TYPES_TO_AUTO_CLOSE = "visits.autoCloseVisitType";
	public static final String AUTO_CLOSE_VISITS_TASK_NAME = "Auto Close Visits Task";
	public static final String GP_ALLOWED_FAILED_LOGINS_BEFORE_LOCKOUT = "security.allowedFailedLoginsBeforeLockout";
	public static final String GP_UNLOCK_ACCOUNT_WAITING_TIME  = "security.unlockAccountWaitingTime";
	public static final String GP_CASE_SENSITIVE_DATABASE_STRING_COMPARISON = "search.caseSensitiveDatabaseStringComparison";
	public static final String GP_DASHBOARD_CONCEPTS = "dashboard.header.showConcept";
	public static final String GP_MAIL_SMTP_STARTTLS_ENABLE = "mail.smtp.starttls.enable";
	public static final String GP_NEXT_ORDER_NUMBER_SEED = "order.nextOrderNumberSeed";
	public static final String GP_ORDER_NUMBER_GENERATOR_BEAN_ID = "order.orderNumberGeneratorBeanId";
	public static final String GP_DRUG_ROUTES_CONCEPT_UUID = "order.drugRoutesConceptUuid";
	public static final String GP_DRUG_DOSING_UNITS_CONCEPT_UUID = "order.drugDosingUnitsConceptUuid";
	public static final String GP_DRUG_DISPENSING_UNITS_CONCEPT_UUID = "order.drugDispensingUnitsConceptUuid";
	public static final String GP_DURATION_UNITS_CONCEPT_UUID = "order.durationUnitsConceptUuid";
	public static final String GP_TEST_SPECIMEN_SOURCES_CONCEPT_UUID = "order.testSpecimenSourcesConceptUuid";
	public static final String GP_UNKNOWN_PROVIDER_UUID = "provider.unknownProviderUuid";
	public static final String GP_SEARCH_INDEX_VERSION = "search.indexVersion";
	public static final Integer SEARCH_INDEX_VERSION = 7;
	public static final String GP_DISABLE_VALIDATION = "validation.disable";
	public static final String GP_DRUG_ORDER_DRUG_OTHER = "drugOrder.drugOther";
	@Deprecated
	public static final String GP_HOST_URL = "host.url";
	public static final String GP_PASSWORD_RESET_URL = "security.passwordResetUrl";
	public static final String GP_NUMBER_OF_DAYS_TO_AUTO_RETIRE_USERS = "users.numberOfDaysToRetire";
	public static final List<GlobalProperty> CORE_GLOBAL_PROPERTIES() {
		List<GlobalProperty> props = new ArrayList<>();
		props.add(new GlobalProperty("use_patient_attribute.healthCenter", "false",
		        "Indicates whether or not the 'health center' attribute is shown when viewing/searching for patients",
		        BooleanDatatype.class, null));
		props.add(new GlobalProperty("use_patient_attribute.mothersName", "false",
		        "Indicates whether or not mother's name is able to be added/viewed for a patient", BooleanDatatype.class,
		        null));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_NEWPATIENTFORM_SHOW_RELATIONSHIPS, "false",
		        "true/false whether or not to show the relationship editor on the addPatient.htm screen",
		        BooleanDatatype.class, null));
		props.add(new GlobalProperty("dashboard.overview.showConcepts", "",
		        "Comma delimited list of concepts ids to show on the patient dashboard overview tab"));
		props
		        .add(new GlobalProperty("dashboard.encounters.showEmptyFields", "true",
		                "true/false whether or not to show empty fields on the 'View Encounter' window",
		                BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                "dashboard.encounters.usePages",
		                "smart",
		                "true/false/smart on how to show the pages on the 'View Encounter' window.  'smart' means that if > 50% of the fields have page numbers defined, show data in pages"));
		props.add(new GlobalProperty("dashboard.encounters.showViewLink", "true",
		        "true/false whether or not to show the 'View Encounter' link on the patient dashboard",
		        BooleanDatatype.class, null));
		props.add(new GlobalProperty("dashboard.encounters.showEditLink", "true",
		        "true/false whether or not to show the 'Edit Encounter' link on the patient dashboard",
		        BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                "dashboard.header.programs_to_show",
		                "",
		                "List of programs to show Enrollment details of in the patient header. (Should be an ordered comma-separated list of program_ids or names.)"));
		props
		        .add(new GlobalProperty(
		                "dashboard.header.workflows_to_show",
		                "",
		                "List of programs to show Enrollment details of in the patient header. List of workflows to show current status of in the patient header. These will only be displayed if they belong to a program listed above. (Should be a comma-separated list of program_workflow_ids.)"));
		props.add(new GlobalProperty("dashboard.relationships.show_types", "",
		        "Types of relationships separated by commas.  Doctor/Patient,Parent/Child"));
		props.add(new GlobalProperty("FormEntry.enableDashboardTab", "true",
		        "true/false whether or not to show a Form Entry tab on the patient dashboard", BooleanDatatype.class, null));
		props.add(new GlobalProperty("FormEntry.enableOnEncounterTab", "false",
		        "true/false whether or not to show a Enter Form button on the encounters tab of the patient dashboard",
		        BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                "dashboard.regimen.displayDrugSetIds",
		                "ANTIRETROVIRAL DRUGS,TUBERCULOSIS TREATMENT DRUGS",
		                "Drug sets that appear on the Patient Dashboard Regimen tab. Comma separated list of name of concepts that are defined as drug sets."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_DRUG_FREQUENCIES,
		                "7 days/week,6 days/week,5 days/week,4 days/week,3 days/week,2 days/week,1 days/week",
		                "Frequency of a drug order that appear on the Patient Dashboard. Comma separated list of name of concepts that are defined as drug frequencies."));
		props.add(new GlobalProperty(GP_GRAPH_COLOR_ABSOLUTE, "rgb(20,20,20)",
		        "Color of the 'invalid' section of numeric graphs on the patient dashboard."));
		props.add(new GlobalProperty(GP_GRAPH_COLOR_NORMAL, "rgb(255,126,0)",
		        "Color of the 'normal' section of numeric graphs on the patient dashboard."));
		props.add(new GlobalProperty(GP_GRAPH_COLOR_CRITICAL, "rgb(200,0,0)",
		        "Color of the 'critical' section of numeric graphs on the patient dashboard."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_LOCATION_WIDGET_TYPE, "default",
		        "Type of widget to use for location fields"));
		props.add(new GlobalProperty(GP_MAIL_SMTP_STARTTLS_ENABLE, "false",
		        "Set to true to enable TLS encryption, else set to false"));
		props.add(new GlobalProperty(GP_PASSWORD_RESET_URL, "",
		        "The URL to redirect to after requesting for a password reset. Always provide a place holder in this url with name {activationKey}, it will get substituted by the actual activation key."));
		props.add(new GlobalProperty("mail.transport_protocol", "smtp",
		        "Transport protocol for the messaging engine. Valid values: smtp"));
		props.add(new GlobalProperty("mail.smtp_host", "localhost", "SMTP host name"));
		props.add(new GlobalProperty("mail.smtp_port", "25", "SMTP port"));
		props.add(new GlobalProperty("mail.from", "info@openmrs.org", "Email address to use as the default from address"));
		props.add(new GlobalProperty("mail.debug", "false",
		        "true/false whether to print debugging information during mailing"));
		props.add(new GlobalProperty("mail.smtp_auth", "false", "true/false whether the smtp host requires authentication"));
		props.add(new GlobalProperty("mail.user", "test", "Username of the SMTP user (if smtp_auth is enabled)"));
		props.add(new GlobalProperty("mail.password", "test", "Password for the SMTP user (if smtp_auth is enabled)"));
		props.add(new GlobalProperty("mail.default_content_type", "text/plain",
		        "Content type to append to the mail messages"));
		props.add(new GlobalProperty(ModuleConstants.REPOSITORY_FOLDER_PROPERTY,
		        ModuleConstants.REPOSITORY_FOLDER_PROPERTY_DEFAULT, "Name of the folder in which to store the modules"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_ADDRESS_TEMPLATE, DEFAULT_ADDRESS_TEMPLATE,
		        "XML description of address formats"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_LAYOUT_NAME_FORMAT, PERSON_NAME_FORMAT_SHORT,
		        "Format in which to display the person names.  Valid values are short, long"));
		props.add(new GlobalProperty("scheduler.username", SchedulerConstants.SCHEDULER_DEFAULT_USERNAME,
		        "Username for the OpenMRS user that will perform the scheduler activities"));
		props.add(new GlobalProperty("scheduler.password", SchedulerConstants.SCHEDULER_DEFAULT_PASSWORD,
		        "Password for the OpenMRS user that will perform the scheduler activities"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_CONCEPTS_LOCKED, "false", "if true, do not allow editing concepts",
		        BooleanDatatype.class, null));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_PATIENT_LISTING_ATTRIBUTES, "",
		        "A comma delimited list of PersonAttributeType names that should be displayed for patients in _lists_"));
		props
		        .add(new GlobalProperty(GLOBAL_PROPERTY_PATIENT_VIEWING_ATTRIBUTES, "",
		                "A comma delimited list of PersonAttributeType names that should be displayed for patients when _viewing individually_"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_PATIENT_HEADER_ATTRIBUTES, "",
		        "A comma delimited list of PersonAttributeType names that will be shown on the patient dashboard"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_USER_LISTING_ATTRIBUTES, "",
		        "A comma delimited list of PersonAttributeType names that should be displayed for users in _lists_"));
		props
		        .add(new GlobalProperty(GLOBAL_PROPERTY_USER_VIEWING_ATTRIBUTES, "",
		                "A comma delimited list of PersonAttributeType names that should be displayed for users when _viewing individually_"));
		props
		        .add(new GlobalProperty(GLOBAL_PROPERTY_USER_HEADER_ATTRIBUTES, "",
		                "A comma delimited list of PersonAttributeType names that will be shown on the user dashboard. (not used in v1.5)"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_IDENTIFIER_REGEX,
		                "",
		                "WARNING: Using this search property can cause a drop in mysql performance with large patient sets.  A MySQL regular expression for the patient identifier search strings.  The @SEARCH@ string is replaced at runtime with the user's search string.  An empty regex will cause a simply 'like' sql search to be used. Example: ^0*@SEARCH@([A-Z]+-[0-9])?$"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_IDENTIFIER_PREFIX,
		                "",
		                "This property is only used if "
		                        + GLOBAL_PROPERTY_PATIENT_IDENTIFIER_REGEX
		                        + " is empty.  The string here is prepended to the sql indentifier search string.  The sql becomes \"... where identifier like '<PREFIX><QUERY STRING><SUFFIX>';\".  Typically this value is either a percent sign (%) or empty."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SUFFIX,
		                "",
		                "This property is only used if "
		                        + GLOBAL_PROPERTY_PATIENT_IDENTIFIER_REGEX
		                        + " is empty.  The string here is prepended to the sql indentifier search string.  The sql becomes \"... where identifier like '<PREFIX><QUERY STRING><SUFFIX>';\".  Typically this value is either a percent sign (%) or empty."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SEARCH_PATTERN,
		                "",
		                "If this is empty, the regex or suffix/prefix search is used.  Comma separated list of identifiers to check.  Allows for faster searching of multiple options rather than the slow regex. e.g. @SEARCH@,0@SEARCH@,@SEARCH-1@-@CHECKDIGIT@,0@SEARCH-1@-@CHECKDIGIT@ would turn a request for \"4127\" into a search for \"in ('4127','04127','412-7','0412-7')\""));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_NAME_REGEX,
		                "",
		                "Names of the patients must pass this regex. Eg : ^[a-zA-Z \\-]+$ contains only english alphabet letters, spaces, and hyphens. A value of .* or the empty string means no validation is done."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS, String
		        .valueOf(GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS_DEFAULT_VALUE),
		        "The maximum number of results returned by patient searches"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_GZIP_ENABLED,
		                "false",
		                "Set to 'true' to turn on OpenMRS's gzip filter, and have the webapp compress data before sending it to any client that supports it. Generally use this if you are running Tomcat standalone. If you are running Tomcat behind Apache, then you'd want to use Apache to do gzip compression.",
		                BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_LOG_LEVEL,
		                "org.openmrs.api:" + LOG_LEVEL_INFO,
		                "Logging levels for log4j2.xml. Valid format is class:level,class:level. If class not specified, 'org.openmrs.api' presumed. Valid levels are trace, debug, info, warn, error or fatal"));
		props.add(new GlobalProperty(GP_LOG_LOCATION, "",
		        "A directory where the OpenMRS log file appender is stored. The log file name is 'openmrs.log'."));
		props.add(new GlobalProperty(GP_LOG_LAYOUT, "%p - %C{1}.%M(%L) |%d{ISO8601}| %m%n",
		        "A log layout pattern which is used by the OpenMRS file appender."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR,
		                LUHN_IDENTIFIER_VALIDATOR,
		                "This property sets the default patient identifier validator.  The default validator is only used in a handful of (mostly legacy) instances.  For example, it's used to generate the isValidCheckDigit calculated column and to append the string \"(default)\" to the name of the default validator on the editPatientIdentifierType form."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_IDENTIFIER_IMPORTANT_TYPES,
		                "",
		                "A comma delimited list of PatientIdentifier names : PatientIdentifier locations that will be displayed on the patient dashboard.  E.g.: TRACnet ID:Rwanda,ELDID:Kenya"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_COMPLEX_OBS_DIR, "complex_obs",
		        "Default directory for storing complex obs."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_ENCOUNTER_FORM_OBS_SORT_ORDER,
		                "number",
		                "The sort order for the obs listed on the encounter edit form.  'number' sorts on the associated numbering from the form schema.  'weight' sorts on the order displayed in the form schema."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en, en_GB, es, fr, it, pt",
		        "Comma delimited list of locales allowed for use on system"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_NEWPATIENTFORM_RELATIONSHIPS,
		                "",
		                "Comma separated list of the RelationshipTypes to show on the new/short patient form.  The list is defined like '3a, 4b, 7a'.  The number is the RelationshipTypeId and the 'a' vs 'b' part is which side of the relationship is filled in by the user."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_MIN_SEARCH_CHARACTERS, "2",
		        "Number of characters user must input before searching is started."));
		props
		        .add(new GlobalProperty(
		                OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE,
		                OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE_DEFAULT_VALUE,
		                "Specifies the default locale. You can specify both the language code(ISO-639) and the country code(ISO-3166), e.g. 'en_GB' or just country: e.g. 'en'"));
		props.add(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_WEEK_START_DAY,
		        OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_WEEK_START_DAY_DEFAULT_VALUE,
		        "First day of the week in the date picker. Domingo/Dimanche/Sunday:0  Lunes/Lundi/Monday:1"));
		props.add(new GlobalProperty(GP_PASSWORD_CANNOT_MATCH_USERNAME_OR_SYSTEMID, "true",
		        "Configure whether passwords must not match user's username or system id", BooleanDatatype.class, null));
		props.add(new GlobalProperty(GP_PASSWORD_CUSTOM_REGEX, "",
		        "Configure a custom regular expression that a password must match"));
		props.add(new GlobalProperty(GP_PASSWORD_MINIMUM_LENGTH, "8",
		        "Configure the minimum length required of all passwords"));
		props.add(new GlobalProperty(GP_PASSWORD_RESET_VALIDTIME, "600000",
		        " Specifies the duration of time in seconds for which a password reset token is valid, the default value is 10 minutes and the allowed values range from 1 minute to 12hrs"));
		props.add(new GlobalProperty(GP_PASSWORD_REQUIRES_DIGIT, "true",
		        "Configure whether passwords must contain at least one digit", BooleanDatatype.class, null));
		props.add(new GlobalProperty(GP_PASSWORD_REQUIRES_NON_DIGIT, "true",
		        "Configure whether passwords must contain at least one non-digit", BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(GP_PASSWORD_REQUIRES_UPPER_AND_LOWER_CASE, "true",
		                "Configure whether passwords must contain both upper and lower case characters",
		                BooleanDatatype.class, null));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_IGNORE_MISSING_NONLOCAL_PATIENTS, "false",
		        "If true, hl7 messages for patients that are not found and are non-local will silently be dropped/ignored",
		        BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_SHOW_PATIENT_NAME,
		                "false",
		                "Whether or not to display the patient name in the patient dashboard title. Note that enabling this could be security risk if multiple users operate on the same computer.",
		                BooleanDatatype.class, null));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_DEFAULT_THEME, "",
		        "Default theme for users.  OpenMRS ships with themes of 'green', 'orange', 'purple', and 'legacy'"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_HL7_ARCHIVE_DIRECTORY, HL7Constants.HL7_ARCHIVE_DIRECTORY_NAME,
		        "The default name or absolute path for the folder where to write the hl7_in_archives."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_REPORT_BUG_URL, "http:
		        "The openmrs url where to submit bug reports"));
		props.add(new GlobalProperty(GP_SEARCH_WIDGET_BATCH_SIZE, "200",
		        "The maximum number of search results that are returned by an ajax call"));
		props
		        .add(new GlobalProperty(
		                GP_SEARCH_WIDGET_IN_SERIAL_MODE,
		                "false",
		                "Specifies whether the search widgets should make ajax requests in serial or parallel order, a value of true is appropriate for implementations running on a slow network connection and vice versa",
		                BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                GP_SEARCH_WIDGET_DELAY_INTERVAL,
		                "300",
		                "Specifies time interval in milliseconds when searching, between keyboard keyup event and triggering the search off, should be higher if most users are slow when typing so as to minimise the load on the server"));
		props
		        .add(new GlobalProperty(GP_SEARCH_DATE_DISPLAY_FORMAT, null,
		                "Date display format to be used to display the date somewhere in the UI i.e the search widgets and autocompletes"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_DEFAULT_LOCATION_NAME, "Unknown Location",
		        "The name of the location to use as a system default"));
		props
				.add(new GlobalProperty(
						GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SEARCH_MATCH_MODE,
						GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_EXACT,
						"Specifies how patient identifiers are matched while searching for a patient. Valid values are 'EXACT, 'ANYWHERE' or 'START'. Defaults to 'EXACT' if missing or invalid value is present."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE,
		                GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_START,
		                "Specifies how patient names are matched while searching patient. Valid values are 'ANYWHERE' or 'START'. Defaults to start if missing or invalid value is present."));
		props.add(new GlobalProperty(GP_ENABLE_CONCEPT_MAP_TYPE_MANAGEMENT, "false",
		        "Enables or disables management of concept map types", BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_ENABLE_VISITS,
		                "true",
		                "Set to true to enable the Visits feature. This will replace the 'Encounters' tab with a 'Visits' tab on the dashboard.",
		                BooleanDatatype.class, null));
		props.add(new GlobalProperty(GP_VISIT_ASSIGNMENT_HANDLER, ExistingVisitAssignmentHandler.class.getName(),
		        "Set to the name of the class responsible for assigning encounters to visits."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_APPLICATION_NAME, "OpenMRS",
		        "The name of this application, as presented to the user, for example on the login and welcome pages."));
		props
		        .add(new GlobalProperty(
		                GP_ENCOUNTER_TYPE_TO_VISIT_TYPE_MAPPING,
		                "",
		                "Specifies how encounter types are mapped to visit types when automatically assigning encounters to visits. e.g 1:1, 2:1, 3:2 in the format encounterTypeId:visitTypeId or encounterTypeUuid:visitTypeUuid or a combination of encounter/visit type uuids and ids e.g 1:759799ab-c9a5-435e-b671-77773ada74e4"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_ENCOUNTER_TYPES_LOCKED, "false",
		        "saving, retiring or deleting an Encounter Type is not permitted, if true", BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                GP_DASHBOARD_PROVIDER_DISPLAY_ENCOUNTER_ROLES,
		                "",
		                "A comma-separated list of encounter roles (by name or id). Providers with these roles in an encounter will be displayed on the encounter tab of the patient dashboard."));
		props.add(new GlobalProperty(GP_SEARCH_WIDGET_MAXIMUM_RESULTS, "2000",
		        "Specifies the maximum number of results to return from a single search in the search widgets"));
		props
		        .add(new GlobalProperty(
		                GP_DASHBOARD_MAX_NUMBER_OF_ENCOUNTERS_TO_SHOW,
		                "3",
		                "An integer which, if specified, would determine the maximum number of encounters to display on the encounter tab of the patient dashboard."));
		props.add(new GlobalProperty(GP_VISIT_TYPES_TO_AUTO_CLOSE, "",
		        "comma-separated list of the visit type(s) to automatically close"));
		props.add(new GlobalProperty(GP_ALLOWED_FAILED_LOGINS_BEFORE_LOCKOUT, "7",
		        "Maximum number of failed logins allowed after which username is locked out"));
		props.add(new GlobalProperty(GP_UNLOCK_ACCOUNT_WAITING_TIME, "5",
			"Waiting time for account to get automatically unlocked after getting locked due to multiple invalid login tries"));
		props.add(new GlobalProperty(GP_DEFAULT_CONCEPT_MAP_TYPE, "NARROWER-THAN",
		        "Default concept map type which is used when no other is set"));
		props
		        .add(new GlobalProperty(GP_CONCEPT_DRUG_DOSAGE_FORM_CONCEPT_CLASSES, "",
		                "A comma-separated list of the allowed concept classes for the dosage form field of the concept drug management form."));
		props
		        .add(new GlobalProperty(GP_CONCEPT_DRUG_ROUTE_CONCEPT_CLASSES, "",
		                "A comma-separated list of the allowed concept classes for the route field of the concept drug management form."));
		props
		        .add(new GlobalProperty(
		                GP_CASE_SENSITIVE_DATABASE_STRING_COMPARISON,
		                "false",
		                "Indicates whether database string comparison is case sensitive or not. Setting this to false for MySQL with a case insensitive collation improves search performance."));
		props
		        .add(new GlobalProperty(
		                GP_DASHBOARD_METADATA_CASE_CONVERSION,
		                "",
		                "Indicates which type automatic case conversion is applied to program/workflow/state in the patient dashboard. Valid values: lowercase, uppercase, capitalize. If empty no conversion is applied."));
		props.add(new GlobalProperty(GP_ALLERGY_ALLERGEN_CONCEPT_CLASSES, "Drug,MedSet",
		        "A comma-separated list of the allowed concept classes for the allergen field of the allergy dialog"));
		props.add(new GlobalProperty(GP_ALLERGY_REACTION_CONCEPT_CLASSES, "Symptom",
		        "A comma-separated list of the allowed concept classes for the reaction field of the allergy dialog"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_USER_REQUIRE_EMAIL_AS_USERNAME, "false",
		        "Indicates whether a username must be a valid e-mail or not.", BooleanDatatype.class, null));
		props.add(new GlobalProperty(GP_SEARCH_INDEX_VERSION, "",
		        "Indicates the index version. If it is blank, the index needs to be rebuilt."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_ALLOW_OVERLAPPING_VISITS, "true",
		        "true/false whether or not to allow visits of a given patient to overlap", BooleanDatatype.class, null));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_FORMS_LOCKED, "false",
		        "Set to a value of true if you do not want any changes to be made on forms, else set to false."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_DRUG_ORDER_REQUIRE_DRUG, "false",
		        "Set to value true if you need to specify a formulation(Drug) when creating a drug order."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_DRUG_ORDER_REQUIRE_OUTPATIENT_QUANTITY, "true",
			"true/false whether to require quantity, quantityUnits, and numRefills for outpatient drug orders"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_PERSON_ATRIBUTE_TYPES_LOCKED, "false",
		        "Set to a value of true if you do not want allow editing person attribute types, else set to false."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_PATIENT_IDENTIFIER_TYPES_LOCKED, "false",
		        "Set to a value of true if you do not want allow editing patient identifier types, else set to false."));
		props.add(new GlobalProperty(GP_NEXT_ORDER_NUMBER_SEED, "1", "The next order number available for assignment"));
		props.add(new GlobalProperty(GP_ORDER_NUMBER_GENERATOR_BEAN_ID, "",
		        "Specifies spring bean id of the order generator to use when assigning order numbers"));
		props.add(new GlobalProperty(GP_DRUG_ROUTES_CONCEPT_UUID, "",
		        "Specifies the uuid of the concept set where its members represent the possible drug routes"));
		props.add(new GlobalProperty(GP_DRUG_DOSING_UNITS_CONCEPT_UUID, "",
		        "Specifies the uuid of the concept set where its members represent the possible drug dosing units"));
		props.add(new GlobalProperty(GP_DRUG_DISPENSING_UNITS_CONCEPT_UUID, "",
		        "Specifies the uuid of the concept set where its members represent the possible drug dispensing units"));
		props.add(new GlobalProperty(GP_DURATION_UNITS_CONCEPT_UUID, "",
		        "Specifies the uuid of the concept set where its members represent the possible duration units"));
		props.add(new GlobalProperty(GP_TEST_SPECIMEN_SOURCES_CONCEPT_UUID, "",
		        "Specifies the uuid of the concept set where its members represent the possible test specimen sources"));
		props.add(new GlobalProperty(GP_UNKNOWN_PROVIDER_UUID, "", "Specifies the uuid of the Unknown Provider account"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PROVIDER_SEARCH_MATCH_MODE,
		                "EXACT",
		                "Specifies how provider identifiers are matched while searching for providers. Valid values are START,EXACT, END or ANYWHERE"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PERSON_ATTRIBUTE_SEARCH_MATCH_MODE,
		                GLOBAL_PROPERTY_PERSON_ATTRIBUTE_SEARCH_MATCH_EXACT,
		                "Specifies how person attributes are matched while searching person. Valid values are 'ANYWHERE' or 'EXACT'. Defaults to exact if missing or invalid value is present."));
		props.add(new GlobalProperty(GP_DISABLE_VALIDATION, "false",
				"Disables validation of OpenMRS Objects. Only takes affect on next restart. Warning: only do this is you know what you are doing!"));
		props.add(new GlobalProperty("allergy.concept.severity.mild", "1498AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the MILD severity concept"));
		props.add(new GlobalProperty("allergy.concept.severity.moderate", "1499AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the MODERATE severity concept"));
		props.add(new GlobalProperty("allergy.concept.severity.severe", "1500AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the SEVERE severity concept"));
		props.add(new GlobalProperty("allergy.concept.allergen.food", "162553AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the food allergens concept"));
		props.add(new GlobalProperty("allergy.concept.allergen.drug", "162552AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the drug allergens concept"));
		props.add(new GlobalProperty("allergy.concept.allergen.environment", "162554AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the environment allergens concept"));
		props.add(new GlobalProperty("allergy.concept.reactions", "162555AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the allergy reactions concept"));
		props.add(new GlobalProperty(GP_ALLERGEN_OTHER_NON_CODED_UUID, "5622AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the allergy other non coded concept"));
		props.add(new GlobalProperty("allergy.concept.unknown", "1067AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the allergy unknown concept"));
		props
				.add(new GlobalProperty(GP_DRUG_ORDER_DRUG_OTHER, "", "Specifies the uuid of the concept which represents drug other non coded"));
		props.add(new GlobalProperty(GP_LOGIN_URL, LOGIN_URL,
			"Responsible for defining the Authentication URL "));
		props.addAll(ModuleFactory.getGlobalProperties());
		return props;
	}
	public static final String PROPOSED_CONCEPT_IDENTIFIER = "PROPOSED";
	public static final String CONCEPT_PROPOSAL_UNMAPPED = "UNMAPPED";
	public static final String CONCEPT_PROPOSAL_CONCEPT = "CONCEPT";
	public static final String CONCEPT_PROPOSAL_SYNONYM = "SYNONYM";
	public static final String CONCEPT_PROPOSAL_REJECT = "REJECT";
	public static final Collection<String> CONCEPT_PROPOSAL_STATES() {
		Collection<String> states = new ArrayList<>();
		states.add(CONCEPT_PROPOSAL_UNMAPPED);
		states.add(CONCEPT_PROPOSAL_CONCEPT);
		states.add(CONCEPT_PROPOSAL_SYNONYM);
		states.add(CONCEPT_PROPOSAL_REJECT);
		return states;
	}
	public static final Locale SPANISH_LANGUAGE = new Locale("es");
	public static final Locale PORTUGUESE_LANGUAGE = new Locale("pt");
	public static final Locale ITALIAN_LANGUAGE = new Locale("it");
	public static final String USER_PROPERTY_CHANGE_PASSWORD = "forcePassword";
	public static final String USER_PROPERTY_DEFAULT_LOCALE = "defaultLocale";
	public static final String USER_PROPERTY_DEFAULT_LOCATION = "defaultLocation";
	public static final String USER_PROPERTY_SHOW_RETIRED = "showRetired";
	public static final String USER_PROPERTY_SHOW_VERBOSE = "showVerbose";
	public static final String USER_PROPERTY_NOTIFICATION = "notification";
	public static final String USER_PROPERTY_NOTIFICATION_ADDRESS = "notificationAddress";
	public static final String USER_PROPERTY_NOTIFICATION_FORMAT = "notificationFormat"; 
	public static final String USER_PROPERTY_LOGIN_ATTEMPTS = "loginAttempts";
	public static final String USER_PROPERTY_LOCKOUT_TIMESTAMP = "lockoutTimestamp";
	public static final String USER_PROPERTY_PROFICIENT_LOCALES = "proficientLocales";
	public static final String USER_PROPERTY_LAST_LOGIN_TIMESTAMP = "lastLoginTimestamp";
	public static final String OPERATING_SYSTEM_KEY = "os.name";
	public static final String OPERATING_SYSTEM = System.getProperty(OPERATING_SYSTEM_KEY);
	public static final String OPERATING_SYSTEM_WINDOWS_XP = "Windows XP";
	public static final String OPERATING_SYSTEM_WINDOWS_VISTA = "Windows Vista";
	public static final String OPERATING_SYSTEM_LINUX = "Linux";
	public static final String OPERATING_SYSTEM_SUNOS = "SunOS";
	public static final String OPERATING_SYSTEM_FREEBSD = "FreeBSD";
	public static final String OPERATING_SYSTEM_OSX = "Mac OS X";
	public static final String IMPLEMENTATION_ID_REMOTE_CONNECTION_URL = "https:
	public static final boolean UNIX_BASED_OPERATING_SYSTEM = (OPERATING_SYSTEM.contains(OPERATING_SYSTEM_LINUX)
	        || OPERATING_SYSTEM.contains(OPERATING_SYSTEM_SUNOS)
	        || OPERATING_SYSTEM.contains(OPERATING_SYSTEM_FREEBSD) || OPERATING_SYSTEM.contains(OPERATING_SYSTEM_OSX));
	public static final boolean WINDOWS_BASED_OPERATING_SYSTEM = OPERATING_SYSTEM.contains("Windows");
	public static final boolean WINDOWS_VISTA_OPERATING_SYSTEM = OPERATING_SYSTEM.equals(OPERATING_SYSTEM_WINDOWS_VISTA);
	public static final String SHORT_SERIALIZATION = "isShortSerialization";
	public static final String GLOBAL_PROPERTY_LOG_LEVEL = "log.level";
	public static final String GP_LOG_LOCATION = "log.location";
	public static final String GP_LOG_LAYOUT = "log.layout";
	public static final String LOG_OPENMRS_FILE_APPENDER = "OPENMRS FILE APPENDER";
	public static final String LOG_CLASS_DEFAULT = "org.openmrs.api";
	public static final String LOG_LEVEL_TRACE = "trace";
	public static final String LOG_LEVEL_DEBUG = "debug";
	public static final String LOG_LEVEL_INFO = "info";
	public static final String LOG_LEVEL_WARN = "warn";
	public static final String LOG_LEVEL_ERROR = "error";
	public static final String LOG_LEVEL_FATAL = "fatal";
	public static final String MEMORY_APPENDER_NAME = "MEMORY_APPENDER";
	public static final String LOGIN_URL = "login.htm";
	public static final String GP_LOGIN_URL = "login.url";
	public static enum PERSON_TYPE {
		PERSON,
		PATIENT,
		USER
	}
	public static final String LUHN_IDENTIFIER_VALIDATOR = LuhnIdentifierValidator.class.getName();
	public static final String DEFAULT_CUSTOM_DATATYPE = FreeTextDatatype.class.getName();
	public static final String REGISTERED_COMPONENT_NAME_PREFIX = "bean:";
	public static final String PERSON_NAME_FORMAT_SHORT = "short";
	public static final String PERSON_NAME_FORMAT_LONG = "long";
	public static final String LIQUIBASE_DUPLICATE_FILE_MODE_DEFAULT = GlobalConfiguration.DuplicateFileMode.WARN.name();
	public static final String ZERO_LOGIN_ATTEMPTS_VALUE = "0";
	private OpenmrsConstants() {
	}
}
_____
package org.openmrs.util;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import liquibase.GlobalConfiguration;
import org.apache.commons.io.IOUtils;
import org.openmrs.GlobalProperty;
import org.openmrs.api.handler.ExistingVisitAssignmentHandler;
import org.openmrs.customdatatype.datatype.BooleanDatatype;
import org.openmrs.customdatatype.datatype.FreeTextDatatype;
import org.openmrs.hl7.HL7Constants;
import org.openmrs.module.ModuleConstants;
import org.openmrs.module.ModuleFactory;
import org.openmrs.patient.impl.LuhnIdentifierValidator;
import org.openmrs.scheduler.SchedulerConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import static java.util.Arrays.asList;
public final class OpenmrsConstants {
	private static final Logger log = LoggerFactory.getLogger(OpenmrsConstants.class);
	public static String KEY_OPENMRS_APPLICATION_DATA_DIRECTORY = "OPENMRS_APPLICATION_DATA_DIRECTORY";
	public static final int CONCEPT_CLASS_DRUG = 3;
	private static final Package THIS_PACKAGE = OpenmrsConstants.class.getPackage();
	public static final String OPENMRS_VERSION = THIS_PACKAGE.getSpecificationVendor() != null ? THIS_PACKAGE
	        .getSpecificationVendor() : (getBuildVersion() != null ? getBuildVersion() : getVersion());
	public static final String OPENMRS_VERSION_SHORT = THIS_PACKAGE.getSpecificationVersion() != null ? THIS_PACKAGE
	        .getSpecificationVersion() : (getBuildVersionShort() != null ? getBuildVersionShort() : getVersion());
	private static String getBuildVersion() {
		return getOpenmrsProperty("openmrs.version.long");
	}
	private static String getBuildVersionShort() {
		return getOpenmrsProperty("openmrs.version.short");
	}
	private static String getVersion() {
		return getOpenmrsProperty("openmrs.version");
	}
	public static String getOpenmrsProperty(String property) {
		InputStream file = OpenmrsConstants.class.getClassLoader().getResourceAsStream("org/openmrs/api/openmrs.properties");
		if (file == null) {
			log.error("Unable to find the openmrs.properties file");
			return null;
		}
		try {
			Properties props = new Properties();
			props.load(file);
			file.close();
			return props.getProperty(property);
		}
		catch (IOException e) {
			log.error("Unable to parse the openmrs.properties file", e);
		}
		finally {
			IOUtils.closeQuietly(file);
		}
		return null;
	}
	public static String DATABASE_NAME = "openmrs";
	public static String DATABASE_BUSINESS_NAME = "openmrs";
	public static boolean OBSCURE_PATIENTS = false;
	public static String OBSCURE_PATIENTS_GIVEN_NAME = "Demo";
	public static String OBSCURE_PATIENTS_MIDDLE_NAME = null;
	public static String OBSCURE_PATIENTS_FAMILY_NAME = "Person";
	public static final String REGEX_LARGE = "[!\"#\\$%&'\\(\\)\\*,+-\\./:;<=>\\?@\\[\\\\\\\\\\]^_`{\\|}~]";
	public static final String REGEX_SMALL = "[!\"#\\$%&'\\(\\)\\*,\\./:;<=>\\?@\\[\\\\\\\\\\]^_`{\\|}~]";
	public static final Integer CIVIL_STATUS_CONCEPT_ID = 1054;
	public static final String APPLICATION_DATA_DIRECTORY_FALLBACK_UNIX = "/var/lib";
	public static final String APPLICATION_DATA_DIRECTORY_FALLBACK_WIN = System.getenv("appdata");
	public static final String APPLICATION_DATA_DIRECTORY_RUNTIME_PROPERTY = "application_data_directory";
	public static final String AUTO_UPDATE_DATABASE_RUNTIME_PROPERTY = "auto_update_database";
	public static final Collection<String> STOP_WORDS() {
		List<String> stopWords = new ArrayList<>();
		stopWords.add("A");
		stopWords.add("AND");
		stopWords.add("AT");
		stopWords.add("BUT");
		stopWords.add("BY");
		stopWords.add("FOR");
		stopWords.add("HAS");
		stopWords.add("OF");
		stopWords.add("THE");
		stopWords.add("TO");
		return stopWords;
	}
	@Deprecated
	@SuppressWarnings("squid:S00100")
	public static final Map<String, String> GENDER() {
		Map<String, String> genders = new LinkedHashMap<>();
		genders.put("M", "Male");
		genders.put("F", "Female");
		return genders;
	}
	public static final List<String> GENDERS = Collections.unmodifiableList(asList("M", "F"));
	public static final Collection<String> AUTO_ROLES() {
		List<String> roles = new ArrayList<>();
		roles.add(RoleConstants.ANONYMOUS);
		roles.add(RoleConstants.AUTHENTICATED);
		return roles;
	}
	public static final String GLOBAL_PROPERTY_DRUG_FREQUENCIES = "dashboard.regimen.displayFrequencies";
	public static final String GLOBAL_PROPERTY_CONCEPTS_LOCKED = "concepts.locked";
	public static final String GLOBAL_PROPERTY_PATIENT_LISTING_ATTRIBUTES = "patient.listingAttributeTypes";
	public static final String GLOBAL_PROPERTY_PATIENT_VIEWING_ATTRIBUTES = "patient.viewingAttributeTypes";
	public static final String GLOBAL_PROPERTY_PATIENT_HEADER_ATTRIBUTES = "patient.headerAttributeTypes";
	public static final String GLOBAL_PROPERTY_USER_LISTING_ATTRIBUTES = "user.listingAttributeTypes";
	public static final String GLOBAL_PROPERTY_USER_VIEWING_ATTRIBUTES = "user.viewingAttributeTypes";
	public static final String GLOBAL_PROPERTY_USER_HEADER_ATTRIBUTES = "user.headerAttributeTypes";
	public static final String GLOBAL_PROPERTY_USER_REQUIRE_EMAIL_AS_USERNAME = "user.requireEmailAsUsername";
	public static final String GLOBAL_PROPERTY_HL7_ARCHIVE_DIRECTORY = "hl7_archive.dir";
	public static final String GLOBAL_PROPERTY_DEFAULT_THEME = "default_theme";
	public static final String GLOBAL_PROPERTY_APPLICATION_NAME = "application.name";
	public static final String[] GLOBAL_PROPERTIES_OF_PERSON_ATTRIBUTES = { GLOBAL_PROPERTY_PATIENT_LISTING_ATTRIBUTES,
	        GLOBAL_PROPERTY_PATIENT_VIEWING_ATTRIBUTES, GLOBAL_PROPERTY_PATIENT_HEADER_ATTRIBUTES,
	        GLOBAL_PROPERTY_USER_LISTING_ATTRIBUTES, GLOBAL_PROPERTY_USER_VIEWING_ATTRIBUTES,
	        GLOBAL_PROPERTY_USER_HEADER_ATTRIBUTES, GLOBAL_PROPERTY_USER_REQUIRE_EMAIL_AS_USERNAME };
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_REGEX = "patient.identifierRegex";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_PREFIX = "patient.identifierPrefix";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SUFFIX = "patient.identifierSuffix";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SEARCH_PATTERN = "patient.identifierSearchPattern";
	public static final String GLOBAL_PROPERTY_PATIENT_NAME_REGEX = "patient.nameValidationRegex";
	public static final String GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS = "person.searchMaxResults";
	public static final int GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS_DEFAULT_VALUE = 1000;
	public static final String GLOBAL_PROPERTY_PERSON_ATTRIBUTE_SEARCH_MATCH_MODE = "person.attributeSearchMatchMode";
	public static final String GLOBAL_PROPERTY_PERSON_ATTRIBUTE_SEARCH_MATCH_EXACT = "EXACT";
	public static final String GLOBAL_PROPERTY_PERSON_ATTRIBUTE_SEARCH_MATCH_ANYWHERE = "ANYWHERE";
	public static final String GLOBAL_PROPERTY_GZIP_ENABLED = "gzip.enabled";
	public static final String GLOBAL_PROPERTY_GZIP_ACCEPT_COMPRESSED_REQUESTS_FOR_PATHS = "gzip.acceptCompressedRequestsForPaths";
	public static final String GLOBAL_PROPERTY_MEDICAL_RECORD_OBSERVATIONS = "concept.medicalRecordObservations";
	public static final String GLOBAL_PROPERTY_PROBLEM_LIST = "concept.problemList";
	public static final String GLOBAL_PROPERTY_SHOW_PATIENT_NAME = "dashboard.showPatientName";
	public static final String GLOBAL_PROPERTY_ENABLE_VISITS = "visits.enabled";
	public static final String GLOBAL_PROPERTY_ALLOW_OVERLAPPING_VISITS = "visits.allowOverlappingVisits";
	public static final String GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR = "patient.defaultPatientIdentifierValidator";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_IMPORTANT_TYPES = "patient_identifier.importantTypes";
	public static final String GLOBAL_PROPERTY_ENCOUNTER_FORM_OBS_SORT_ORDER = "encounterForm.obsSortOrder";
	public static final String GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST = "locale.allowed.list";
	public static final String GLOBAL_PROPERTY_IMPLEMENTATION_ID = "implementation_id";
	public static final String GLOBAL_PROPERTY_NEWPATIENTFORM_SHOW_RELATIONSHIPS = "new_patient_form.showRelationships";
	public static final String GLOBAL_PROPERTY_NEWPATIENTFORM_RELATIONSHIPS = "newPatientForm.relationships";
	public static final String GLOBAL_PROPERTY_COMPLEX_OBS_DIR = "obs.complex_obs_dir";
	public static final String GLOBAL_PROPERTY_MIN_SEARCH_CHARACTERS = "minSearchCharacters";
	public static final int GLOBAL_PROPERTY_DEFAULT_MIN_SEARCH_CHARACTERS = 2;
	public static final String GLOBAL_PROPERTY_DEFAULT_LOCALE = "default_locale";
	public static final String GLOBAL_PROPERTY_DEFAULT_LOCATION_NAME = "default_location";
	public static final String GLOBAL_PROPERTY_DEFAULT_LOCALE_DEFAULT_VALUE = "en_GB";
	public static final String GLOBAL_PROPERTY_DEFAULT_WEEK_START_DAY = "datePicker.weekStart";
	public static final String GLOBAL_PROPERTY_DEFAULT_WEEK_START_DAY_DEFAULT_VALUE = "0";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SEARCH_MATCH_MODE = "patientIdentifierSearch.matchMode";
	public static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE = "patientSearch.matchMode";
	public static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_EXACT = "EXACT";
	public static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_ANYWHERE = "ANYWHERE";
	public static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_START = "START";
	public static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX = "SOUNDEX";
	public static final String GLOBAL_PROPERTY_PROVIDER_SEARCH_MATCH_MODE = "providerSearch.matchMode";
	public static final String GLOBAL_PROPERTY_DEFAULT_SERIALIZER = "serialization.defaultSerializer";
	public static final String GLOBAL_PROPERTY_IGNORE_MISSING_NONLOCAL_PATIENTS = "hl7_processor.ignore_missing_patient_non_local";
	public static final String GLOBAL_PROPERTY_TRUE_CONCEPT = "concept.true";
	public static final String GLOBAL_PROPERTY_FALSE_CONCEPT = "concept.false";
	public static final String GLOBAL_PROPERTY_UNKNOWN_CONCEPT = "concept.unknown";
	public static final String GLOBAL_PROPERTY_LOCATION_WIDGET_TYPE = "location.field.style";
	public static final String GLOBAL_PROPERTY_REPORT_BUG_URL = "reportProblem.url";
	public static final String GLOBAL_PROPERTY_ADDRESS_TEMPLATE = "layout.address.format";
	public static final String GLOBAL_PROPERTY_LAYOUT_NAME_FORMAT = "layout.name.format";
	public static final String GLOBAL_PROPERTY_LAYOUT_NAME_TEMPLATE = "layout.name.template";
	public static final String GLOBAL_PROPERTY_ENCOUNTER_TYPES_LOCKED = "EncounterType.encounterTypes.locked";
	public static final String GLOBAL_PROPERTY_FORMS_LOCKED = "forms.locked";
	public static final String GLOBAL_PROPERTY_PERSON_ATRIBUTE_TYPES_LOCKED = "personAttributeTypes.locked";
	public static final String GLOBAL_PROPERTY_PATIENT_IDENTIFIER_TYPES_LOCKED = "patientIdentifierTypes.locked";
	public static final String GLOBAL_PROPERTY_DRUG_ORDER_REQUIRE_DRUG = "drugOrder.requireDrug";
	public static final String GLOBAL_PROPERTY_DRUG_ORDER_REQUIRE_OUTPATIENT_QUANTITY = "drugOrder.requireOutpatientQuantity";
	public static final String DEFAULT_ADDRESS_TEMPLATE = "<org.openmrs.layout.address.AddressTemplate>\n"
	        + "    <nameMappings class=\"properties\">\n"
	        + "      <property name=\"postalCode\" value=\"Location.postalCode\"/>\n"
	        + "      <property name=\"address2\" value=\"Location.address2\"/>\n"
	        + "      <property name=\"address1\" value=\"Location.address1\"/>\n"
	        + "      <property name=\"country\" value=\"Location.country\"/>\n"
	        + "      <property name=\"stateProvince\" value=\"Location.stateProvince\"/>\n"
	        + "      <property name=\"cityVillage\" value=\"Location.cityVillage\"/>\n" + "    </nameMappings>\n"
	        + "    <sizeMappings class=\"properties\">\n" + "      <property name=\"postalCode\" value=\"10\"/>\n"
	        + "      <property name=\"address2\" value=\"40\"/>\n" + "      <property name=\"address1\" value=\"40\"/>\n"
	        + "      <property name=\"country\" value=\"10\"/>\n"
	        + "      <property name=\"stateProvince\" value=\"10\"/>\n"
	        + "      <property name=\"cityVillage\" value=\"10\"/>\n" + "    </sizeMappings>\n" + "    <lineByLineFormat>\n"
	        + "      <string>address1</string>\n" + "      <string>address2</string>\n"
	        + "      <string>cityVillage stateProvince country postalCode</string>\n" + "    </lineByLineFormat>\n"
	        + "   <requiredElements>\\n\" + \" </requiredElements>\\n\" + \" </org.openmrs.layout.address.AddressTemplate>";
	public static final String GP_PASSWORD_REQUIRES_UPPER_AND_LOWER_CASE = "security.passwordRequiresUpperAndLowerCase";
	public static final String GP_PASSWORD_REQUIRES_NON_DIGIT = "security.passwordRequiresNonDigit";
	public static final String GP_PASSWORD_REQUIRES_DIGIT = "security.passwordRequiresDigit";
	public static final String GP_PASSWORD_CANNOT_MATCH_USERNAME_OR_SYSTEMID = "security.passwordCannotMatchUsername";
	public static final String GP_PASSWORD_MINIMUM_LENGTH = "security.passwordMinimumLength";
	public static final String GP_PASSWORD_RESET_VALIDTIME = "security.validTime";
	public static final String GP_PASSWORD_CUSTOM_REGEX = "security.passwordCustomRegex";
	public static final String GP_GRAPH_COLOR_ABSOLUTE = "graph.color.absolute";
	public static final String GP_GRAPH_COLOR_NORMAL = "graph.color.normal";
	public static final String GP_GRAPH_COLOR_CRITICAL = "graph.color.critical";
	public static final String GP_SEARCH_WIDGET_BATCH_SIZE = "searchWidget.batchSize";
	public static final String GP_SEARCH_WIDGET_IN_SERIAL_MODE = "searchWidget.runInSerialMode";
	public static final String GP_SEARCH_WIDGET_DELAY_INTERVAL = "searchWidget.searchDelayInterval";
	public static final String GP_SEARCH_WIDGET_MAXIMUM_RESULTS = "searchWidget.maximumResults";
	public static final String GP_SEARCH_DATE_DISPLAY_FORMAT = "searchWidget.dateDisplayFormat";
	public static final String GP_ENABLE_CONCEPT_MAP_TYPE_MANAGEMENT = "concept_map_type_management.enable";
	public static final String GP_VISIT_ASSIGNMENT_HANDLER = "visits.assignmentHandler";
	public static final String GP_ENCOUNTER_TYPE_TO_VISIT_TYPE_MAPPING = "visits.encounterTypeToVisitTypeMapping";
	public static final String GP_DASHBOARD_PROVIDER_DISPLAY_ENCOUNTER_ROLES = "dashboard.encounters.providerDisplayRoles";
	public static final String GP_DASHBOARD_MAX_NUMBER_OF_ENCOUNTERS_TO_SHOW = "dashboard.encounters.maximumNumberToShow";
	public static final String GP_DASHBOARD_METADATA_CASE_CONVERSION = "dashboard.metadata.caseConversion";
	public static final String GP_DEFAULT_CONCEPT_MAP_TYPE = "concept.defaultConceptMapType";
	public static final String GP_CONCEPT_DRUG_DOSAGE_FORM_CONCEPT_CLASSES = "conceptDrug.dosageForm.conceptClasses";
	public static final String GP_CONCEPT_DRUG_ROUTE_CONCEPT_CLASSES = "conceptDrug.route.conceptClasses";
	public static final String GP_ALLERGY_ALLERGEN_CONCEPT_CLASSES = "allergy.allergen.ConceptClasses";
	public static final String GP_ALLERGY_REACTION_CONCEPT_CLASSES = "allergy.reaction.ConceptClasses";
	public static final String GP_ALLERGEN_OTHER_NON_CODED_UUID = "allergy.concept.otherNonCoded";
	public static final String ENCRYPTION_CIPHER_CONFIGURATION = "AES/CBC/PKCS5Padding";
	public static final String ENCRYPTION_KEY_SPEC = "AES";
	public static final String ENCRYPTION_VECTOR_RUNTIME_PROPERTY = "encryption.vector";
	public static final String ENCRYPTION_VECTOR_DEFAULT = "9wyBUNglFCRVSUhMfsTa3Q==";
	public static final String ENCRYPTION_KEY_RUNTIME_PROPERTY = "encryption.key";
	public static final String ENCRYPTION_KEY_DEFAULT = "dTfyELRrAICGDwzjHDjuhw==";
	public static final String GP_VISIT_TYPES_TO_AUTO_CLOSE = "visits.autoCloseVisitType";
	public static final String AUTO_CLOSE_VISITS_TASK_NAME = "Auto Close Visits Task";
	public static final String GP_ALLOWED_FAILED_LOGINS_BEFORE_LOCKOUT = "security.allowedFailedLoginsBeforeLockout";
	public static final String GP_UNLOCK_ACCOUNT_WAITING_TIME  = "security.unlockAccountWaitingTime";
	public static final String GP_CASE_SENSITIVE_DATABASE_STRING_COMPARISON = "search.caseSensitiveDatabaseStringComparison";
	public static final String GP_DASHBOARD_CONCEPTS = "dashboard.header.showConcept";
	public static final String GP_MAIL_SMTP_STARTTLS_ENABLE = "mail.smtp.starttls.enable";
	public static final String GP_NEXT_ORDER_NUMBER_SEED = "order.nextOrderNumberSeed";
	public static final String GP_ORDER_NUMBER_GENERATOR_BEAN_ID = "order.orderNumberGeneratorBeanId";
	public static final String GP_DRUG_ROUTES_CONCEPT_UUID = "order.drugRoutesConceptUuid";
	public static final String GP_DRUG_DOSING_UNITS_CONCEPT_UUID = "order.drugDosingUnitsConceptUuid";
	public static final String GP_DRUG_DISPENSING_UNITS_CONCEPT_UUID = "order.drugDispensingUnitsConceptUuid";
	public static final String GP_DURATION_UNITS_CONCEPT_UUID = "order.durationUnitsConceptUuid";
	public static final String GP_TEST_SPECIMEN_SOURCES_CONCEPT_UUID = "order.testSpecimenSourcesConceptUuid";
	public static final String GP_UNKNOWN_PROVIDER_UUID = "provider.unknownProviderUuid";
	public static final String GP_SEARCH_INDEX_VERSION = "search.indexVersion";
	public static final Integer SEARCH_INDEX_VERSION = 7;
	public static final String GP_DISABLE_VALIDATION = "validation.disable";
	public static final String GP_DRUG_ORDER_DRUG_OTHER = "drugOrder.drugOther";
	@Deprecated
	public static final String GP_HOST_URL = "host.url";
	public static final String GP_PASSWORD_RESET_URL = "security.passwordResetUrl";
	public static final String GP_NUMBER_OF_DAYS_TO_AUTO_RETIRE_USERS = "users.numberOfDaysToRetire";
	public static final List<GlobalProperty> CORE_GLOBAL_PROPERTIES() {
		List<GlobalProperty> props = new ArrayList<>();
		props.add(new GlobalProperty("use_patient_attribute.healthCenter", "false",
		        "Indicates whether or not the 'health center' attribute is shown when viewing/searching for patients",
		        BooleanDatatype.class, null));
		props.add(new GlobalProperty("use_patient_attribute.mothersName", "false",
		        "Indicates whether or not mother's name is able to be added/viewed for a patient", BooleanDatatype.class,
		        null));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_NEWPATIENTFORM_SHOW_RELATIONSHIPS, "false",
		        "true/false whether or not to show the relationship editor on the addPatient.htm screen",
		        BooleanDatatype.class, null));
		props.add(new GlobalProperty("dashboard.overview.showConcepts", "",
		        "Comma delimited list of concepts ids to show on the patient dashboard overview tab"));
		props
		        .add(new GlobalProperty("dashboard.encounters.showEmptyFields", "true",
		                "true/false whether or not to show empty fields on the 'View Encounter' window",
		                BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                "dashboard.encounters.usePages",
		                "smart",
		                "true/false/smart on how to show the pages on the 'View Encounter' window.  'smart' means that if > 50% of the fields have page numbers defined, show data in pages"));
		props.add(new GlobalProperty("dashboard.encounters.showViewLink", "true",
		        "true/false whether or not to show the 'View Encounter' link on the patient dashboard",
		        BooleanDatatype.class, null));
		props.add(new GlobalProperty("dashboard.encounters.showEditLink", "true",
		        "true/false whether or not to show the 'Edit Encounter' link on the patient dashboard",
		        BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                "dashboard.header.programs_to_show",
		                "",
		                "List of programs to show Enrollment details of in the patient header. (Should be an ordered comma-separated list of program_ids or names.)"));
		props
		        .add(new GlobalProperty(
		                "dashboard.header.workflows_to_show",
		                "",
		                "List of programs to show Enrollment details of in the patient header. List of workflows to show current status of in the patient header. These will only be displayed if they belong to a program listed above. (Should be a comma-separated list of program_workflow_ids.)"));
		props.add(new GlobalProperty("dashboard.relationships.show_types", "",
		        "Types of relationships separated by commas.  Doctor/Patient,Parent/Child"));
		props.add(new GlobalProperty("FormEntry.enableDashboardTab", "true",
		        "true/false whether or not to show a Form Entry tab on the patient dashboard", BooleanDatatype.class, null));
		props.add(new GlobalProperty("FormEntry.enableOnEncounterTab", "false",
		        "true/false whether or not to show a Enter Form button on the encounters tab of the patient dashboard",
		        BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                "dashboard.regimen.displayDrugSetIds",
		                "ANTIRETROVIRAL DRUGS,TUBERCULOSIS TREATMENT DRUGS",
		                "Drug sets that appear on the Patient Dashboard Regimen tab. Comma separated list of name of concepts that are defined as drug sets."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_DRUG_FREQUENCIES,
		                "7 days/week,6 days/week,5 days/week,4 days/week,3 days/week,2 days/week,1 days/week",
		                "Frequency of a drug order that appear on the Patient Dashboard. Comma separated list of name of concepts that are defined as drug frequencies."));
		props.add(new GlobalProperty(GP_GRAPH_COLOR_ABSOLUTE, "rgb(20,20,20)",
		        "Color of the 'invalid' section of numeric graphs on the patient dashboard."));
		props.add(new GlobalProperty(GP_GRAPH_COLOR_NORMAL, "rgb(255,126,0)",
		        "Color of the 'normal' section of numeric graphs on the patient dashboard."));
		props.add(new GlobalProperty(GP_GRAPH_COLOR_CRITICAL, "rgb(200,0,0)",
		        "Color of the 'critical' section of numeric graphs on the patient dashboard."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_LOCATION_WIDGET_TYPE, "default",
		        "Type of widget to use for location fields"));
		props.add(new GlobalProperty(GP_MAIL_SMTP_STARTTLS_ENABLE, "false",
		        "Set to true to enable TLS encryption, else set to false"));
		props.add(new GlobalProperty(GP_PASSWORD_RESET_URL, "",
		        "The URL to redirect to after requesting for a password reset. Always provide a place holder in this url with name {activationKey}, it will get substituted by the actual activation key."));
		props.add(new GlobalProperty("mail.transport_protocol", "smtp",
		        "Transport protocol for the messaging engine. Valid values: smtp"));
		props.add(new GlobalProperty("mail.smtp_host", "localhost", "SMTP host name"));
		props.add(new GlobalProperty("mail.smtp_port", "25", "SMTP port"));
		props.add(new GlobalProperty("mail.from", "info@openmrs.org", "Email address to use as the default from address"));
		props.add(new GlobalProperty("mail.debug", "false",
		        "true/false whether to print debugging information during mailing"));
		props.add(new GlobalProperty("mail.smtp_auth", "false", "true/false whether the smtp host requires authentication"));
		props.add(new GlobalProperty("mail.user", "test", "Username of the SMTP user (if smtp_auth is enabled)"));
		props.add(new GlobalProperty("mail.password", "test", "Password for the SMTP user (if smtp_auth is enabled)"));
		props.add(new GlobalProperty("mail.default_content_type", "text/plain",
		        "Content type to append to the mail messages"));
		props.add(new GlobalProperty(ModuleConstants.REPOSITORY_FOLDER_PROPERTY,
		        ModuleConstants.REPOSITORY_FOLDER_PROPERTY_DEFAULT, "Name of the folder in which to store the modules"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_ADDRESS_TEMPLATE, DEFAULT_ADDRESS_TEMPLATE,
		        "XML description of address formats"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_LAYOUT_NAME_FORMAT, PERSON_NAME_FORMAT_SHORT,
		        "Format in which to display the person names.  Valid values are short, long"));
		props.add(new GlobalProperty("scheduler.username", SchedulerConstants.SCHEDULER_DEFAULT_USERNAME,
		        "Username for the OpenMRS user that will perform the scheduler activities"));
		props.add(new GlobalProperty("scheduler.password", SchedulerConstants.SCHEDULER_DEFAULT_PASSWORD,
		        "Password for the OpenMRS user that will perform the scheduler activities"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_CONCEPTS_LOCKED, "false", "if true, do not allow editing concepts",
		        BooleanDatatype.class, null));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_PATIENT_LISTING_ATTRIBUTES, "",
		        "A comma delimited list of PersonAttributeType names that should be displayed for patients in _lists_"));
		props
		        .add(new GlobalProperty(GLOBAL_PROPERTY_PATIENT_VIEWING_ATTRIBUTES, "",
		                "A comma delimited list of PersonAttributeType names that should be displayed for patients when _viewing individually_"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_PATIENT_HEADER_ATTRIBUTES, "",
		        "A comma delimited list of PersonAttributeType names that will be shown on the patient dashboard"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_USER_LISTING_ATTRIBUTES, "",
		        "A comma delimited list of PersonAttributeType names that should be displayed for users in _lists_"));
		props
		        .add(new GlobalProperty(GLOBAL_PROPERTY_USER_VIEWING_ATTRIBUTES, "",
		                "A comma delimited list of PersonAttributeType names that should be displayed for users when _viewing individually_"));
		props
		        .add(new GlobalProperty(GLOBAL_PROPERTY_USER_HEADER_ATTRIBUTES, "",
		                "A comma delimited list of PersonAttributeType names that will be shown on the user dashboard. (not used in v1.5)"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_IDENTIFIER_REGEX,
		                "",
		                "WARNING: Using this search property can cause a drop in mysql performance with large patient sets.  A MySQL regular expression for the patient identifier search strings.  The @SEARCH@ string is replaced at runtime with the user's search string.  An empty regex will cause a simply 'like' sql search to be used. Example: ^0*@SEARCH@([A-Z]+-[0-9])?$"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_IDENTIFIER_PREFIX,
		                "",
		                "This property is only used if "
		                        + GLOBAL_PROPERTY_PATIENT_IDENTIFIER_REGEX
		                        + " is empty.  The string here is prepended to the sql indentifier search string.  The sql becomes \"... where identifier like '<PREFIX><QUERY STRING><SUFFIX>';\".  Typically this value is either a percent sign (%) or empty."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SUFFIX,
		                "",
		                "This property is only used if "
		                        + GLOBAL_PROPERTY_PATIENT_IDENTIFIER_REGEX
		                        + " is empty.  The string here is prepended to the sql indentifier search string.  The sql becomes \"... where identifier like '<PREFIX><QUERY STRING><SUFFIX>';\".  Typically this value is either a percent sign (%) or empty."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SEARCH_PATTERN,
		                "",
		                "If this is empty, the regex or suffix/prefix search is used.  Comma separated list of identifiers to check.  Allows for faster searching of multiple options rather than the slow regex. e.g. @SEARCH@,0@SEARCH@,@SEARCH-1@-@CHECKDIGIT@,0@SEARCH-1@-@CHECKDIGIT@ would turn a request for \"4127\" into a search for \"in ('4127','04127','412-7','0412-7')\""));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_NAME_REGEX,
		                "",
		                "Names of the patients must pass this regex. Eg : ^[a-zA-Z \\-]+$ contains only english alphabet letters, spaces, and hyphens. A value of .* or the empty string means no validation is done."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS, String
		        .valueOf(GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS_DEFAULT_VALUE),
		        "The maximum number of results returned by patient searches"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_GZIP_ENABLED,
		                "false",
		                "Set to 'true' to turn on OpenMRS's gzip filter, and have the webapp compress data before sending it to any client that supports it. Generally use this if you are running Tomcat standalone. If you are running Tomcat behind Apache, then you'd want to use Apache to do gzip compression.",
		                BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_LOG_LEVEL,
		                "org.openmrs.api:" + LOG_LEVEL_INFO,
		                "Logging levels for log4j2.xml. Valid format is class:level,class:level. If class not specified, 'org.openmrs.api' presumed. Valid levels are trace, debug, info, warn, error or fatal"));
		props.add(new GlobalProperty(GP_LOG_LOCATION, "",
		        "A directory where the OpenMRS log file appender is stored. The log file name is 'openmrs.log'."));
		props.add(new GlobalProperty(GP_LOG_LAYOUT, "%p - %C{1}.%M(%L) |%d{ISO8601}| %m%n",
		        "A log layout pattern which is used by the OpenMRS file appender."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR,
		                LUHN_IDENTIFIER_VALIDATOR,
		                "This property sets the default patient identifier validator.  The default validator is only used in a handful of (mostly legacy) instances.  For example, it's used to generate the isValidCheckDigit calculated column and to append the string \"(default)\" to the name of the default validator on the editPatientIdentifierType form."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_IDENTIFIER_IMPORTANT_TYPES,
		                "",
		                "A comma delimited list of PatientIdentifier names : PatientIdentifier locations that will be displayed on the patient dashboard.  E.g.: TRACnet ID:Rwanda,ELDID:Kenya"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_COMPLEX_OBS_DIR, "complex_obs",
		        "Default directory for storing complex obs."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_ENCOUNTER_FORM_OBS_SORT_ORDER,
		                "number",
		                "The sort order for the obs listed on the encounter edit form.  'number' sorts on the associated numbering from the form schema.  'weight' sorts on the order displayed in the form schema."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en, en_GB, es, fr, it, pt",
		        "Comma delimited list of locales allowed for use on system"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_NEWPATIENTFORM_RELATIONSHIPS,
		                "",
		                "Comma separated list of the RelationshipTypes to show on the new/short patient form.  The list is defined like '3a, 4b, 7a'.  The number is the RelationshipTypeId and the 'a' vs 'b' part is which side of the relationship is filled in by the user."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_MIN_SEARCH_CHARACTERS, "2",
		        "Number of characters user must input before searching is started."));
		props
		        .add(new GlobalProperty(
		                OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE,
		                OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE_DEFAULT_VALUE,
		                "Specifies the default locale. You can specify both the language code(ISO-639) and the country code(ISO-3166), e.g. 'en_GB' or just country: e.g. 'en'"));
		props.add(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_WEEK_START_DAY,
		        OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_WEEK_START_DAY_DEFAULT_VALUE,
		        "First day of the week in the date picker. Domingo/Dimanche/Sunday:0  Lunes/Lundi/Monday:1"));
		props.add(new GlobalProperty(GP_PASSWORD_CANNOT_MATCH_USERNAME_OR_SYSTEMID, "true",
		        "Configure whether passwords must not match user's username or system id", BooleanDatatype.class, null));
		props.add(new GlobalProperty(GP_PASSWORD_CUSTOM_REGEX, "",
		        "Configure a custom regular expression that a password must match"));
		props.add(new GlobalProperty(GP_PASSWORD_MINIMUM_LENGTH, "8",
		        "Configure the minimum length required of all passwords"));
		props.add(new GlobalProperty(GP_PASSWORD_RESET_VALIDTIME, "600000",
		        " Specifies the duration of time in seconds for which a password reset token is valid, the default value is 10 minutes and the allowed values range from 1 minute to 12hrs"));
		props.add(new GlobalProperty(GP_PASSWORD_REQUIRES_DIGIT, "true",
		        "Configure whether passwords must contain at least one digit", BooleanDatatype.class, null));
		props.add(new GlobalProperty(GP_PASSWORD_REQUIRES_NON_DIGIT, "true",
		        "Configure whether passwords must contain at least one non-digit", BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(GP_PASSWORD_REQUIRES_UPPER_AND_LOWER_CASE, "true",
		                "Configure whether passwords must contain both upper and lower case characters",
		                BooleanDatatype.class, null));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_IGNORE_MISSING_NONLOCAL_PATIENTS, "false",
		        "If true, hl7 messages for patients that are not found and are non-local will silently be dropped/ignored",
		        BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_SHOW_PATIENT_NAME,
		                "false",
		                "Whether or not to display the patient name in the patient dashboard title. Note that enabling this could be security risk if multiple users operate on the same computer.",
		                BooleanDatatype.class, null));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_DEFAULT_THEME, "",
		        "Default theme for users.  OpenMRS ships with themes of 'green', 'orange', 'purple', and 'legacy'"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_HL7_ARCHIVE_DIRECTORY, HL7Constants.HL7_ARCHIVE_DIRECTORY_NAME,
		        "The default name or absolute path for the folder where to write the hl7_in_archives."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_REPORT_BUG_URL, "http:
		        "The openmrs url where to submit bug reports"));
		props.add(new GlobalProperty(GP_SEARCH_WIDGET_BATCH_SIZE, "200",
		        "The maximum number of search results that are returned by an ajax call"));
		props
		        .add(new GlobalProperty(
		                GP_SEARCH_WIDGET_IN_SERIAL_MODE,
		                "false",
		                "Specifies whether the search widgets should make ajax requests in serial or parallel order, a value of true is appropriate for implementations running on a slow network connection and vice versa",
		                BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                GP_SEARCH_WIDGET_DELAY_INTERVAL,
		                "300",
		                "Specifies time interval in milliseconds when searching, between keyboard keyup event and triggering the search off, should be higher if most users are slow when typing so as to minimise the load on the server"));
		props
		        .add(new GlobalProperty(GP_SEARCH_DATE_DISPLAY_FORMAT, null,
		                "Date display format to be used to display the date somewhere in the UI i.e the search widgets and autocompletes"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_DEFAULT_LOCATION_NAME, "Unknown Location",
		        "The name of the location to use as a system default"));
		props
				.add(new GlobalProperty(
						GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SEARCH_MATCH_MODE,
						GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_EXACT,
						"Specifies how patient identifiers are matched while searching for a patient. Valid values are 'EXACT, 'ANYWHERE' or 'START'. Defaults to 'EXACT' if missing or invalid value is present."));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE,
		                GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_START,
		                "Specifies how patient names are matched while searching patient. Valid values are 'ANYWHERE' or 'START'. Defaults to start if missing or invalid value is present."));
		props.add(new GlobalProperty(GP_ENABLE_CONCEPT_MAP_TYPE_MANAGEMENT, "false",
		        "Enables or disables management of concept map types", BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_ENABLE_VISITS,
		                "true",
		                "Set to true to enable the Visits feature. This will replace the 'Encounters' tab with a 'Visits' tab on the dashboard.",
		                BooleanDatatype.class, null));
		props.add(new GlobalProperty(GP_VISIT_ASSIGNMENT_HANDLER, ExistingVisitAssignmentHandler.class.getName(),
		        "Set to the name of the class responsible for assigning encounters to visits."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_APPLICATION_NAME, "OpenMRS",
		        "The name of this application, as presented to the user, for example on the login and welcome pages."));
		props
		        .add(new GlobalProperty(
		                GP_ENCOUNTER_TYPE_TO_VISIT_TYPE_MAPPING,
		                "",
		                "Specifies how encounter types are mapped to visit types when automatically assigning encounters to visits. e.g 1:1, 2:1, 3:2 in the format encounterTypeId:visitTypeId or encounterTypeUuid:visitTypeUuid or a combination of encounter/visit type uuids and ids e.g 1:759799ab-c9a5-435e-b671-77773ada74e4"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_ENCOUNTER_TYPES_LOCKED, "false",
		        "saving, retiring or deleting an Encounter Type is not permitted, if true", BooleanDatatype.class, null));
		props
		        .add(new GlobalProperty(
		                GP_DASHBOARD_PROVIDER_DISPLAY_ENCOUNTER_ROLES,
		                "",
		                "A comma-separated list of encounter roles (by name or id). Providers with these roles in an encounter will be displayed on the encounter tab of the patient dashboard."));
		props.add(new GlobalProperty(GP_SEARCH_WIDGET_MAXIMUM_RESULTS, "2000",
		        "Specifies the maximum number of results to return from a single search in the search widgets"));
		props
		        .add(new GlobalProperty(
		                GP_DASHBOARD_MAX_NUMBER_OF_ENCOUNTERS_TO_SHOW,
		                "3",
		                "An integer which, if specified, would determine the maximum number of encounters to display on the encounter tab of the patient dashboard."));
		props.add(new GlobalProperty(GP_VISIT_TYPES_TO_AUTO_CLOSE, "",
		        "comma-separated list of the visit type(s) to automatically close"));
		props.add(new GlobalProperty(GP_ALLOWED_FAILED_LOGINS_BEFORE_LOCKOUT, "7",
		        "Maximum number of failed logins allowed after which username is locked out"));
		props.add(new GlobalProperty(GP_UNLOCK_ACCOUNT_WAITING_TIME, "5",
			"Waiting time for account to get automatically unlocked after getting locked due to multiple invalid login tries"));
		props.add(new GlobalProperty(GP_DEFAULT_CONCEPT_MAP_TYPE, "NARROWER-THAN",
		        "Default concept map type which is used when no other is set"));
		props
		        .add(new GlobalProperty(GP_CONCEPT_DRUG_DOSAGE_FORM_CONCEPT_CLASSES, "",
		                "A comma-separated list of the allowed concept classes for the dosage form field of the concept drug management form."));
		props
		        .add(new GlobalProperty(GP_CONCEPT_DRUG_ROUTE_CONCEPT_CLASSES, "",
		                "A comma-separated list of the allowed concept classes for the route field of the concept drug management form."));
		props
		        .add(new GlobalProperty(
		                GP_CASE_SENSITIVE_DATABASE_STRING_COMPARISON,
		                "false",
		                "Indicates whether database string comparison is case sensitive or not. Setting this to false for MySQL with a case insensitive collation improves search performance."));
		props
		        .add(new GlobalProperty(
		                GP_DASHBOARD_METADATA_CASE_CONVERSION,
		                "",
		                "Indicates which type automatic case conversion is applied to program/workflow/state in the patient dashboard. Valid values: lowercase, uppercase, capitalize. If empty no conversion is applied."));
		props.add(new GlobalProperty(GP_ALLERGY_ALLERGEN_CONCEPT_CLASSES, "Drug,MedSet",
		        "A comma-separated list of the allowed concept classes for the allergen field of the allergy dialog"));
		props.add(new GlobalProperty(GP_ALLERGY_REACTION_CONCEPT_CLASSES, "Symptom",
		        "A comma-separated list of the allowed concept classes for the reaction field of the allergy dialog"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_USER_REQUIRE_EMAIL_AS_USERNAME, "false",
		        "Indicates whether a username must be a valid e-mail or not.", BooleanDatatype.class, null));
		props.add(new GlobalProperty(GP_SEARCH_INDEX_VERSION, "",
		        "Indicates the index version. If it is blank, the index needs to be rebuilt."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_ALLOW_OVERLAPPING_VISITS, "true",
		        "true/false whether or not to allow visits of a given patient to overlap", BooleanDatatype.class, null));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_FORMS_LOCKED, "false",
		        "Set to a value of true if you do not want any changes to be made on forms, else set to false."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_DRUG_ORDER_REQUIRE_DRUG, "false",
		        "Set to value true if you need to specify a formulation(Drug) when creating a drug order."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_DRUG_ORDER_REQUIRE_OUTPATIENT_QUANTITY, "true",
			"true/false whether to require quantity, quantityUnits, and numRefills for outpatient drug orders"));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_PERSON_ATRIBUTE_TYPES_LOCKED, "false",
		        "Set to a value of true if you do not want allow editing person attribute types, else set to false."));
		props.add(new GlobalProperty(GLOBAL_PROPERTY_PATIENT_IDENTIFIER_TYPES_LOCKED, "false",
		        "Set to a value of true if you do not want allow editing patient identifier types, else set to false."));
		props.add(new GlobalProperty(GP_NEXT_ORDER_NUMBER_SEED, "1", "The next order number available for assignment"));
		props.add(new GlobalProperty(GP_ORDER_NUMBER_GENERATOR_BEAN_ID, "",
		        "Specifies spring bean id of the order generator to use when assigning order numbers"));
		props.add(new GlobalProperty(GP_DRUG_ROUTES_CONCEPT_UUID, "",
		        "Specifies the uuid of the concept set where its members represent the possible drug routes"));
		props.add(new GlobalProperty(GP_DRUG_DOSING_UNITS_CONCEPT_UUID, "",
		        "Specifies the uuid of the concept set where its members represent the possible drug dosing units"));
		props.add(new GlobalProperty(GP_DRUG_DISPENSING_UNITS_CONCEPT_UUID, "",
		        "Specifies the uuid of the concept set where its members represent the possible drug dispensing units"));
		props.add(new GlobalProperty(GP_DURATION_UNITS_CONCEPT_UUID, "",
		        "Specifies the uuid of the concept set where its members represent the possible duration units"));
		props.add(new GlobalProperty(GP_TEST_SPECIMEN_SOURCES_CONCEPT_UUID, "",
		        "Specifies the uuid of the concept set where its members represent the possible test specimen sources"));
		props.add(new GlobalProperty(GP_UNKNOWN_PROVIDER_UUID, "", "Specifies the uuid of the Unknown Provider account"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PROVIDER_SEARCH_MATCH_MODE,
		                "EXACT",
		                "Specifies how provider identifiers are matched while searching for providers. Valid values are START,EXACT, END or ANYWHERE"));
		props
		        .add(new GlobalProperty(
		                GLOBAL_PROPERTY_PERSON_ATTRIBUTE_SEARCH_MATCH_MODE,
		                GLOBAL_PROPERTY_PERSON_ATTRIBUTE_SEARCH_MATCH_EXACT,
		                "Specifies how person attributes are matched while searching person. Valid values are 'ANYWHERE' or 'EXACT'. Defaults to exact if missing or invalid value is present."));
		props.add(new GlobalProperty(GP_DISABLE_VALIDATION, "false",
				"Disables validation of OpenMRS Objects. Only takes affect on next restart. Warning: only do this is you know what you are doing!"));
		props.add(new GlobalProperty("allergy.concept.severity.mild", "1498AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the MILD severity concept"));
		props.add(new GlobalProperty("allergy.concept.severity.moderate", "1499AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the MODERATE severity concept"));
		props.add(new GlobalProperty("allergy.concept.severity.severe", "1500AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the SEVERE severity concept"));
		props.add(new GlobalProperty("allergy.concept.allergen.food", "162553AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the food allergens concept"));
		props.add(new GlobalProperty("allergy.concept.allergen.drug", "162552AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the drug allergens concept"));
		props.add(new GlobalProperty("allergy.concept.allergen.environment", "162554AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the environment allergens concept"));
		props.add(new GlobalProperty("allergy.concept.reactions", "162555AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the allergy reactions concept"));
		props.add(new GlobalProperty(GP_ALLERGEN_OTHER_NON_CODED_UUID, "5622AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the allergy other non coded concept"));
		props.add(new GlobalProperty("allergy.concept.unknown", "1067AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
		        "UUID for the allergy unknown concept"));
		props
				.add(new GlobalProperty(GP_DRUG_ORDER_DRUG_OTHER, "", "Specifies the uuid of the concept which represents drug other non coded"));
		props.add(new GlobalProperty(GP_LOGIN_URL, LOGIN_URL,
			"Responsible for defining the Authentication URL "));
		props.addAll(ModuleFactory.getGlobalProperties());
		return props;
	}
	public static final String PROPOSED_CONCEPT_IDENTIFIER = "PROPOSED";
	public static final String CONCEPT_PROPOSAL_UNMAPPED = "UNMAPPED";
	public static final String CONCEPT_PROPOSAL_CONCEPT = "CONCEPT";
	public static final String CONCEPT_PROPOSAL_SYNONYM = "SYNONYM";
	public static final String CONCEPT_PROPOSAL_REJECT = "REJECT";
	public static final Collection<String> CONCEPT_PROPOSAL_STATES() {
		Collection<String> states = new ArrayList<>();
		states.add(CONCEPT_PROPOSAL_UNMAPPED);
		states.add(CONCEPT_PROPOSAL_CONCEPT);
		states.add(CONCEPT_PROPOSAL_SYNONYM);
		states.add(CONCEPT_PROPOSAL_REJECT);
		return states;
	}
	public static final Locale SPANISH_LANGUAGE = new Locale("es");
	public static final Locale PORTUGUESE_LANGUAGE = new Locale("pt");
	public static final Locale ITALIAN_LANGUAGE = new Locale("it");
	public static final String USER_PROPERTY_CHANGE_PASSWORD = "forcePassword";
	public static final String USER_PROPERTY_DEFAULT_LOCALE = "defaultLocale";
	public static final String USER_PROPERTY_DEFAULT_LOCATION = "defaultLocation";
	public static final String USER_PROPERTY_SHOW_RETIRED = "showRetired";
	public static final String USER_PROPERTY_SHOW_VERBOSE = "showVerbose";
	public static final String USER_PROPERTY_NOTIFICATION = "notification";
	public static final String USER_PROPERTY_NOTIFICATION_ADDRESS = "notificationAddress";
	public static final String USER_PROPERTY_NOTIFICATION_FORMAT = "notificationFormat"; 
	public static final String USER_PROPERTY_LOGIN_ATTEMPTS = "loginAttempts";
	public static final String USER_PROPERTY_LOCKOUT_TIMESTAMP = "lockoutTimestamp";
	public static final String USER_PROPERTY_PROFICIENT_LOCALES = "proficientLocales";
	public static final String USER_PROPERTY_LAST_LOGIN_TIMESTAMP = "lastLoginTimestamp";
	public static final String OPERATING_SYSTEM_KEY = "os.name";
	public static final String OPERATING_SYSTEM = System.getProperty(OPERATING_SYSTEM_KEY);
	public static final String OPERATING_SYSTEM_WINDOWS_XP = "Windows XP";
	public static final String OPERATING_SYSTEM_WINDOWS_VISTA = "Windows Vista";
	public static final String OPERATING_SYSTEM_LINUX = "Linux";
	public static final String OPERATING_SYSTEM_SUNOS = "SunOS";
	public static final String OPERATING_SYSTEM_FREEBSD = "FreeBSD";
	public static final String OPERATING_SYSTEM_OSX = "Mac OS X";
	public static final String IMPLEMENTATION_ID_REMOTE_CONNECTION_URL = "https:
	public static final boolean UNIX_BASED_OPERATING_SYSTEM = (OPERATING_SYSTEM.contains(OPERATING_SYSTEM_LINUX)
	        || OPERATING_SYSTEM.contains(OPERATING_SYSTEM_SUNOS)
	        || OPERATING_SYSTEM.contains(OPERATING_SYSTEM_FREEBSD) || OPERATING_SYSTEM.contains(OPERATING_SYSTEM_OSX));
	public static final boolean WINDOWS_BASED_OPERATING_SYSTEM = OPERATING_SYSTEM.contains("Windows");
	public static final boolean WINDOWS_VISTA_OPERATING_SYSTEM = OPERATING_SYSTEM.equals(OPERATING_SYSTEM_WINDOWS_VISTA);
	public static final String SHORT_SERIALIZATION = "isShortSerialization";
	public static final String GLOBAL_PROPERTY_LOG_LEVEL = "log.level";
	public static final String GP_LOG_LOCATION = "log.location";
	public static final String GP_LOG_LAYOUT = "log.layout";
	public static final String LOG_OPENMRS_FILE_APPENDER = "OPENMRS FILE APPENDER";
	public static final String LOG_CLASS_DEFAULT = "org.openmrs.api";
	public static final String LOG_LEVEL_TRACE = "trace";
	public static final String LOG_LEVEL_DEBUG = "debug";
	public static final String LOG_LEVEL_INFO = "info";
	public static final String LOG_LEVEL_WARN = "warn";
	public static final String LOG_LEVEL_ERROR = "error";
	public static final String LOG_LEVEL_FATAL = "fatal";
	public static final String MEMORY_APPENDER_NAME = "MEMORY_APPENDER";
	public static final String LOGIN_URL = "login.htm";
	public static final String GP_LOGIN_URL = "login.url";
	public static enum PERSON_TYPE {
		PERSON,
		PATIENT,
		USER
	}
	public static final String LUHN_IDENTIFIER_VALIDATOR = LuhnIdentifierValidator.class.getName();
	public static final String DEFAULT_CUSTOM_DATATYPE = FreeTextDatatype.class.getName();
	public static final String REGISTERED_COMPONENT_NAME_PREFIX = "bean:";
	public static final String PERSON_NAME_FORMAT_SHORT = "short";
	public static final String PERSON_NAME_FORMAT_LONG = "long";
	public static final String LIQUIBASE_DUPLICATE_FILE_MODE_DEFAULT = GlobalConfiguration.DuplicateFileMode.WARN.name();
	public static final String ZERO_LOGIN_ATTEMPTS_VALUE = "0";
	private OpenmrsConstants() {
	}
}
_____
package org.openmrs.api.context;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.stream.Collectors;
import org.apache.commons.collections.CollectionUtils;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.APIAuthenticationException;
import org.openmrs.api.APIException;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.db.ContextDAO;
import org.openmrs.module.DaemonToken;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleException;
import org.openmrs.module.ModuleFactory;
import org.openmrs.scheduler.Task;
import org.openmrs.scheduler.timer.TimerSchedulerTask;
import org.openmrs.util.OpenmrsSecurityManager;
import org.openmrs.util.OpenmrsThreadPoolHolder;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
public final class Daemon {
	static final String DAEMON_USER_UUID = "A4F30A1B-5EB9-11DF-A648-37A07F9C90FB";
	private static final ThreadLocal<Boolean> isDaemonThread = new ThreadLocal<>();
	private static final ThreadLocal<User> daemonThreadUser = new ThreadLocal<>();
	private Daemon() {
	}
	public static Module startModule(Module module) throws ModuleException {
		return startModule(module, false, null);
	}
	public static Module startModule(final Module module, final boolean isOpenmrsStartup,
	        final AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (callerClass != Daemon.class && callerClass != ModuleFactory.class) {
			throw new APIException("Module.factory.only", new Object[] { callerClass.getName() });
		}
		Future<Module> moduleStartFuture = runInDaemonThreadInternal(() -> ModuleFactory.startModuleInternal(module, isOpenmrsStartup, applicationContext));
		try {
			return moduleStartFuture.get();
		}
		catch (InterruptedException e) {
		} catch (ExecutionException e) {
			if (e.getCause() instanceof ModuleException) {
				throw (ModuleException) e.getCause();
			} else {
				throw new ModuleException("Unable to start module " + module.getName(), e);
			}
		}
		return module;
	}
	public static User createUser(User user, String password, List<String> roleNames) throws Exception {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (!ContextDAO.class.isAssignableFrom(callerClass)) {
			throw new APIException("Context.DAO.only", new Object[] { callerClass.getName() });
		}
		Future<User> userFuture = runInDaemonThreadInternal(() -> {
			if ((user.getId() != null && Context.getUserService().getUser(user.getId()) != null) || Context.getUserService().getUserByUuid(user.getUuid()) != null || Context.getUserService().getUserByUsername(user.getUsername()) != null || (user.getEmail() != null && Context.getUserService().getUserByUsernameOrEmail(user.getEmail()) != null) ) {
				throw new APIException("User.creating.already.exists", new Object[] { user.getDisplayString() });
			}
			if (!CollectionUtils.isEmpty(roleNames)) {
				List<Role> roles = roleNames.stream().map(roleName -> Context.getUserService().getRole(roleName)).collect(Collectors.toList());
				roles.forEach(user::addRole);
			}
			return Context.getUserService().createUser(user, password);
		});
		try {
			return userFuture.get();
		}
		catch (InterruptedException e) {
		}
		catch (ExecutionException e) {
			if (e.getCause() instanceof Exception) {
				throw (Exception) e.getCause();
			} else {
				throw new RuntimeException(e.getCause());
			}
		}
		return null;
	}	
	public static void executeScheduledTask(final Task task) throws Exception {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (!TimerSchedulerTask.class.isAssignableFrom(callerClass)) {
			throw new APIException("Scheduler.timer.task.only", new Object[] { callerClass.getName() });
		}
		Future<?> scheduleTaskFuture = runInDaemonThreadInternal(() -> TimerSchedulerTask.execute(task));
		try {
			scheduleTaskFuture.get();
		}
		catch (InterruptedException e) {
		} catch (ExecutionException e) {
			if (e.getCause() instanceof Exception) {
				throw (Exception) e.getCause();
			} else {
				throw new RuntimeException(e.getCause());
			}
		}
	}
	@Deprecated
	public static Thread runInNewDaemonThread(final Runnable runnable) {
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		final CountDownLatch countDownLatch = new CountDownLatch(1);
		DaemonThread thread = new DaemonThread() {
			@Override
			public void run() {
				isDaemonThread.set(true);
				try {
					Context.openSession();
					countDownLatch.countDown();
					runnable.run();
				}
				finally {
					try {
						Context.closeSession();
					} finally {
						isDaemonThread.remove();
						daemonThreadUser.remove();
					}
				}
			}
		};
		OpenmrsThreadPoolHolder.threadExecutor.execute(thread);
		try {
			countDownLatch.await();
		} catch (InterruptedException ignored) {
		}
		return thread;
	}
	@SuppressWarnings({"squid:S1217", "unused"})
	public static <T> Future<T> runInNewDaemonThread(final Callable<T> callable) {
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		return runInDaemonThreadInternal(callable);
	}
	@SuppressWarnings({"squid:S1217", "unused"})
	public static Future<?> runNewDaemonTask(final Runnable runnable) {
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		return runInDaemonThreadInternal(runnable);
	}
	public static boolean isDaemonThread() {
		Boolean b = isDaemonThread.get();
		if (b == null || !b) {
			Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(1);
			return callerClass.equals(Daemon.class) || callerClass.getName().equals("org.openmrs.web.WebDaemon");
		} else {
			return true;
		}
	}
	public static void runStartupForService(final OpenmrsService service) throws ModuleException {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (callerClass != ServiceContext.class) {
			throw new APIException("Service.context.only", new Object[] { callerClass.getName() });
		}
		Future<?> future = runInDaemonThreadInternal(service::onStartup);
		try {
			future.get();
		}
		catch (InterruptedException e) {
		}
		catch (ExecutionException e) {
			if (e.getCause() instanceof ModuleException) {
				throw (ModuleException) e.getCause();
			} else {
				throw new ModuleException("Unable to run onStartup() method of service {}", service.getClass().getSimpleName(), e);
			}
		}
	}
	@Deprecated
	@SuppressWarnings({"squid:S1217", "unused"})
	public static Thread runInDaemonThread(final Runnable runnable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token " + token);
		}
		DaemonThread thread = new DaemonThread() {
			@Override
			public void run() {
				isDaemonThread.set(true);
				try {
					Context.openSession();
					runnable.run();
				}
				finally {
					try {
						Context.closeSession();
					} finally {
						isDaemonThread.remove();
						daemonThreadUser.remove();
					}
				}
			}
		};
		OpenmrsThreadPoolHolder.threadExecutor.execute(thread);
		return thread;
	}
	@SuppressWarnings({"squid:S1217", "unused"})
	public static <T> Future<T> runInDaemonThread(final Callable<T> callable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token");
		}
		return runInDaemonThreadInternal(callable);
	}
	@SuppressWarnings("squid:S1217")
	public static Future<?> runInDaemonThreadWithoutResult(final Runnable runnable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token");
		}
		return runInDaemonThreadInternal(runnable);
	}
	public static void runInDaemonThreadAndWait(final Runnable runnable, DaemonToken token) {
		Future<?> daemonThread = runInDaemonThreadWithoutResult(runnable, token);
		try {
			daemonThread.get();
		}
		catch (InterruptedException | ExecutionException e) {
		}
	}
	private static <T> Future<T> runInDaemonThreadInternal(Callable<T> callable) {
		return OpenmrsThreadPoolHolder.threadExecutor.submit(() -> {
			isDaemonThread.set(true);
			try {
				Context.openSession();
				return callable.call();
			}
			finally {
				try {
					Context.closeSession();
				} finally {
					isDaemonThread.remove();
					daemonThreadUser.remove();
				}
			}
		});
	}
	private static Future<?> runInDaemonThreadInternal(Runnable runnable) {
		CountDownLatch countDownLatch = getCountDownLatch(runnable instanceof Thread);
		Future<?> result = OpenmrsThreadPoolHolder.threadExecutor.submit(() -> {
			isDaemonThread.set(true);
			try {
				Context.openSession();
				countDownLatch.countDown();
				runnable.run();
			}
			finally {
				try {
					Context.closeSession();
				} finally {
					isDaemonThread.remove();
					daemonThreadUser.remove();
				}
			}
		});
		try {
			countDownLatch.await();
		} catch (InterruptedException ignored) {}
		return result;
	}
	private static CountDownLatch getCountDownLatch(boolean isThread) {
		return isThread ? new CountDownLatch(1) : new CountDownLatch(0);
	}
	protected static class DaemonThread extends Thread {
		protected Object returnedObject = null;
		protected Exception exceptionThrown = null;
		public Exception getExceptionThrown() {
			return exceptionThrown;
		}
	}
	public static boolean isDaemonUser(User user) {
		return DAEMON_USER_UUID.equals(user.getUuid());
	}
	public static User getDaemonThreadUser() {
		if (isDaemonThread()) {
			User user = daemonThreadUser.get();
			if (user == null) {
				user = Context.getContextDAO().getUserByUuid(DAEMON_USER_UUID);
				daemonThreadUser.set(user);
			}
			return user;
		} else {
			return null;
		}
	}
	public static String getDaemonUserUuid() {
		return DAEMON_USER_UUID;
	}
}
_____
package org.openmrs.api;
public class ServiceNotFoundException extends APIException {
	private final Class serviceClass;
	public <T> ServiceNotFoundException(Class<T> serviceClass) {
		super("Service not found: " + serviceClass);
		this.serviceClass = serviceClass;
	}
	@SuppressWarnings("unchecked")
	public <T> Class<T> getServiceClass() {
		return serviceClass;
	}
}
_____
package org.openmrs.customdatatype;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.ConceptDatatype;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import org.openmrs.attribute.Attribute;
import org.openmrs.attribute.AttributeType;
import org.openmrs.serialization.SerializationException;
import org.openmrs.util.OpenmrsConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class CustomDatatypeUtil {
	private CustomDatatypeUtil() {
	}
	private static final Logger log = LoggerFactory.getLogger(CustomDatatypeUtil.class);
	public static CustomDatatype<?> getDatatype(CustomValueDescriptor descriptor) {
		return getDatatype(descriptor.getDatatypeClassname(), descriptor.getDatatypeConfig());
	}
	public static CustomDatatype<?> getDatatype(String datatypeClassname, String datatypeConfig) {
		try {
			Class dtClass = Context.loadClass(datatypeClassname);
			CustomDatatype<?> ret = (CustomDatatype<?>) Context.getDatatypeService().getDatatype(dtClass, datatypeConfig);
			if (ret == null) {
				throw new CustomDatatypeException("Can't find datatype: " + datatypeClassname);
			}
			return ret;
		}
		catch (Exception ex) {
			throw new CustomDatatypeException("Error loading " + datatypeClassname + " and configuring it with "
			        + datatypeConfig, ex);
		}
	}
	public static CustomDatatype<?> getDatatypeOrDefault(CustomValueDescriptor descriptor) {
		try {
			return getDatatype(descriptor);
		}
		catch (CustomDatatypeException ex) {
			return getDatatype(OpenmrsConstants.DEFAULT_CUSTOM_DATATYPE, null);
		}
	}
	public static CustomDatatypeHandler getHandler(CustomValueDescriptor descriptor) {
		return getHandler(getDatatypeOrDefault(descriptor), descriptor.getPreferredHandlerClassname(), descriptor
		        .getHandlerConfig());
	}
	public static CustomDatatypeHandler getHandler(CustomDatatype<?> dt, String preferredHandlerClassname,
	        String handlerConfig) {
		if (preferredHandlerClassname != null) {
			try {
				Class<? extends CustomDatatypeHandler> clazz = (Class<? extends CustomDatatypeHandler>) Context
				        .loadClass(preferredHandlerClassname);
				CustomDatatypeHandler handler = clazz.newInstance();
				if (handlerConfig != null) {
					handler.setHandlerConfiguration(handlerConfig);
				}
				return handler;
			}
			catch (Exception ex) {
				log.warn("Failed to instantiate and configure preferred handler with class " + preferredHandlerClassname
				        + " and config " + handlerConfig, ex);
			}
		}
		return Context.getDatatypeService().getHandler(dt, handlerConfig);
	}
	public static String serializeSimpleConfiguration(Map<String, String> simpleConfig) {
		if (simpleConfig == null || simpleConfig.size() == 0) {
			return "";
		}
		try {
			return Context.getSerializationService().getDefaultSerializer().serialize(simpleConfig);
		}
		catch (SerializationException ex) {
			throw new APIException(ex);
		}
	}
	@SuppressWarnings("unchecked")
	public static Map<String, String> deserializeSimpleConfiguration(String serializedConfig) {
		if (StringUtils.isBlank(serializedConfig)) {
			return Collections.emptyMap();
		}
		try {
			return Context.getSerializationService().getDefaultSerializer().deserialize(serializedConfig, Map.class);
		}
		catch (SerializationException ex) {
			throw new APIException(ex);
		}
	}
	public static <T extends AttributeType<?>, U> Map<T, String> getValueReferences(Map<T, U> datatypeValues) {
		Map<T, String> serializedAttributeValues = null;
		if (datatypeValues != null) {
			serializedAttributeValues = new HashMap<>();
			for (Map.Entry<T, U> e : datatypeValues.entrySet()) {
				T vat = e.getKey();
				CustomDatatype<U> customDatatype = (CustomDatatype<U>) getDatatype(vat);
				String valueReference;
				try {
					valueReference = customDatatype.getReferenceStringForValue(e.getValue());
				}
				catch (UnsupportedOperationException ex) {
					throw new APIException("CustomDatatype.error.cannot.search", new Object[] { customDatatype.getClass() });
				}
				serializedAttributeValues.put(vat, valueReference);
			}
		}
		return serializedAttributeValues;
	}
	public static List<String> getDatatypeClassnames() {
		List<String> ret = new ArrayList<>();
		for (Class<?> c : Context.getDatatypeService().getAllDatatypeClasses()) {
			ret.add(c.getName());
		}
		return ret;
	}
	public static List<String> getHandlerClassnames() {
		List<String> ret = new ArrayList<>();
		for (Class<?> c : Context.getDatatypeService().getAllHandlerClasses()) {
			ret.add(c.getName());
		}
		return ret;
	}
	public static boolean isCompatibleHandler(CustomDatatypeHandler handler, CustomDatatype<?> datatype) {
		List<Class<? extends CustomDatatypeHandler>> handlerClasses = Context.getDatatypeService().getHandlerClasses(
		    (Class<? extends CustomDatatype<?>>) datatype.getClass());
		return handlerClasses.contains(handler.getClass());
	}
	public static void saveAttributesIfNecessary(Customizable<?> customizable) {
		for (Attribute attr : customizable.getAttributes()) {
			saveIfDirty(attr);
		}
	}
	public static void saveIfDirty(SingleCustomValue<?> value) {
		if (value.isDirty()) {
			CustomDatatype datatype = CustomDatatypeUtil.getDatatype(value.getDescriptor());
			if (value.getValue() == null) {
				throw new InvalidCustomValueException(value.getClass() + " with type=" + value.getDescriptor()
				        + " cannot be null");
			}
			String existingValueReference = null;
			try {
				existingValueReference = value.getValueReference();
			}
			catch (NotYetPersistedException ex) {
			}
			String newValueReference = datatype.save(value.getValue(), existingValueReference);
			value.setValueReferenceInternal(newValueReference);
		}
	}
	@SuppressWarnings("unchecked")
	public static <T, D extends CustomValueDescriptor> boolean validate(SingleCustomValue<D> value) {
		try {
			CustomDatatype<T> datatype = (CustomDatatype<T>) getDatatype(value.getDescriptor());
			datatype.validate((T) value.getValue());
			return true;
		}
		catch (Exception ex) {
			return false;
		}
	}
}
_____
package org.openmrs.api;
import org.openmrs.api.context.Context;
public class APIException extends RuntimeException {
	public static final long serialVersionUID = 12121212L;
	public APIException() {
	}
	public APIException(String message) {
		super(message);
	}
	public APIException(String message, Throwable cause) {
		super(message, cause);
	}
	public APIException(Throwable cause) {
		super(cause);
	}
	public APIException(String messageKey, Object[] parameters) {
		super(Context.getMessageSourceService().getMessage(messageKey, parameters, Context.getLocale()));
	}
	public APIException(String messageKey, Object[] parameters, Throwable cause) {
		super(Context.getMessageSourceService().getMessage(messageKey, parameters, Context.getLocale()), cause);
	}
}
_____
package org.openmrs.api.context;
import org.aopalliance.aop.Advice;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.SessionFactory;
import org.openmrs.Allergen;
import org.openmrs.GlobalProperty;
import org.openmrs.OpenmrsObject;
import org.openmrs.PersonName;
import org.openmrs.Privilege;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.CohortService;
import org.openmrs.api.ConceptService;
import org.openmrs.api.ConditionService;
import org.openmrs.api.DatatypeService;
import org.openmrs.api.DiagnosisService;
import org.openmrs.api.EncounterService;
import org.openmrs.api.FormService;
import org.openmrs.api.LocationService;
import org.openmrs.api.MedicationDispenseService;
import org.openmrs.api.ObsService;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.OrderService;
import org.openmrs.api.OrderSetService;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.ProviderService;
import org.openmrs.api.SerializationService;
import org.openmrs.api.UserService;
import org.openmrs.api.VisitService;
import org.openmrs.api.db.ContextDAO;
import org.openmrs.hl7.HL7Service;
import org.openmrs.logic.LogicService;
import org.openmrs.messagesource.MessageSourceService;
import org.openmrs.module.ModuleMustStartException;
import org.openmrs.module.ModuleUtil;
import org.openmrs.notification.AlertService;
import org.openmrs.notification.MessageException;
import org.openmrs.notification.MessagePreparator;
import org.openmrs.notification.MessageSender;
import org.openmrs.notification.MessageService;
import org.openmrs.notification.mail.MailMessageSender;
import org.openmrs.notification.mail.velocity.VelocityMessagePreparator;
import org.openmrs.scheduler.SchedulerService;
import org.openmrs.scheduler.SchedulerUtil;
import org.openmrs.util.ConfigUtil;
import org.openmrs.util.DatabaseUpdateException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.validator.ValidateUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Advisor;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.NoUniqueBeanDefinitionException;
import javax.mail.Authenticator;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import java.sql.Connection;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.Future;
public class Context {
	private static final Logger log = LoggerFactory.getLogger(Context.class);
	private static ContextDAO contextDAO;
	private static Session mailSession;
	private static final ThreadLocal<Object[] > userContextHolder = new ThreadLocal<>();
	private static volatile ServiceContext serviceContext;
	private static Properties runtimeProperties = new Properties();
	private static Properties configProperties = new Properties();
	private static AuthenticationScheme authenticationScheme;
	public Context() {
	}
	static ContextDAO getContextDAO() {
		if (contextDAO == null) {
			throw new APIException("error.context.null", (Object[]) null);
		}
		return contextDAO;
	}
	public void setContextDAO(ContextDAO dao) {
		setDAO(dao);
	}
	public static void setDAO(ContextDAO dao) {
		contextDAO = dao;
	}
	private static void setAuthenticationScheme() {
		authenticationScheme = new UsernamePasswordAuthenticationScheme();
		try {
			authenticationScheme = Context.getServiceContext().getApplicationContext().getBean(AuthenticationScheme.class); 
			log.info("An authentication scheme override was provided. Using this one in place of the OpenMRS default authentication scheme.");
		}
		catch(NoUniqueBeanDefinitionException e) {
			log.error("Multiple authentication schemes overrides are being provided, this is currently not supported. Sticking to OpenMRS default authentication scheme.");
		}
		catch(NoSuchBeanDefinitionException e) {
			log.debug("No authentication scheme override was provided. Sticking to OpenMRS default authentication scheme.");
		}
		catch(BeansException e){
			log.error("Fatal error encountered when injecting the authentication scheme override. Sticking to OpenMRS default authentication scheme.");
		}
	}
	public static Class<?> loadClass(String className) throws ClassNotFoundException {
		return OpenmrsClassLoader.getInstance().loadClass(className);
	}
	public static void setUserContext(UserContext ctx) {
		log.trace("Setting user context {}", ctx);
		Object[] arr = new Object[] { ctx };
		userContextHolder.set(arr);
	}
	public static void clearUserContext() {
		log.trace("Clearing user context {}", Arrays.toString(userContextHolder.get()));
		userContextHolder.remove();
	}
	public static UserContext getUserContext() {
		Object[] arr = userContextHolder.get();
		log.trace("Getting user context {} from userContextHolder {}", Arrays.toString(arr), userContextHolder);
		if (arr == null) {
			log.trace("userContext is null.");
			throw new APIException(
					"A user context must first be passed to setUserContext()...use Context.openSession() (and closeSession() to prevent memory leaks!) before using the API");
		}
		return (UserContext) userContextHolder.get()[0];
	}
	static ServiceContext getServiceContext() {
		if (serviceContext == null) {
			synchronized (Context.class) {
				if (serviceContext == null) {
					log.info("Creating new service context");
					serviceContext = ServiceContext.getInstance();
				}
			}
		}
		log.trace("serviceContext: {}", serviceContext);
		return ServiceContext.getInstance();
	}
	public void setServiceContext(ServiceContext ctx) {
		setContext(ctx);
	}
	public static void setContext(ServiceContext ctx) {
		serviceContext = ctx;
	}
	public static AuthenticationScheme getAuthenticationScheme() {
		return authenticationScheme;
	}
	@Deprecated
	public static void authenticate(String username, String password) throws ContextAuthenticationException {
		authenticate(new UsernamePasswordCredentials(username, password));
	}
	public static Authenticated authenticate(Credentials credentials) throws ContextAuthenticationException {
		if (Daemon.isDaemonThread()) {
			log.error("Authentication attempted while operating on a "
					+ "daemon thread, authenticating is not necessary or allowed");
			return new BasicAuthenticated(Daemon.getDaemonThreadUser(), "No auth scheme used by Context - Daemon user is always authenticated.");
		}
		if (credentials == null) {
			throw new ContextAuthenticationException("Context cannot authenticate with null credentials.");
		}
		return getUserContext().authenticate(credentials);
	}
	public static void refreshAuthenticatedUser() {
		if (Daemon.isDaemonThread()) {
			return;
		}
		log.debug("Refreshing authenticated user");
		getUserContext().refreshAuthenticatedUser();
	}
	public static void becomeUser(String systemId) throws ContextAuthenticationException {
		log.info("systemId: {}", systemId);
		getUserContext().becomeUser(systemId);
	}
	public static Properties getRuntimeProperties() {
		log.trace("getting runtime properties. size: {}", runtimeProperties.size());
		Properties props = new Properties();
		props.putAll(runtimeProperties);
		return props;
	}
	public static void setRuntimeProperties(Properties props) {
		runtimeProperties = props;
	}
	public static ConceptService getConceptService() {
		return getServiceContext().getConceptService();
	}
	public static EncounterService getEncounterService() {
		return getServiceContext().getEncounterService();
	}
	public static LocationService getLocationService() {
		return getServiceContext().getLocationService();
	}
	public static ObsService getObsService() {
		return getServiceContext().getObsService();
	}
	public static PatientService getPatientService() {
		return getServiceContext().getPatientService();
	}
	public static CohortService getCohortService() {
		return getServiceContext().getCohortService();
	}
	public static PersonService getPersonService() {
		return getServiceContext().getPersonService();
	}
	public static ConditionService getConditionService(){
		return getServiceContext().getConditionService();
	}
	public static DiagnosisService getDiagnosisService(){
		return getServiceContext().getDiagnosisService();
	}
	public static MedicationDispenseService getMedicationDispenseService(){
		return getServiceContext().getMedicationDispenseService();
	}
	public static HL7Service getHL7Service() {
		return getServiceContext().getHL7Service();
	}
	public static UserService getUserService() {
		return getServiceContext().getUserService();
	}
	public static OrderService getOrderService() {
		return getServiceContext().getOrderService();
	}
	public static OrderSetService getOrderSetService() {
		return getServiceContext().getOrderSetService();
	}
	public static FormService getFormService() {
		return getServiceContext().getFormService();
	}
	public static SerializationService getSerializationService() {
		return getServiceContext().getSerializationService();
	}
	public static LogicService getLogicService() {
		return getServiceContext().getLogicService();
	}
	public static AdministrationService getAdministrationService() {
		return getServiceContext().getAdministrationService();
	}
	public static MessageSourceService getMessageSourceService() {
		return getServiceContext().getMessageSourceService();
	}
	public static SchedulerService getSchedulerService() {
		return getServiceContext().getSchedulerService();
	}
	public static AlertService getAlertService() {
		return getServiceContext().getAlertService();
	}
	public static ProgramWorkflowService getProgramWorkflowService() {
		return getServiceContext().getProgramWorkflowService();
	}
	public static MessageService getMessageService() {
		MessageService ms = getServiceContext().getMessageService();
		try {
			if (ms.getMessagePreparator() == null) {
				ms.setMessagePreparator(getMessagePreparator());
			}
			if (ms.getMessageSender() == null) {
				ms.setMessageSender(getMessageSender());
			}
		}
		catch (Exception e) {
			log.error("Unable to create message service due", e);
		}
		return ms;
	}
	public static Properties getMailProperties() {
		Properties p = new Properties();
		String prefix = "mail.";
		for (GlobalProperty gp : getAdministrationService().getGlobalPropertiesByPrefix(prefix)) {
			if (gp.getProperty().equals("mail.transport_protocol")) {
				p.setProperty("mail.transport.protocol", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_host")) {
				p.setProperty("mail.smtp.host", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_port")) {
				p.setProperty("mail.smtp.port", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_auth")) {
				p.setProperty("mail.smtp.auth", gp.getPropertyValue());
			}
			else {
				p.setProperty(gp.getProperty(), gp.getPropertyValue());
			}
		}
		for (String runtimeProperty : runtimeProperties.stringPropertyNames()) {
			if (runtimeProperty.startsWith(prefix)) {
				p.setProperty(runtimeProperty, runtimeProperties.getProperty(runtimeProperty));
			}
		}
		for (String systemProperty : System.getProperties().stringPropertyNames()) {
			if (systemProperty.startsWith(prefix)) {
				p.setProperty(systemProperty, System.getProperty(systemProperty));
			}
		}
		return p;
	}
	private static Session getMailSession() {
		if (mailSession == null) {
			synchronized (Context.class) {
				if (mailSession == null) {
					Authenticator auth = new Authenticator() {
						@Override
						public PasswordAuthentication getPasswordAuthentication() {
							return new PasswordAuthentication(
								ConfigUtil.getProperty("mail.user"),
								ConfigUtil.getProperty("mail.password")
							);
						}
					};
					mailSession = Session.getInstance(getMailProperties(), auth);
				}
			}
		}
		return mailSession;
	}
	private static MessageSender getMessageSender() {
		return new MailMessageSender(getMailSession());
	}
	private static MessagePreparator getMessagePreparator() throws MessageException {
		return new VelocityMessagePreparator();
	}
	public static User getAuthenticatedUser() {
		if (Daemon.isDaemonThread()) {
			return Daemon.getDaemonThreadUser();
		}
		return getUserContext().getAuthenticatedUser();
	}
	public static boolean isAuthenticated() {
		if (Daemon.isDaemonThread()) {
			return true;
		} else {
			try {
				return getAuthenticatedUser() != null;
			} catch (APIException e) {
				log.info("Could not get authenticated user inside called to isAuthenticated(), assuming no user context has been defined", e);
				return false;
			}
		}
	}
	public static void logout() {
		if (!isSessionOpen()) {
			return; 
		}
		log.debug("Logging out : {}", getAuthenticatedUser());
		getUserContext().logout();
		setUserContext(new UserContext(getAuthenticationScheme()));
	}
	public static Set<Role> getAllRoles(User user) throws Exception {
		return getUserContext().getAllRoles();
	}
	public static boolean hasPrivilege(String privilege) {
		if (Daemon.isDaemonThread()) {
			return true;
		}
		return getUserContext().hasPrivilege(privilege);
	}
	public static void requirePrivilege(String privilege) throws ContextAuthenticationException {
		if (!hasPrivilege(privilege)) {
			String errorMessage;
			if (StringUtils.isNotBlank(privilege)) {
				errorMessage = Context.getMessageSourceService().getMessage("error.privilegesRequired",
						new Object[] { privilege }, null);
			} else {
				errorMessage = Context.getMessageSourceService().getMessage("error.privilegesRequiredNoArgs");
			}
			throw new ContextAuthenticationException(errorMessage);
		}
	}
	public static void addProxyPrivilege(String privilege) {
		getUserContext().addProxyPrivilege(privilege);
	}
	public static void removeProxyPrivilege(String privilege) {
		getUserContext().removeProxyPrivilege(privilege);
	}
	public static void setLocale(Locale locale) {
		getUserContext().setLocale(locale);
	}
	public static Locale getLocale() {
		if (!isSessionOpen()) {
			return LocaleUtility.getDefaultLocale();
		}
		return getUserContext().getLocale();
	}
	public static void openSession() {
		log.trace("opening session");
		setUserContext(new UserContext(getAuthenticationScheme())); 
		getContextDAO().openSession();
	}
	public static void closeSession() {
		log.trace("closing session");
		clearUserContext(); 
		getContextDAO().closeSession();
	}
	public static void openSessionWithCurrentUser() {
		getContextDAO().openSession();
	}
	public static void closeSessionWithCurrentUser() {
		getContextDAO().closeSession();
	}
	public static void clearSession() {
		log.trace("clearing session");
		getContextDAO().clearSession();
	}
	public static void flushSession() {
		log.trace("flushing session");
		getContextDAO().flushSession();
	}
	public static boolean isSessionOpen() {
		return userContextHolder.get() != null;
	}
	public static void refreshEntity(Object obj) {
		log.trace("refreshing object: {}", obj);
		getContextDAO().refreshEntity(obj);
	}
	public static void evictFromSession(Object obj) {
		log.trace("clearing session");
		getContextDAO().evictFromSession(obj);
	}
	public static void evictEntity(OpenmrsObject object) {
		log.debug("Clearing DB cache for entity: {} with id: {}", object.getClass(), object.getId());
		getContextDAO().evictEntity(object);
	}
	public static void evictAllEntities(Class<?> entityClass) {
		log.debug("Clearing DB cache for entities of type: {}", entityClass);
		getContextDAO().evictAllEntities(entityClass);
	}
	public static void clearEntireCache() {
		log.debug("Clearing DB cache from all regions");
		getContextDAO().clearEntireCache();
	}
	public static synchronized void startup(Properties props) throws DatabaseUpdateException, InputRequiredException,
	ModuleMustStartException {
		getContextDAO().startup(props);
		checkForDatabaseUpdates(props);
		OpenmrsUtil.startup(props);
		openSession();
		clearSession();
		checkCoreDataset();
		getContextDAO().setupSearchIndex();
		ModuleUtil.startup(props);
	}
	public static synchronized void startup(String url, String username, String password, Properties properties)
			throws DatabaseUpdateException, InputRequiredException, ModuleMustStartException {
		if (properties == null) {
			properties = new Properties();
		}
		properties.put("connection.url", url);
		properties.put("connection.username", username);
		properties.put("connection.password", password);
		setRuntimeProperties(properties);
		openSession(); 
		startup(properties);
		SchedulerUtil.startup(properties);
		closeSession();
	}
	public static void shutdown() {
		log.debug("Shutting down the scheduler");
		try {
			SchedulerUtil.shutdown();
		}
		catch (Exception e) {
			log.warn("Error while shutting down scheduler service", e);
		}
		log.debug("Shutting down the modules");
		try {
			ModuleUtil.shutdown();
		}
		catch (Exception e) {
			log.warn("Error while shutting down module system", e);
		}
		log.debug("Shutting down the context");
		try {
			ContextDAO dao = null;
			try {
				dao = getContextDAO();
			}
			catch (APIException e) {
			}
			if (dao != null) {
				dao.shutdown();
			}
		}
		catch (Exception e) {
			log.warn("Error while shutting down context dao", e);
		}
	}
	public static <T> T getService(Class<? extends T> cls) {
		return getServiceContext().getService(cls);
	}
	public static void addAdvisor(Class cls, Advisor advisor) {
		getServiceContext().addAdvisor(cls, advisor);
	}
	public static void addAdvice(Class cls, Advice advice) {
		getServiceContext().addAdvice(cls, advice);
	}
	public static void removeAdvisor(Class cls, Advisor advisor) {
		getServiceContext().removeAdvisor(cls, advisor);
	}
	public static void removeAdvice(Class cls, Advice advice) {
		getServiceContext().removeAdvice(cls, advice);
	}
	public static void checkCoreDataset() {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ROLES);
			Set<String> currentRoleNames = new HashSet<>();
			for (Role role : Context.getUserService().getAllRoles()) {
				currentRoleNames.add(role.getRole().toUpperCase());
			}
			Map<String, String> map = OpenmrsUtil.getCoreRoles();
			for (Map.Entry<String, String> entry : map.entrySet()) {
				String roleName = entry.getKey();
				if (!currentRoleNames.contains(roleName.toUpperCase())) {
					Role role = new Role();
					role.setRole(roleName);
					role.setDescription(entry.getValue());
					Context.getUserService().saveRole(role);
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core roles for openmrs system", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ROLES);
		}
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_PRIVILEGES);
			Set<String> currentPrivilegeNames = new HashSet<>();
			for (Privilege privilege : Context.getUserService().getAllPrivileges()) {
				currentPrivilegeNames.add(privilege.getPrivilege().toUpperCase());
			}
			Map<String, String> map = OpenmrsUtil.getCorePrivileges();
			for (Map.Entry<String, String> entry : map.entrySet()) {
				String privilegeName = entry.getKey();
				if (!currentPrivilegeNames.contains(privilegeName.toUpperCase())) {
					Privilege p = new Privilege();
					p.setPrivilege(privilegeName);
					p.setDescription(entry.getValue());
					Context.getUserService().savePrivilege(p);
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core privileges", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_PRIVILEGES);
		}
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			Context.addProxyPrivilege(PrivilegeConstants.GET_GLOBAL_PROPERTIES);
			Set<String> currentPropNames = new HashSet<>();
			Map<String, GlobalProperty> propsMissingDescription = new HashMap<>();
			Map<String, GlobalProperty> propsMissingDatatype = new HashMap<>();
			for (GlobalProperty prop : Context.getAdministrationService().getAllGlobalProperties()) {
				currentPropNames.add(prop.getProperty().toUpperCase());
				if (prop.getDescription() == null) {
					propsMissingDescription.put(prop.getProperty().toUpperCase(), prop);
				}
				if (prop.getDatatypeClassname() == null) {
					propsMissingDatatype.put(prop.getProperty().toUpperCase(), prop);
				}
			}
			for (GlobalProperty coreProp : OpenmrsConstants.CORE_GLOBAL_PROPERTIES()) {
				String corePropName = coreProp.getProperty().toUpperCase();
				if (!currentPropNames.contains(corePropName)) {
					Context.getAdministrationService().saveGlobalProperty(coreProp);
					currentPropNames.add(corePropName); 
				} else {
					GlobalProperty propToUpdate = propsMissingDescription.get(corePropName);
					if (propToUpdate != null) {
						propToUpdate.setDescription(coreProp.getDescription());
						Context.getAdministrationService().saveGlobalProperty(propToUpdate);
					}
					propToUpdate = propsMissingDatatype.get(corePropName);
					if (propToUpdate != null && coreProp.getDatatypeClassname() != null) {
						propToUpdate.setDatatypeClassname(coreProp.getDatatypeClassname());
						propToUpdate.setDatatypeConfig(coreProp.getDatatypeConfig());
						propToUpdate.setPreferredHandlerClassname(coreProp.getPreferredHandlerClassname());
						propToUpdate.setHandlerConfig(coreProp.getHandlerConfig());
						Context.getAdministrationService().saveGlobalProperty(propToUpdate);
					}
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core global properties", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			Context.removeProxyPrivilege(PrivilegeConstants.GET_GLOBAL_PROPERTIES);
		}
		AdministrationService as = Context.getAdministrationService();
		Boolean disableValidation = Boolean.valueOf(as.getGlobalProperty(OpenmrsConstants.GP_DISABLE_VALIDATION, "false"));
		ValidateUtil.setDisableValidation(disableValidation);
		PersonName.setFormat(Context.getAdministrationService().getGlobalProperty(
				OpenmrsConstants.GLOBAL_PROPERTY_LAYOUT_NAME_FORMAT));
		Allergen.setOtherNonCodedConceptUuid(Context.getAdministrationService().getGlobalProperty(
				OpenmrsConstants.GP_ALLERGEN_OTHER_NON_CODED_UUID));
	}
	private static void checkForDatabaseUpdates(Properties props) throws DatabaseUpdateException, InputRequiredException {
		boolean updatesRequired;
		try {
			updatesRequired = DatabaseUpdater.updatesRequired();
		}
		catch (Exception e) {
			throw new DatabaseUpdateException("Unable to check if database updates are required", e);
		}
		if (updatesRequired) {
			if (DatabaseUpdater.allowAutoUpdate()) {
				DatabaseUpdater.executeChangelog();
			} else {
				throw new DatabaseUpdateException(
						"Database updates are required.  Call Context.updateDatabase() before .startup() to continue.");
			}
		}
	}
	@Deprecated
	public static void updateDatabase(Map<String, Object> userInput) throws DatabaseUpdateException {
		throw new UnsupportedOperationException("As of 2.4, this method is not longer implemented");
	}
	public static SimpleDateFormat getDateFormat() {
		return OpenmrsUtil.getDateFormat(getLocale());
	}
	public static SimpleDateFormat getTimeFormat() {
		return OpenmrsUtil.getTimeFormat(getLocale());
	}
	public static SimpleDateFormat getDateTimeFormat() {
		return OpenmrsUtil.getDateTimeFormat(getLocale());
	}
	public static boolean isRefreshingContext() {
		return getServiceContext().isRefreshingContext();
	}
	public static <T> List<T> getRegisteredComponents(Class<T> type) {
		return getServiceContext().getRegisteredComponents(type);
	}
	public static <T> T getRegisteredComponent(String beanName, Class<T> type) throws APIException {
		return getServiceContext().getRegisteredComponent(beanName, type);
	}
	public static List<OpenmrsService> getModuleOpenmrsServices(String modulePackage) {
		return getServiceContext().getModuleOpenmrsServices(modulePackage);
	}
	public static VisitService getVisitService() {
		return getServiceContext().getVisitService();
	}
	public static ProviderService getProviderService() {
		return getServiceContext().getProviderService();
	}
	public static DatatypeService getDatatypeService() {
		return getServiceContext().getDatatypeService();
	}
	public static void addConfigProperty(Object key, Object value) {
		configProperties.put(key, value);
	}
	public static void removeConfigProperty(Object key) {
		configProperties.remove(key);
	}
	public static Properties getConfigProperties() {
		Properties props = new Properties();
		props.putAll(configProperties);
		return props;
	}
	public static void updateSearchIndex() {
		getContextDAO().updateSearchIndex();
	}
	public static Future<?> updateSearchIndexAsync() {
		return getContextDAO().updateSearchIndexAsync();
	}
	public static void updateSearchIndexForType(Class<?> type) {
		getContextDAO().updateSearchIndexForType(type);
	}
	public static void updateSearchIndexForObject(Object object) {
		getContextDAO().updateSearchIndexForObject(object);
	}
	public static void setUseSystemClassLoader(boolean useSystemClassLoader) {
		getServiceContext().setUseSystemClassLoader(useSystemClassLoader);
	}
	public static boolean isUseSystemClassLoader() {
		return getServiceContext().isUseSystemClassLoader();
	}
	public static Connection getDatabaseConnection() {
		return getContextDAO().getDatabaseConnection();
	}
}